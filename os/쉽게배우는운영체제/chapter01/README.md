# 1. 운영체제의 개요

## 운영체제 소개
### 운영체제의 필요성
- 컴퓨터는 운영체제가 없어도 작동하는가?
    - 세계의 최초의 컴퓨터로 알려진 애니악
        - 애니악: 진공관으로 만들어진 애니악은 미사일 탄도를 계산하기 위해 개발
    - 에니약을 컴퓨터라고 불리는 이유는 프로그래밍이 가능함 (진공관의 전선을 이용하여 프로그래밍 가능)
- 운영체제가 있는 기계와 없는 기계는 어떤 차이가 있는가?
    - 운영체제를 사용하지 않으면 기계를 만들 당시에 구현한 기능 외에 다른 기능을 추가하거나 성능 향상할 수 없음
    - 운영체제가 있으면 새로운 기능의 추가 성능의 변경이 가능함
- 운영체제는 성능을 향상하는 데에만 필요한가?
    - 자원관리라는 중요한 역할을 함
- 운영체제는 자원을 어떻게 관리하는가?
    - 운영체제는 사용자가 직접 자원에 접근하는 것을 막음으로써 자원을 보호하고 관리함
- 사용자는 숨어 있는 자원을 어떻게 이용할 수 있는가?
    - 운영체제는 사용자가 자원에 직접 접근하지 못하도록 하는 대신 자원을 이용할 수 있는 여러 가지 방법을 제공함
### 운영체제의 정의
- 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어
### 운영체제의 역할
- 자원 관리
- 자원 보호
- 하드웨어 인터페이스 제공
- 사용자 인터페이스 제공
### 운영체제의 목표
- 효율성 (자원 관리)
- 안정성 (자원 보호)
- 확장성 (하드웨어 인터페이스 제공)
- 편리성 (사용자 인터페이스 제공)

## 운영체제의 역사
1. 초창기 컴퓨터 (1940년대)
    - 미사일 탄도 계산을 하기위한 애니악
    - 진공관이라는 소자를 사용하여 진공관이 켜지면 1, 꺼지면 0 (컴퓨터가 2진법을 사용하는 계기)
    - 키보드, 마우스, 모니터와 같은 주변장치와 운영체제가 존재하지 않음
2. 일괄 작업 시스템 (1950년대)
    - 진공관을 전선으로 연결했던 초창기의 컴퓨터는 IC라는 칩으로 만들어짐
    - CPU와 메인 메모리를 사용
    - 천공카드리더를 입력장치로 라인프린터를 출력장치로 사용
    - 프로그래밍이 가능 
        - 천공카드 시스템으로 프로그램을 구성 후카드에 구멍을 뚫어 컴퓨터에 입력을 하면 프로그램이 실행
        - 실행결과는 라인 프린터를 통해 출력
        - 현재의 프로그래밍과 유사한 방식으로 소프트웨어를 개발 가능
    - 한번에 한가지 작업만 실행 가능
        - 모든 작업을 한꺼번에 처리해야하고 프로그램 실행 중간에 사용자가 데이터를 입력하거나 수정하는 것이 불가능, 이러한 시스템을
        **일괄 작업 시스템** 또는 **일괄 처리 시스템**이라고 부름
    - 운영체제가 사용
        - 작은 크기로 사용
        - 메인메모리에 운영체제 상주 영역과 사용자의 사용 영역으로 나뉘어 있음
3. 대화형 시스템 (1960년대 초반)
    - 키보드와 모니터의 등장으로 일괄 작업 시스템의 방식을 획기적으로 바꾸었음
    - 프로그램 실행 중간에 사용자가 입력을 하거나 중간 결과값을 보여줄 수 있음
    - 컴퓨터와 사용자의 대활르 통해 작업이 이루어지므로 **대화형 시스템**이라고 함
    - 일괄 작업 시스템은 계산위주로 작업만 가능했으나 대화형 시스템의 등장으로 문서 편집기, 게임과 같은 다양항 종류의 응용 프로그램을 만들 수 있음
    - 일괄 작업 시스템은 입출력이 없어 작업 시간을 예측할 수 있지만 대화형 시스템의 경우 작업 시간을 예측하기 어려움
        - 입출력 시 얼마 만에 완료될지 예측하기 어렵고 사용자가 언제 반응할지도 알 수 없기때문임
4. 시분할 시스템 (1960년대 후반)
    - 컴퓨터의 크기가 작어지고 계산 능력이 향상
    - 한 번에 하나의 작업만 수행하는 것은 낭비라 효율적으로 사용하기 위해서 다중 프로그래밍 기술이 개발
        - 하나의 CPU를 가지고 여러 작업을 동시에 실행하는 기술
        - 한 번에 하나의 작업만 가능한 일괄 작업 시스템에 비해 효율성이 높음
    - 여러 작업을 조금씩 처리하여 작업이 동시에 이루어지는 것처럼 보이게 하는 것을 **시분할 시스템**이라고 함
    - 시스템내에 많은 작업이 공존할 경우, 중요한 작업이 일정 시간 안에 끝나는 것을 보장하지 못함
5. 분산 시스템 (1970년대 후반)
    - 개인용 컴퓨터 출현으로 개인이 소유하기 쉬어짐
    - 운영체제 시장이 커짐 (매킨토스와 MS-DOS가 많이 사용)
    - 컴퓨터 간의 네트워킹을 위한 TCP/IP프로토콜 정의
    - 개인용 컴퓨터와 인터넷이 보급되면서 값이 싸고 크기가 작은 컴퓨터들을 하나로 묶어 대형 컴퓨터에 버금가는 시스템을 만들게 되었는데 이를 분산 시스템이라고 부름
6. 클라이언트/서버 시스템 (1990년대 ~ 현재)
    - 작업을 요청하는 클라이언트와 요청받은 작업을 처리하는 서버의 이중구조로 나뉨
    - 모든 요청이 서버로 집중하기 때문에 수신만 명의 클라이언트를 처리하기 위해서는 많은 서버와 큰 용량의 네트워크가 필요함
7. P2P 시스템 (2000년대 초반 ~ 현재)
    - 서버의 부하를 줄이기 위해서 **P2P 시스템**이 만들어짐
    - P2P는 서버를 거치지 않고 사용자와 사용자를 직접 연결한다는 의미 (메신저, 파일 공유에 사용)
8. 기타 컴퓨팅 환경 (2000년대 초반 ~ 현재)
- 그리드 컴퓨팅
    - 그리드 컴퓨팅은 분산 시스템의 한 분야로, 서로 다른 기종의 컴퓨터들을 묶어 대용량의 컴퓨터 풀을 구성하고 이를 원격지와 연결하여 대용량 연산을 수행하는 컴퓨팅 환경
- 클라우드 컴퓨팅
    - 클라우드 컴퓨팅은 언제 어디서나 응용 프로그램과 데이터를 자유롭게 사용할 수 있는 컴퓨팅 환경으로 그리드 컴퓨팅과 Sass를 합쳐놓은 형태
- 사물 인터넷
    - 사물 인터넷은 사물에 센서와 통신 기능을 내장하여 인터넷에 연결하는 기술

## 운영체제의 구조
### 커널과 인터페이스
- 커널은 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심적인 기능을 모야놓은 것
- 인터페이스는 커널에 명령을 전달하고 실행 결과를 사용자와 응용 프로그램에 돌려줌
- 유닉스의 사용자 인터페이스는 Shell
    - C Shell, T Shell, Bash Shell 등이 있음
    - 명령어 기반
### 시스템 호출
- 시스템 호출은 커널이 자신을 보호하기 위해 만든 인터페이스
- 커널은 사용자나 응용 프로그램으로부터 컴퓨터 자원을 보호하기 위해 자원에 직접 접근하는 것을 차단
    - 자원을 이용하려면 시스템 호출이라는 인터페이스를 이용하여 접근
- 시스템 호출은 커널이 제공하는 시스템 자원의 사용과 연관된 함수
- 응용 프로그램이 하드웨어 자원에 접근하거나 운영체제가 제공하는 서비스를 이용하려 할 때는 시스템 호출을 사용해야 함
### 드라이버
- 응용 프로그램과 커널의 인터페이스가 시스템 호출이라면 커널과 하드웨어의 인터페이스는 드라이버가 담당
- 커널이 제공하는 드라이버도 있고 하드웨어 제작자가 제공하는 드라이버도 있음
- 하드웨어는 커널과 직접 연결되기도하고 하드웨어 제작자가 제공하는 드라이버를 통해 연결
### 커널의 구성
커널은 프로세스 관리, 메모리 관리, 파일 시스템 관리, 입출력 관리, 프로세스 간 통신 관리 등의 일을 함
#### 단일형 구조 커널
- 커널의 초창기의 운영체제 구조
- 커널의 핵심 기능을 구현하는 모듈들이 구분 없이 하나로 구성
- MS-DOS, VMS, 초기의 유닉스 해당
- 장점
    - 모듈이 거의 분리되지 않았기 때문에 모듈 간의 통신 비용이 줄어들어 효율적인 운영 가능 (함수를 호출하는 오버헤드가 없음)
- 단점
    - 버그나 오류 처리하기가 힘듬
    - 상호 의존성이 높기 때문에 기능상의 작은 혈함이 시스템 전체로 확산될 수 있음
    - 다양한 환경의 시스템에서 적용하기 어려움
    - 현대 운영체제는 매우 크고 복잡하기 때문에 완전 단일형 구조의 운영체제를 구현하기가 어려움
#### 계층형 구조 커널
- 단일형 구조 커널이 발전된 형태로, 비슷한 기능을 가진 모듈을 묵어서 하나의 계층으로 만들고 계층 간의 통신을 통해서 운영체제를 구현하는 방식
- 모듈화를 통해서 버그나 오류를 쉽게 처리 가능
- 오늘날의 운영체제는 대부분 이 구조로 이루어짐
#### 마이크로 구조 커널
- 프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공
    - 커널은 메모리 관리, 프로세스 간의 동기화 서비스를 제공
    - 메모리 관리자와 동기화 모듈은 프로세스 간 통신 모듈로 연결되어 있음
- 다른 커널에 비해 사용자 영역에 구현되어있음
- 각 모듈은 독립적으로 작동하기 때문에 하나의 모듈이 실패하더라도 전체 운영체제가 멈추지 않음
- 이 구조로 사용하는 대폭적인 운영체제인 Mach는 애플의 PC, IOS의 커널로 사용되어 유명해졌음