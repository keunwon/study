# 3. 프로세스와 스레드

## 프로세스 개요
### 프로그램에서 프로세스로의 전환
- 프로세스는 컴퓨터 시스템의 작업 단위로 태스크(task)라고 부름
- 프로세스 제어 블록
    - 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 못함
    - 프로세즈 제어 블록에는 프로세스를 처리하는데 필요한 다양한 정보들이 있음
        - 프로세스 구분자: 프로세스를 구분하는 구분자가 있음
        - 메모리 관련 정보: 프로세스의 메모리 위치 정보를 가지고 있음 (메모리 보호를 위해 경계 레지스터와 한계 레지스터도 포함)
        - 각종 중간값: 프로그램 카운터 저장, 각종 레지스터 같은 중간값 저장
    - 프로그램이 프로세스가 되려면 메모리에 올라오는 것과 동시에 프로세스 제어 블록 생성이 필요함
    - 운영체제 영역에 생성
### 프로세스의 다섯가지 상태
- 생성 상태: 
    - 프로세스가 메모리에 올라와 실행 준비를 완료한 상태 
    - 프로세스 제어 블록 할랑 상태
- 준비 상태: 
    - 실행될 프로세스를 CPU 스케줄러가 선택
    - CPU 스케줄러가 어떤 프로세스 제어 블록을 선택하는 작업을 dispatch 명령으로 처리 
    - dispatch 실행 시 준비상태에서 실행 상태로 변경
- 실행 상태
    - 프로세스가 CPU를 할당받아 실행되는 상태
    - 타임 슬라이스 동안만 작업 가능
        - 시간안에 작업을 처리하지 못하면 timeout 실행, 준비 상태로 변경
        - 작업이 완료되면 exit 실행, 프로세스 정상 종료
        - 실행 상태에서 입출력을 요청하면 CPU는 입출력 관리자에게 요청 후 block, 대기 상태로 변경
- 대기 상태
    - 실행 상태에있는 프로세스가 입출력을 요청한 경우 완료될때까지 기다리는 상태
    - 입출력이 완료되면 인터럽트 발생하면 깨어날 프로세를 찾음 (wakeup), 준비 상태로 변경
- 완료 상태
    - 프로세스 종료
    - 코드와 데이터를 메모리에 삭제, 프로세스 제어 블록 삭제
    - 만약 비정상적으로 프로세스가 종료되면 종료 직전 메로리 상태를 저장장치로 저장 -> 코어 덤프

## 프로세스 제어 블록과 문맥 교환
### 프로세스 제어 블록
- 프로세를 실행하는데 필요한 중요한 정보를 보관하는 자료구조로 TCB (Task Control Block)라고 부름
- 모든 프로세스는 고유한 프로세스 제어 블록을 가짐
### 문맥 교환
- CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업 
- 이때 두 프로세스 제어 블록의 내용 변경

## 프로세스의 연산
### 프로세스의 구조
프로세스는 코드 영역, 데이터 영역, 스택 영역으로 구성
- 코드 영역
    - 프르그램의 본문이 기술된 곳으로 텍스트 영역이라고 함
    - 프로그램은 코드 영역에 탑재되며 탑재된 코드는 읽기 전용으로 처리
- 데이터 영역
    - 프로그램 실행 시 사용되는 각종 데이터를 모아놓은 곳
    - 데이터는 값이기 때문에 읽기와 쓰기가 가능
- 스택 영역
    - 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
### 프로세스의 생성과 복사
사용자가 프로그램을 실행하면 운영체제는 프로그램을 메모리로 가져와 코드 영역에 넣고 프로세스 제어 블록을 생성,  
이후 메모리에 데이터 영역과 스택 영역을 확보 후 프로세스 실행
#### fork() 시스템 호출의 개념
- fork 시스템 호출은 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수 (커널 함수)
- fork 시스템 호출을 사용하면 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어짐
- fork 시스템 호출을 이용하면 실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세라고 함 (부모-자식 관계)
#### fork() 시스템 호출의 동작 방식
- fork를 이용하여 복사한 한 새로운 프로세스는 제어 블록을 보함한 대부분의 영역이 동일  
- 단, 프로세스 제어 블록 내용 중에 일분 내용이 변경
    - 프로세스 구분자 (PID) 값이 변경
    - 메모리 관련 정보 변경
    - 부모프로세스 구분자 (PPID)와 자식 프로세스 구분자 (CPID) 변경 (자식 프로세스가 없으면 CPID의 값은 -1)
#### fork() 시스템 호출의 장점
- 프로세스 생성 속도가 빠름
    - 하드디스크로부터 프로그램을 새로 가져오지 않고 메모리를 복사하기 때문에 자식 프로세스의 생성 속도가 빠름
- 추가 작업 없이 상속 가능
    - 부모 프로세스가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속
- 시스템 관리를 효율적
    - 부모, 자식 프로세스가 구분자로 연결되어있기 때문에, 자식 프로세스를 종료하면 자식 프로세스가 사용하던 자원을 부모 프로세스가 정리 할 수 있음 (프로세스를 종료하려면 메모리 영역, 파일 , 하드웨어 정리가 필요, 부모 프로세스에게 맡김으로서 시스템이 효율적으로 관리)
### 프로세스의 전환
#### exec() 시스템 호출의 개념
- 기존의 프로세스를 새로운 프로세스로 전환하는 함수 (현재의 프로세스와 다른 프로세스로 전환)
- exec() 시스템 호출의 사용목적은 프로세의 구조체를 재활용하기 위함 
    - 새로운 프로세스를 만드려면 프로세의 제어블록을 만들고 메모리의 자리를 확보하는 과정이 필요
    - 프로세스 종료 후 메모리 정리를 위해서 상위 프로세스와 부모-자식 관계를 만들어야 함
    - exec() 사용 시 프로세스 제어 블록, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있음
#### exec() 시스템 호출의 동작 과정
- exec() 시스템 호출 시 코드 영역의 있는 기존의 내용을 지우고 새로운 코드로 변경
- 데이터 영역이 새로운 변수로, 스택영역은 리셋
- 프로세스 제어 블록의 내용 중 프로세스 구분자, 부모 프로세스 구분자, 자식 프로세스 구분자, 메모리 관련 사항 등은 변하지 않음
- 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 사용한 파일 정보가 모두 리셋 (새로운 프로세스를 처음 시작하는 것처럼 내용 정리)

## 프로세의 계층 구조
### 유닉스의 프로세스 계층 구조
- 유닉스 부팅 시 커널 관련 프로세스를 여러개 만드는데, 기중 init 프로세는 전체 프로세스의 출발점
- 프로세스를 효율적으로 관리하기 위해 init 프로세스를 만든 후, init 프로세스의 자식 프로세스로 만듬
- init 프로세스의 자식으로는 login 프로세스, shell 프로세스 등이 있음
### 프로세스 계층 구조의 장점
- 여러 작업 동시 처리
    - 여러 사용자를 동시에 처리하기 위해 fork() 시스템 호출로 login 프로세스를 여러 개 만들어 사용
    - 작업이 완료된 login 프로세스를 exec() 시스템 호출을 사용하여 shell 프로세스로 다시 활용 (기존의 부모-자식 관계 유지)
- 용이한 자원 회수
    - 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템 관리 하기가 수월
    - 만약 모든 프로세스가 독립적으로 만들어지면 프로세스가 종료될 때마다 운영체제가 직접 자원을 회수를 해야하지만 프로세스를 부모-자식 관계로 만들면 자식 프로세스가 작업을 마치면 사용하던 자원을 부모 프로세스가 회수
### 고아 프로세스
- 부모 프로세스가 자식 프로세스보다 먼저 죽어 발생
     - 자식 프로세스가 종료 했지만 자원 정리를 하지 못함 (컴퓨터 자원 낭비)
     - 운영체제는 반환하지 않는 자원들을 주기적으로 회수해야함

## 스레드
### 프로세스와 스레드 차이
프로세스는 약하게 연결되있는 반면 스데드 끼리는 강하게 연결되어있음
- 멀티스레드: 프로세스 내의 여러개의 작업을 여러 개의 스레드로 분할하여 작업의 부담을 줄임
- 멀티태스킹: 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법 (시분할 시스템)
- 멀티프로세싱: CPU를 여러개 사용하여 여러 갱의 스레드를 동시에 처리하는 작업환경 (슈버 스칼라)
- CPU 멀티 스레드: 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스데드를 처리하도록 만드는 병렬 처리 기봅
### 멀티스레드의 구조
- 프로세스는 정적인 영역과 동적인 영역으로 구분
- 멀티스레드는 하나의 프로세스 내에 여러개의 스레드를 생성함
    - 코드, 파일 등의 자원을 공유하여 자원의 낭비를 막고 효율성 향상
    - 스레드는 가벼운 프로세스라고 부름
### 멀티스레드의 장정
- 응답성 향상: 한 스레드가 입출력 작업이 진행하지 않아도 다른 스레드들은 작업을 계속하므로 사용자에의 작업 요구에 빨리 응답
- 자원 공유: 한 프로세스의 자원들을 여러 스레드들이 공유하여 작업
- 효율성 향상: 불필요한 자원의 중복을 막음
- 다중 CPU 지언: 2개 이상의 코어를 가진 CPU를 사용하면 멀티 스레드를 동시에 처리하여 CPU 사용량이 증가하여 처리 시간이 단축
### 멀티스레드 단점
- 한 스레드의 문제가 생기면 전체 프로세스에 영향을 미침

## 멀티스레드 모델
- 커널 스레드
    - 커널이 직접 생성하고 관리하는 스레드
- 사용자 스레드
    - 라이브러리에 의해 구현된 일반적인 스레드
    - 사용자 스레드가 커널 스레드를 사용하려면 시스템 호출로 커널 기능을 이용
### 사용자 스레드
- 사용자 스레드는 운영체제가 멀티스레드를 지원하지 않을 때 사용하는 방법 (초기의 스레드 시스템에 이용)
- 사용자 레벨에서 구현하기 때문에 관련 라이브러리를 사용하여 구현
### 커널 스레드
- 커널 스레드는 커널이 멀티스레드를 지원하는 방식, 하나의 사용자 스레드가 하나의 커널 스레드와 연결되기 때문에 1 to 1 모델이라고 부름
- 커널 스레드는 독립적으로 스케줄링이 되므로 특정 스레드가 대기 상태에 들어가도 다른 스레드는 작업을 계속 할 수 있음
- 멀티 CPU 사용가능하지만 문맥 교환을 할 때 오버헤드 때문에 느리게 작동 함
### 멀티레벨 스레드
- 사용자 스레드와 커널 스레드를 혼합한 방식으로 M to N 모델
- 커널 스레드의 개수가 사용자 스레드보다 같거나 적다
- 하나의 커널 스레드가 대기 상태면 다른 커널 스레드가 대신 작업을 하여 사용자 스레드보다 유연하게 작업을 처리할 수 있음
- 커널 스레드를 같이 사용하기 때문에 오베헤드가 있어 사용자 스레드 만큼 빠르지 않음
- 빠르게 움직여야하는 스레드는 사용자 스레드로 작동하고, 안정적으로 움직여야하는 스레드는 커널 스레드로 작동함

## [심화학습] 동적 할당 영역과 시스템 호출
### 프로세스의 동적 할당 영역
- 스택 영역
    - 호출한 함수가 종료되면 함수를 호출하기 전 코드로 되돌아와야 하는데 되돌아올 메모리의 주소를 스택에 저장  
    (즉, 함수 호출과 복귀 시에 스택이 사용)
    - 지역 변수는 함수가 호출될 때만 사용되다가 함수가 종료되면 사용한 공간을 반환해야 하는데, 지역 변수를 저장할 때 스택이 사용
    - 스택은 동적 영역
- 힙 영역
    - 동적으로 할당도는 변수 영역 (필요할 때 메모리를 차지했다가 필요 없을 때 메모리를 반환)