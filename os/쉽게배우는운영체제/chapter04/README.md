# 4. CPU 스케줄링

## 스케줄링의 개요
### 스케줄링의 단계
- 고수준 스케줄링
    - CPU 스케줄링을 고수준 스케줄링 또는 장기 스케줄링, 작업 스케줄링이라고 함
    - 고수준 스케줄링에서는 전체 시스템의 부하를 고려하여 작업을 시작할지 말지를 결정함  
    (전체 프로세스 수가 결정, 이를 멀티프로그래밍 이라고함)
- 중간 수준 스케줄링
    - 고수준, 저수준 스케줄링 사이에 일어나는 스케줄링
    - 전체 시스템의 활성하된 프로세스 수를 조절하여 과부하를 막음 (일부 프로세스를 보류 상태로 보냄)
    - 보류된 프로세스는 처리 능력에 여유가 생기면 다시 활성화
- 저수준 스케줄링
    - 실제 작업이 이루어짐
    - 저수준 스케줄링은 어떤 프로세스에 CPU를 할당할지, 어떤 기준으로 타임 슬라이스를 정할지, 준비 상태에 있는 프로세스 중 하나를 골라 실행 상태로, 실행 상태 프로세스를 대기 상태로, 대기 상태 프로세스를 준비 상태로 변경

## 스케줄링 시 고려 사항
### 선점형 스케줄링과 비선점형 스케줄링
- 선점형 스케줄링: 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 강제로 CPU를 빼앗을 수 있는 스케줄링 방식
- 비선점형 스케줄링: 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식

## 다중 큐
### 준비 상태의 다중 큐
- 자신의 우선순위에 해당하는 큐의 마지막에 삽입
- 프로세스의 우선순위 배정하는 방식에는 고정 우선순위 방식, 변동 우선순위 방식이 있음
    - 고정 우선순위
        - 운영체제가 프로세스에 우선순위 방식을 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식
        - 구현하기 쉽지만, 시스템의 변화에 대응하기 어려워 효율이 떨어짐
    - 변동 우선순위
        - 우선순위가 프로세스 작업 중간에 변하는 방식
        - 구현하기 어렵지만 시스템의 효율성을 높일 수 있음
### 대기 상태의 다중 큐
- 대기 상태의 다중 큐는 입출력이 완료되기를 기다리는 프로세스들이 모여있음
- 같은 입출력을 요구하는 프로세스끼리 모여 대기 큐를 사용 (HDD, CD-ROM, LAN)
- 대기 큐는 여러개의 프로세스 제어 블록을 동시에 꺼내어 준비상태로 옮김

## 스케줄링 알고리즘
- 비선점 알고르즘: 프로세스가 CPU에 할당을 받으면 작업이 끝날 때까지 CPU를 놓지 않음 (효율이 떨어져서 지금은 거이 사용하지 않음) 
- 선점 알고리즘: 시분할 시스템에을 고려하여 만들어진 알고리즘, 프로세스가 CPU를 할당 받아 실행 중이도 운영체제가 강제로 CPU를 강제로 빼앗을 수 있음
### 스케줄링 알고리즘의 선택 기준
### FCFS 스케줄링
- 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식, 선입선출 스케줄링이라고도 함
- 초기 일괄 작업 시스템에서 사용
- 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 기다려야함 (시스템의 효율성이 떨어짐, 이러한 문제를 콘보이 효과라고 부름)
### SJF 스케줄링
- 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식, 최단 작업 우선 스케줄링이라고도 함
- FCFS 스케줄링의 콘보이 효과를 완화하여 효율성을 높임
- SJF 스케줄리은 프로세스 종료 시간을 파악하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않음
### HRN 스케줄링
- SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결하기 위해 반들어진 비선점형 알고리즘, 최고 응답률 우선 스케줄링이라고도 함
- 대기시간과 CPU 사용 시간을 고려하여 스케줄링을 함
    - 우선순위 = 대기시간 + CPU 사용 시간 / CPU 사용시간
- 여전히 공평이 위배되어 많이 사용하지 않음
### 라운드 로빈 스케줄링
한 프로세스가 타임 슬라이스 동안 작업을 하다 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
### SRT 우선 스케줄링
- SJF 스케줄링과 라운드 로빈 스케줄링을 혼합한 방식으로, 최소 잔류 시간 우선 스케줄링이고도 함 (SJF의 선점형 버전)
- SJF 스케줄링과 마찬가지로 프로세스 종료시간을 예측하기 어렵고 아사 현상이 일어나 자주 사용하지 않음
### 우선순위 스케줄링
- 프로세스의 중요도에 따라 우선쉬를 반영한 스케줄링 알고리즘
- 우선순위 스케줄링은 어떤 기준으로 우선순위를 정하느냐에 따라 다양하게 구현할 수 있음
- 우선순위 알고르짐은 고정 우선순위 알고리즘, 변동 우선순위 알고리즘으로 나눔
    - 고정 우선순위
        - 한 번 우선순위를 부여받으면 종료될 떄까지 우선순위가 고정
        - 단순하게 구현할 수 있지만 시시각각 변하는 시스템에서는 효율적이지 못해 효율성이 떨어짐
    - 변동 우선순위
        - 일정 시간마다 우선순위가 변함
        - 시스템이 복잡하지만 시스템의 상황을 반영하여 효율적적인 운영이 가능
- 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하므로(이에 따른 오버헤드도 발생) 공평성을 위배하고 아사 현상을 일으킴
- 우선순위 시스템은 효율성보다 프로세스의 중요도에 따라 정해짐
### 다단계 큐 스케줄링
- 우선순위에 따라 큐를 여러 개 사용하는 방식
- 운영체제로 받은 우선순위에 따라 프로세스는 우선순위의 큐에 삽입
- 라운드 로빈 방식으로 운영되는 큐는 우선순위에 따라 여러 단계로 나뉘어져 있음
### 다단계 피드백 큐 스케줄링
- 우선순위가 낮은 프로세스에 불리한 다단계 큐 스케줄링의 문제점을 보안한 방식
- 다단계 큐 스케줄링에서는 우선순위가 높은 큐의 프로세스가 CPU를 사용하면 해당 큐의 맨뒤로 들어가지만,  
다단계 피드백 큐는 CPU 할당을 받은 프로세스는 한단계 낮은 우선순의 큐의 끝으로 들어감
    - 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화
    - 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않음
- 우선순위에 따라 타임 스라이스의 크기가 다름 (우선 순위가 낮아질수로 해당 큐의 타임 슬라이스가 커짐)
    - 우선순위가 낮은 프로세스가 우선순위가 높은 프로세스보다 CPU를 얻을 확률이 여전히 낮으므로, 우선순위가 낮은 프로세스는 CPU를 좀 더 오랫동안 사용수 있도록 타임 슬라이스를 크게 설정
- 우선순위가 가장낮은 프로세스는 무한대의 타임 슬라이스를 얻음
    - 다단계 피드백 큐 스케줄링에서 마지막 큐는 순서대로 작업을 마치는 FCFS 스케줄링 방식으로 동작
- 다단계 피드백 큐는 오늘날의 운영체제 CPU 스케줄링을 위해 일반적으로 사용하는 방식, 변동 우선순위 알고리즘의 전형적인 예이다
- 유닉스 운영체제에서 타임 슬라이스를 고정하지 않고 10 ~ 200ms 사이에서 조정하는 이유는 다단계 피드백 큐 스케줄링을 사용하기 위해서

## [심화학습] 인터럽트 처리
### 인터럽트의 개념
입출력뿐만 아니라 시스템을 보호하는데 매우 중요한 작업  
프로세스가 사용 중인 메모리 영역을 침범하면 CPU에 있는 메모리 관련 레스터가 인터럽트를 발생시켜 해당 프로세스를 강제로 종료
### 동기적 인터럽트와 비동기적 인터럽트
인터럽트는 프로세스가 실행 중인 명령어로 인해 발생하는 동기적 인터럽트, 실행 중인 명령어와 무관하게 발생하는 비동기적 인터럽트로 나뉨
- 동기적 인터럽트 (사용자 인터럽트)
    - 프로그램상의 문제 때문에 발생하는 인터럽트 (다른 메로리 영역에 접근, 오버플로 언더플로)
    - 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트
    - 입출력장치 같은 주변장치의 조작에 의한 인터럽트
    - 산술 연산 중 발생하는 인터럽트
- 비동기 인터럽트
    - 하드디스크 오류, 메모리 불량과 같은 하드웨어적인 오류 발생하는 인터럽트 (마우스, 키보드)