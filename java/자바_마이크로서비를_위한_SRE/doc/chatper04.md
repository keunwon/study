# 4. 차트와 경고
- 모니터링에 사활을 걸 필요는 없음
- 측정 지표는 한번에 하나씩 추가하는게 좋음
- 점진적인 접근 방식은 경고 알림 체계를 도입할 때도 중요 (견고한 신뢰 관계는 단시간에 구축되지 않음)
## 4.1. 모니터링 시스템의 차이
- 메트릭 시스템은 시간적 정보뿐만 아니라 게이지, 카운터, 히스토그램, 백분위 등을 집계해서 나타낼 수 있음
- 자신이 선택한 메트릭 측정도구가 모니터링 시스템을 교체해도 유연하게 대응할 수 있을지 사전에 충분히 고려하는 것이 좋음
## 4.2. 서비스 수준 지표의 효과적인 시각화
- 필자는 차트를 구성할 때 선은 굵게, 잉크는 적게 쓰는 것을 선호
### 4.2.1. 선 두깨오 음영
- 가독성을 높이려면 선 두께를 2px늘리고 음영을 제거
### 4.2.2. 에러 vs 성공
- 성공과 에러는 단순히 색상만이 아닌 다른 방식으로 시각적 지표를 제공해야 함 (성곡적인 처리 결과는 누적 그래프, 에러는 굵은 점으로 표시해 눈에 잘 띄도록 만듬)
### 4.2.3. '상위 k' 시각화
- 모니터링을 하다 보면 특정 범주에서 '최악'의 결과들만 확인하는 경우가 많음
- 모니터링 시스템 대부분은 일정한 기준으로 '상위 k' 시계열을 선택하는 쿼리 기능을 제공
### 4.2.4. 프로메테우스 비율 간격
- 범위 벡터의 간격은 보통 1분으로 설정된 스크래핑 간격보다 최소 두 배만큼 넓게 잡을 것을 권함
## 4.3. 게이지
- 게이지 시계열을 나열하면 순간 게이지를 모니터링할 때보다 더 많은 정보를 얻음
- 게이지 데이터는 순간적인 값이며 모니터링 시스템은 그대로 그림
## 4.4. 카운터
- 카운터는 주로 최대(가끔 최소) 임곗값과 비교하는 용도로 쓰임
- 카운터는 누적 통계가 아닌 비율로 관찰해야 함 (카운터 통계가 모니터링 시스템에 어떻게 저장되는지는 중요하지 않음)
## 4.5. 타이머
- 처리량, 최대 레이턴시, 레이턴시 저하, 총 레이턴시 등의 정보를 얻음
- 자바 애플리케이션에 최대 소요 시간이 99번째 백분위를 상회하는 경우는 아주 흔함, 경고 발생 기준을 최대 레이턴시에 설정하는 것이 좋음
## 4.6. 대시보드 생성을 중지해야 할 때
- 엔지니어의 목표는 경고가 발생한 문제의 근본적인 원인을 규명하는 것
- 이상적인 대시보드는 경고과 즉각적으로 연결되며 경고과 관련된 정보를 차원적으로 탐색할 수 있도록 구성
- 히트맵은 단순히 선 그래프를 그릴 때보다 연산 비용이 훨씬 더 많이 듬
	- 차트가 하나라면 문제가 없지만 대규모 조직에서 여러 비즈니스에 각기 다른 화면을 출력한다면 전체적인 모니터링 시스템 유지 비용이 부담스러운 수준까지 상승 함
- 차트는 경고를 대체할 수 없음
	- 먼저 적절한 대상자에게 적절한 알림을 보내는 것이 주력하기 바람, 화면 구성은 그 다음
- SLO 위반 경고를 항상 비상 상태로 취급할 필요는 없음
## 4.7. 모든 자바 마이크로서비스에 통용되는 서비스 수준 지표
### 4.7.1. 에러
- 전체 실행 중 실패한 실행의 비중이 곧 시스템에 발생한 에러의 빈도
- 클라이언트 에러와 서버 에러를 구분해야 함
	- 클라이언트 에러율은 침입 감지에 적합한 지표이지만, 서버 에러보다 임곗값이 훨씬 높다는 점을 유념해야 함
- 에러 비중은 정규화하기 쉽고 고정된 임계점을 선정하기도 쉬움
- 처리량이 낮은 서비스는 에러율일 에러 비중보다 유용함
### 4.7.2. 레이턴시
- 대중적인 자바 웹 프레임워크는 대부분 메트릭 자동 설정 방식으로 '화이트박스'측정을 지원, 풍부한 태그 정보를 이용해 인/아웃 바운드 요청을 모니터 할 수 있음
- 서버(인바운드) 요청
	- http.server.requests 라는 타이머 메트릭을 RESET 엔드포인트에 자동적으로 설정(mvc, webflux 모두 적용)
	- 특정 API 엔드 포인트에 집합에 백분위 히스토그램을 설정하면 @Timed 에노테이션을 설정
- 클라이언트 요청(아웃바운드)
	- http.client.requests 타이머 메트릭을 자동을 설정
### 4.7.3. 가비지 수집 다운타임
- 최대 다운타임
	- GC는 최종 사용자의 응답 시간에 직접적으로 영향을 미침
- 가비지 수집에 소요된 시간 비중
	- jvm.gc.pause 타이머는 합계 정보를 독립적으로 제공
	- 합계 변화량을 시간 간격으로 나누면 CPU가 가비지 수집 시간의 비중을 구할 수 있음
- 대규모 할당 경고 
	- G1 수집기의 대규모 할당을 감지하면 jvm.gc.pause 메트릭에서 cause 태그를 관찰
		- 태그 값이 G1 Humongous Allocation 인 항목이 발견되면 대규모 할당이 발생
### 4.7.4. 힙 사용률
- young generation
	- 신규 객체는 이곳에 할당 (가득차면 보조 가비지 수집 이벤트가 발생)
- survivor space
	- 보조 가비지 수집이 발생하면 모든 생존 객체가 이 영역에 복사
	- 생존 임계점이 도달하면 old 영역으로 승격
- old generation
	- 오래 살아남은 객체가 저장되는 공간
- 수집 후 풀 메모리 저하
	- jvm.memory.usage.after.gc 마지막 가비지 수집 후 '이전 세대'의 힙 사용을 추가
	- [0, 1] 범위의 비율이며 이 수치가 높으면 수집기가 가비지를 충분히 청하지 못했다는 의미
		- 90% 정도의 임계점으로 설정하면 적당
### 4.7.5. CPU 사용률
- 블록킹 서블릿 모델로 개발된 애플리케이션은 일반적으로 80%로 임계 수준으로 고정하면 적당, 반응형 애플리케이션에서 적정 포화도 수준을 결정하려면 경험에 의존해야 함
### 4.7.6. 파일 설명자
- 일반적인 기술로 제작된 애플리케이션이나 웹 프레임워크는 파일 설명자가 5%를 넘지 않음
- 애플리케이션이 수많은 호출에 응답하며 개방하는 소켓들은 파일 설명자를 한계까지 늘리는 원인
	- HTTP 연결, 데이터베이스 접속 등도 마찬가지
	- 파일 설명자가 부족하면 프로세스가 정상적으로 종료되지 않는 현상이 나타남
- 마이크로미터 메트릭
	- process.max.fds: 최대 열람 가능 파일 설명자 (ulimit -a 조회결과과 동일)
	- process.open.fds: 열려 있는 파일 설명자
- 일반적으로 열려있는 파일 설명자 개수는 최댓값 미만으로 유지되어야 하므로 80% 정도로 고정된 임곗값과 대조하면 적절히 문제를 식별할 수 있음
### 4.7.7. 비정상 트래픽
- 에러와 달리 상태 코드는 처리량이 아닌 요청 건수 대비 발생 비율로 모니터링 해야 함
### 4.7.8. 배치 및 장기 실행 작업
- 장기 실행 작업을 모니터링하려면 인플라이트 또는 활성 작업의 실행 시간을 측정해야 함(LongTaskTimer 사용)
