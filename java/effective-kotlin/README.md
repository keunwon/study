# 이펙티브 코틀린

## 코틀린의 철학
- 생산성: 애플리케이션을 빠르게 생산합니다
- 확장성: 애플리케이션의 규모가 커져도, 개발 비용이 급격하게 증가하지 않습니다
- 유지보수성: 유지보수를 굉장히 쉽게 할수 있습니다
- 신뢰성: 애플리케이션이 예상한 대로 동작하므로 오류가 적습니다
- 효율성: 애플리케이션이 굉장히 빠르게 동작하면, 리소스가 적게 필요합니다

## 1부. 좋은 코드
### 1장. 안정성
#### 아이템 1: 가변성을 제한하라
- 상태를 갖게 하는 것은 양날의 검
    - 시간의 변화에 따라서 변화하는 요소를 표현할 수 있다는 것은 유용, 상태를 적절히 관리하는 것은 어려움
    - 프로그램을 이해하고 디버그하기 힘듬
    - 코드의 실행을 추론하기 어려움 (시점에 따라 값이 달라질 수 있음)
    - 멀티스레드 환경에서는 적절한 동기화가 필요
    - 테스트 하기 어려움 (모든 상태를 테스트가 필요, 변경이 많을수록 더 많은 조합을 테스트해야 함)
    - 상태 변경이 일어날 때, 다른 부분에 알려야 하는 경우가 있음
- 코틀린에서 가변성 제한하기
    - 읽기 전용 프로퍼티(val)
    - 가변 컬렉션과 읽기 전용 컬렉션 구분
    - 데이터 클래스의 copy
- 다른 종류의 변경 가능 지점
    - 첫째번째: mutable 컬렉션을 사용, 두번째: var로 읽고 쓸 수 있는 프로퍼티 사용
    - mutable 컬렉션을 사용하는 것이 처음에는 더 간단하게 느껴지겠지만, mutable 프러퍼티를 사용하면 객체 변경을 제어하기 더 쉬움
    - 최악의 방식은 프로퍼티와 컬렉션을 모두 변경 가능한 지점으로 만드는 것
- 변경 가능 지점 노출하지 말기
    - 상태를 나타내는 mutable 객체를 외부에 노출하는 것은 굉장히 위험
    - 돌발적인 수정이 이어날 때 위험할 수 있음
        - 방어적 복제(defensive copying)로 해결
        - 컬렉션은 객체를 일긱 전용 슈퍼타입으로 업캐스트하여 가변성을 제한
- 정리
    - var 보다는 val
    - mutable 보다는 immutable 프로퍼티 사용
    - mutable 객체와 클래스보다는 immutable 객체와 클래스를 사용
    - 변경이 필요한 대상을 만들어야 한다면, immutable 데이터 클래스로 만들고 copy 활용
    - 컬렉션에 상태를 저장해야 한다면, mutable 컬렉션보다는 읽기 전용 컬렉션을 사용
    - mutable 객체를 외부에 노출하지 않는 것이 좋음
#### 아이템 2: 변수의 스코프를 최소화하라
 - 프로퍼티보다는 지역 변수를 사용하는 것이 좋음
 - 최대한 좁은 스코프를 갖게 변수를 사용
    - 프로그램을 추적하고 관리하기 쉬움
- 변수는 읽기 전용 또는 읽고 쓰기 전용 여부와 상관없이, 변수를 정의할 때 최기화되는 것이 좋음
- 캡처링
    - 시퀀스 빌더를 사용해서 
#### 아이템 3: 최대한 플랫폼 타입을 사용하지 말라
- 플랫폼 타입이란, 다른 프로그래밍 언어에서 전달되어서 nullable인지 아닌지 알 수 없는 타입
- 플랫폼 타입은 타입 이름 뒤에 '!' 기호를 붙여서 표기
- 플랫폼 타입은 안전하지 않으므로, 최대한 빨리 제거하는 것이 좋음
#### 아이템 4: inferred 타입으로 리턴하지 말라
- 코틀린의 타입 추론(type inference)은 JVM 세계에서 가장 널리 알려진 코틀린의 특징
- 자바도 자바10부터 코틀린을 따라 타입 추론을 도입
- inferred 타입은 정확하게 오른쪽에 있는 피연사에 맞게 설정 (슈퍼클래스 or 인터페이스로 설정 불가)
- 리턴 타입은 외부에서 확인할 수 있게 명시적으로 지정해 주는 것이 좋음
- 정리
    - 타입을 확실하게 지정해야 하는 경우 명시적으로 타입을 지정해야 함
    - 안전을 위해서 외부 API를 만들 때는 반드시 타입을 지정하고, 지정한 타입을 특별한 이유와 확실한 확인 없이는 제거하지 말자
#### 아이템 5: 예외를 활용해 코드에 제한을 걸어라
- require: 아규먼트를 제한
- check:  상태와 관련된 동작을 제한
- assert: 어떤 것이 true인지 확인 (assert 블록은 테스트 모드에서만 작동)
- return or  throw와 함께 활용하는 Elvis 연산자
- 제한을 걸어 주면 다양한 장점
    - 제한을 걸면 문서를 보지 않은 개발자도 문제를 확인
    - 예상하지 못한 동작을 하지 않고 예외를 throw 함
    - 코드가 어느정도 자체적으로 검사
    - 스마트 캐스트 기능을 활용
- 아규먼트(require)
    - 예제
        - 숫자를 아규먼트로 받아서 팩토리얼 계산한다면 숫자는 양의 정수여야 함
        - 좌표들을 아큐먼트로 받아서 클러스터를 찾을 때는 비어 있지 않은 좌표 목록이 필요함
        - 사용자로부터 이메일 주소를 입력받을 때는 값이 입려되어 있는지, 이메일 형식이 올바른지 확인
- 상태(check)
    - 예제
        - 어떤 객체가 미리 초기화되어 있어댜지만 처리를 하게 하고 싶은 함수
        - 사용자가 로그인했을 때만 처리를 하게 하고 싶은 함수
        - 객체를 사용할 수 있는 시점에 사용하고 싶은 함수
    - require와 비슷하지만 지정된 예측을 만족하지 못할 때, 상태가 올바른지 확인할 때 사용
    - 일반적으로 require 블록 뒤에 배치
- Assert 계열 함수 사용
    - 단위 테스트 대신 함수에서 assert를 사용하면 장점
        - Assert 계열의 함수는 코드를 자체 점검하며, 더 효율적으로 테스트
        - 특정 상황이 아닌 모든 상황에 대한 테스트 확인
        - 실행 시점에 정확하게 어떻게 되는지 확인할 수 있음
        - 실제 코드가 더 빠른 시점에 실패하게 만듬 (예상하지 못한 동작이 언제 어디서 실행되었는지 쉽게 찾을 수 있음)
    - 이를 활용해도 단위 테스트는 따로 작성해야 함
    - assert는 파이썬에서 굉장히 많이 사용되고, 자바에서는 딱히 사용되지 않음 (코틀린에서 안정적으로 코드를 만들고 싶을 때 양념처럼 사용할 수 있음)
- 정리
    - 제한을 훨씬 더 쉡게 확인
    - 애플리케이션을 더 안정적으로 지킬수 있음
    - 코드를 잘못 쓰는 상황을 막을 수 있음
    - 스마트 캐스팅을 활용
#### 아이템 6: 사용자 정의 오류보다는 표준 오류를 사용하라
- 가능하다면 직접 오류를 정의하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 좋음
- 표준 라이브러리의 오류는 많은 개발자가 알고 있으므로, 이를 재사용하는 것이 좋음
- 일반적으로 사용되는 예외
    - IllegalArgumentException or IllegalStateException: require, check 사용하여 throw 할 수 있는 예외
    - IndexOutOfBoundsException: 인덱스 파라미터의 값이 범위를 벗어남
    - ConcurrentModificationException: 동시 수정을 금지했는데 발생했을 때
    - UnsupportedOperationException: 사용자가 사용하려고 했던 메서드가 현재 객체에서는 사용할 수 없다는 것을 나타냄
    - NoSuchElementException: 사용자가 사용하려고 했던 요소가 존재하지 않음
#### 아이템 7: 결과 부족이 발생할 경우 null과 Failure를 사용하라
- 함수가 원하는 결과를 만들어 낼 수 없을 때가 있음
    - null or '실패를 나타내는 sealed클래스(일반적으로 Failure라는 이름붙임)' 반환
    - 예외를 throw 함
- 예외는 정보를 전달하는 방법으로 사용해서는 안됨
- 예외는 잘못된 특별한 상황을 나타내야 하며, 처리
- null or Failure는 예상되는 오류를 표현할 때 굉장히 좋음
    - 명시적, 효율적이며 간단한 방법으로 처리
    - 예측할 수 있는 범위의 오류는 null or Failure를 사용
    - 예측하기 어려운 예외적인 범위의 오류는 예외를 throw해서 처리하는 것이 좋음
    - try-catch 블록 내부에 코드를 배치하면, 컴파일러가 할 수 있는 최적화가 제한
#### 아이템 8: 적절하게 null을 처리하라
- nullable 타입은 세가지 방법으로 처리
    - ?., 스마트 캐스팅, Elvis 연산자 등을 활용해서 안전하게 처리
    - 오류를 throw 
    - 함수 또는 프로퍼티를 리팩터링해서 nullable 타입이 나오지 않게 바꿈
- not-null assertion(!!)과 관련된 문제
    - '!!'연산자를 사용하는 방법은 좋은 방법이 아님 (문제는 미래의 어느 순간에 일어남)
    - lateinit or Delegates.notNull 대체하여 사용
    - 코틀린을 대상으로 설계된 API를 활용한다면 '!!' 연산자를 사용하는 것은 이상하게 생각해야 함
- 의미 없는 nullability 피하기
    - 클래스에서 nullability에 따라 여러 함수를 만들어서 제공 (ex. get(), getOrNull())
    - 어떤 값이 클래스 생성 이후 확실하게 설정된다는 보장이 있다면 lateinit or Delegates.notNull 사용
    - 빈 컬렉션 대신 null 리턴하지 말기
- lateinit 프로퍼티와 notNull 델리게이트
    - lateinit 사용
        - 비용 발생
        - 초기화 전에 값을 사용하려면 예외 발생
        - Int, Long, Double, Boolean 같은 기본 타입과 연결된 타입은 사용할 수 없음
            - Delegates.notNull 사용해서 해결
#### 아이템 9: use를 사용하여 리소를 닫아라
- use 사용하면 Closeable/AutoCloseable을 구현한 객체를 쉽고 안전하게 처리할 수 있음
- 파일을 처리할 때는 파일을 한 줄씩 읽어 들이는 useLines를 사용하는 것이 좋음
#### 아이템 10: 단위 테스트를 만들어라
- 코드를 안전하게 만드는 가장 궁극적인 방법은 다양한 종류의 테스트를 하는 것
- 단위 테스트는 개발자가 작성하며, 개발자에게 유용
- 테스트가 잘 만들어져 있다면, 리팩터링하는 것이 두렵지 않음
- 수동 테스트보다 단위 테스트로 확인하는 것이 빠름
- 단점
    - 단위 테스트를 만드는데 시간이 걸림
    - 테스트를 활용할 수 있게 코드를 조정
    - 좋은 단위 테스트를 만드는 작업이 꽤 어려움
        - 잘못 만들어진 단위 테스트는 득보다 실이 큼
### 2장. 가독성
#### 아이템 11: 가독성을 목표로 설계하라
- 인식 부하 감소
    - 가독성이란 코드를 읽고 얼마나 빠르게 이해할 수 있는지를 의미함
    - 뇌는 기본적으로 짧은 코드를 빠르게 읽을 수 있겠지만, 익숙한 코드는 더 빠르게 읽을 수 있음
- 컨벤션
    - 연산자는 의미에 맞게 사용 (invoke 형태로 사용하면 안됨)
    - invoke 연산자와 함께 '람다를 마지막 아규먼트'로 사용하는 것은 신중해야 함
#### 아이템 12: 연산자 오버로드를 할 때는 의미에 맞게 사용하라
- 분명하지 않은 경우
    - 관례를 충적하는지 아닌지 확실하지 않을 때가 문제
    - 의미가 명확하지 않다면, infix를 활영한 확장 함수를 사용하는 것이 좋음
    - 최상위 함수를 사용하는 것도 좋음
- 규칙을 무시해도 되는 경우
    - 도메인 특화 언어(DSL)를 설계할 때
- 정리
    - 연산자 오버라이딩은 그 이름의 의미에 맞게 사용
    - 연자의 의미가 명확하지 않다면, 연산자 오버로딩을 사용하지 않는 것이 좋음
        - infix 확장 함수, 최상위 함수 사용
#### 아이템 13: Unit?을 리턴하지 말라
- 'Unit?' 표현하는 것은 오해의 소지가 있으며, 예측하기 어려운 오류를 만들 수 있음
- 'Unit?' 리터한거나, 이를 기반으로 연산하지 않는 것이 좋음
#### 아이템 14: 변수 타입이 명확하지 않은 경우 확실하게 지정하라
- 가독성 향상 이외에 안전을 위해서도 타입을 지정하는 것이 좋음
- 타입을 무조건 지정하라는 것이 아님(상황에 맞게 사용)
#### 아이템 15: 리시버를 명시적으로 참조하라
- 여러 개의 리시버
    - 스코프 내부에 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내면 좋음
    - also, let을 사용하는 것이 nullable 값을 처리할 때 훨씬 좋은 선택
    - 리시버가 명확하지 않다면, 명시적으로 리시버를 적어서 이를 명확하게 해줘야 함
- DSL 마커
    - 코틀린 DSL 사용할 때는 여러 리시버를 가진 요소들이 중첩되더라도, 리시버를 명시적으로 붙이지 않음
- 정리
    - 짧게 적을 수 있다는 이유만으로 리시버를 제거하지 말기
    - 여러개의 리시버가 있는 상황 등에는 리시버를 명시적으로 적어 주는 것이 좋음
    - 리시버를 명시적으로 지정하면 어떤 리시버의 함수인지를 명확하게 알 수 있으므로 가독성 향상
    - DSL에서 외부 스코프에 있는 리시버를 명시적으로 적게 강제하고 싶다면, DSLMarker 메타 에노테이션을 사용
#### 아이템 16: 프로퍼티는 동작이 아니라 상태를 나타내야 한다
- val 사용해서 읽기 전용 프로퍼티를 만들 때는 field가 만들어지 않음
- 인터페이스에도 프로피터를 정의할 수 있음
- 프로퍼티는 본질적으로 함수이므로, 확장 프로퍼티를 만들 수도있음
- 프로퍼티는 원칙적으로 상태를 나타내거나 설정하기 위한 목적으로만 사용하는 것이 좋고, 다른 로직 등을 포함하지 않아야 함
- 프로퍼티 대신에 함수를 사용하는 것이 좋은 경우
    - 연산 비용이 높거나, 복잡도가 O(1)보다 큰 경우
    - 비즈니스 로직을 포함하는 경우
    - 같은 동작을 연속적으로 두 번했는데 다른 값이 나올 수 있다면, 함수를 사용하는 것이 좋음
    - 게터에서 프로피터의 상태가 변경이 일어나는 경우 함수를 사용하는 것이 좋음
#### 아이템 17: 이름 있는 아규먼트를 사용하라
- 디폴트 아규먼트의 경우 아규먼트 이름 사용
    - 프로퍼티가 디폴트 아규몬트를 가질 경우, 항상 이름을 붙여서 사용하는 것이 좋음
- 같은 타입의 파라미터가 많은 경우 아규먼트 이름 사용
- 함수 타입 파라미터
    - 함수 타입 파라미터는 마지막 위치에 배치하는 것이 좋음
#### 아이템 18: 코딩 컨벤션을 지켜라
- 컨벤션 도구
    - intellij 포메터
    - klint
- 많은 파라미터를 갖고있는 클래스, 함수는 각각의 파라미터를 한 줄씩 작성하는 방법을 사용
- 프로젝트의 모든 코드는 마치 한사람이 작성한 것처럼 작성되어야 함

## 2부. 코드 설계
### 3장. 재사용성
#### 아이템 19: knowledge를 반복하여 사용하지 말라
- 프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다
- knowledge
    - 프로그래밍에서 knowledge는 넓은 의미로 '의도적인 정보'를 뜻함
    - 로직: 프로그램이 어떠한 식으로 동작하는지와 프로그램이 어떻게 보이는지
    - 공통 알고리즘: 원하는 동작을 하기 위한 알고리즘
- 모든 것은 변화한다
    - 모든 것은 변화하고, 우리는 이데 대비해야 함
    - 변화할 때 가장 큰 적은 knowledge가 반복되어 있는 부분
    - knowledeg 반복은 프로젝트의 확장성을 막고, 쉡게 깨지게 만듬
- 언제 코드를 반복해도 될까?
    - 함께 변경될 가능성이 높은가? 따로 변경될 가능성이 높은가? 라는 질문으로 결정
    - 코드를 추출하는 이유는 변경을 쉽게 만들기 위함
- 단일 책임 원칙
    - 단일 책임 원칙이란 '클래스를 변경하는 이유는 단 한가지여야 한다'라는 의미
    - 서로 다른 곳에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많음(완전히 다른 knowledge로 취급하는 것이 좋음)
#### 아이템 20: 일반적인 알고리즘을 반복해서 구현하지 말라
- 나만의 유틸리티 구현하기
    - 함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋음 (side-effect 없는게 좋음)
    - 최상위 함수와 비교해서, 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있으므로 좋음
    - 수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 확장 리시버로 사용하는 것이 가독성 측에서 좋음
    - 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능 등으로 제안이 이루어지므로 쉽게 찾을 수 있음
- 정리
    - 일반적인 알고리즘을 반복해서 만들지 않기
    - 대부분 stdlid에 이미 정의되어 있을 가능성이 높음
#### 아이템 21: 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라
- 프로퍼티 위임을 사용하면 일반적인 프로퍼티의 행위를 추출해서 재사용할 수 있음
    - 대표적인 예로 지연 프로퍼티가 있음
- 프로퍼티 위임을 사용하면, 이외에도 변화가 있을 때 이를 감지하는 observable 패턴을 쉽게 만들 수 있음
- 코틀린은 프로퍼티 위임을 사용해서 간단하고 type-safe하게 구현할 수 있음
- getValue, setValue 메서드가 여러개 있어도 문제가 없음
    - 상황에 따라서 적절한 메서드가 선택
#### 아이템 22: 일반적인 알고리즘을 구현할 때 제네릭을 사용하라
- 타입 파라미터는 컴파일러에 타입과 관련된 정보를 제공하여 컴파일러가 타입을 조금이라도 더 정확하게 추측할 수 있게 해줌
- 제너릭 제한
    - 타입 파라미터의 중한 기능 중 하나는 구체적인 타입의 서브타입만 사용하게 제한하는 것
#### 아이템 23: 타입 파라미터의 섀도잉을 피하라
- 쉐도잉: 지역 파라미터가 외부 스코프에 있는 파라미터를 가릴때 (파라미터 이름을 사용하는 경우)
- 타입 파라미터 쉐도잉을 피해야 함
- 타입 파라미터 새도잉이 발생한 코드는 이해하기 어려울 수 있음
#### 아이템 24: 제네릭 타입과 variance 한정자를 활용하라
- 함수 타입
    - 함수 타입을 사용할 떄는 자동으로 variance 한정자가 사용
    - 코틀린 함수 타입의 모든 파라미터 타입은 contravariant(in)
    - 모든 리턴 타입은 covariant(out)
- variance 한정자의 안정성
    - 자바의 배열은 convariant
        - 배열 기반으로 제네릭 연산자는 정렬 함수 등을 만들기 위해서
#### 아이템 25: 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라
- 풀스택 개발
    - 코틀린이 자바스크립트로 컴파일될 수 있음
    - 코틀린을 활용하여 다양한 웹 애플리케이션을 만들 수 있음 (백엔드 + 프론트)
    - 단순하게 만들 수 있다는 개념을 떠나서, 서로 코드를 공유할 수 있다는 의미
- 모바일 개발
    - 코틀린의 멀티 플랫폼 기능을 활용하면, 로직을 한 번만 구현하고, 두 플랫폼에서 이를 재사용할 수 있음 (android, ios)
- 라이브러리
    - 공통 모듈을 정의할 수 있다는 것은 라이브러리에 있어서 강력한 도구
    - 플랫폼에 크게 의존하지 않음
- 함께 사용하기
    - 코틀린/jvm 백엔드 개발: 스프링, Ktor 등
    - 코트린/js 웹사이트 개발: 리액트 등
    - 코틀린/jvm 안드로이드 개발: 안드로이드 SDK 등
    - 코틀린/네이티브 Objective-C/스위프트로 IOS 개발
    - 코틀린/jvm 사용한 데스크톱 개발: TornadoFX 등
    - 코틀린/네이티브로 사용한 라이베리파이, 리눅스, macOS 프로그램 개발
### 4장. 추상화 설계
- 추상화는 프로그래밍 세계에서 가장 중요한 개념 중 하나
- 프로그래밍에서의 추상화
    - 추상화를 설계한다는 것은 단순하게 모듈 또는 라이브러리로 분리한다는 의미가 아님
    - 강력한 프로그래밍 언어들이 당연히 갖고 있는 기능 중 하나는 공통 패턴에 이름을 붙여서 추상화를 만든느 기능
        - 함수, 델리게이트, 클래스 등이 대표적인 예
- 추상화 목적
    - 복잡성을 숨기기 위해
    - 코드를 체계화하기 위해
    - 만드는 사람에게 변화의 자유를 주기 위해
#### 아이텀 26: 함수 내부의 추상화 레벨을 통일하라
- 추상화 레벨
    - 높은 레벨로 갈수록 물리 장치로부터 점점 멀어짐
    - 프로그래밍에서는 일반적으로 높은 레벨일수록 프로세서로부터 멀어진다고 표현
    - 높은 레벨일수록 단순함을 얻지만, 제어력을 잃음
- 추상화 레벨 동일
    - 함수도 높은 레벨과 낮은 레벨을 구분해서 사용해야 한다는 원칙이 있음
        - 추상화 레벨 통일 (Single Level of Abstraction, SLA)원칙이라고 부름
    - 함수는 간단해야 함
#### 아이템 27: 변화로부터 코드를 보호하려면 추상화를 사용하라
- 상수
    - 리터널은 아무것도 설명하지 않음
    - 반복적으로 등장하는 리터럴을 상수 프로퍼티로 변경하면 해당 값에 의미있는 이름을 붙일 수 있음
    - 상수의 값을 변경해야 할 때 쉽게 변경할 수 있음
    - 두 번 이상 사용되는 값은 상수로 추출하는 것이 좋음
- 함수
    - 일반적인 알고리즘을 확장함수로 추출하면 코드를 항상 기억해 두지 않아도 괜찮음
        - 사용하는 방법이 변경되어도, 확장 함수 부분만 수정되면 되므로 유지보수성이 향상
    - 함수는 매우 단순한 추상화지만, 제한이 많음
    - 함수는 상태를 유지하지 않음
    - 함수 시그니처를 변경하면 프로그램 전체에 큰 영향을 줄 수 있음
- 클래스
    - 구현을 추상화할 수 있는 더 강력한 방법으로는 클래스가 있음
        - 상태를 가질 수 있음
        - 많은 함수를 가질 수 있음
    - 만약 클래스가 final이면, 해당 클래스 타입 아래에 어떤 구현이 있는지 알 수 있음
    - open 클래스를 활용하면 더 자유를 얻을 수 있음
- 인터페이스
    - 코틀린 표준 라이브러리를 읽어보면, 거의 모든 것이 인터페이스로 표현
        - listOf 함수는 List 리턴 (List 인터페이스), listOf는 팩토리 메서드라고 할 수 있음
        - Iterable 또는 Collection의 함수로서 List, Map 등을 리턴함 (모두 인터페이스)
        - 프로퍼티 위임은 ReadOnlyProperty 또는 ReadWriteProperty 뒤에 숨겨짐
            - 모두 인터페이스, 실질적인 클래스는 일반적으로 private
            - 함수 lazy는 Lazy 인터페이스를 리턴 함
        - 라이브러리를 만드는 사람은 내부 클래스의 가시성을 제한하고, 인터페이스를 통해 이를 노출하는 코드를 많이 사용 
        - 인터페이스 뒤에 객체를 숨김으로써 실질적인 구현을 추상화하고, 사용자가 추상화된 것에만 의존하게 만들 수 있음 (즉 결합을 줄일 수 있음)
- 추상화가 주는 자유
    - 상수로 추출
    - 동작을 함수로 래핑
    - 함수를 클래스로 래핑
    - 인터페이스 뒤에 클래스를 숨김
    - 보편적인 객체를 특수한 객체로 래핑
- 추상화의 문제
    - 추상화는 많음 것을 숨길 수 있는 테크닉, 어느 정도 숨겨야 개발이 쉬워지는 것도 사실이지만 너무 많은 것을 숨기면 결과를 이해하는 것 자체가 어려움
    - 추상화가 너무 많으면 코드를 이해하기 어려움
    - 추상화가 많은 코드를 보면, 이해하기 어렵다는 생각 때문에 코드를 제대로 읽기도 전에 두려움에 사로잡힐 수 있음
    - 단위 테스트와 문서의 예제는 추상화가 어떻게 사용되는지 확실하게 보여줌
- 어떻게 균형을 맞춰야 할까?
    - 모든 추상화는 자유를 주지만, 코드가 어떻게 돌아가는 것인지 이해하기 어렵게 만듬
    - 여러 요소들에 따라 달라짐
        - 팀의 크기
        - 팀의 경험
        - 프로젝트 크기
        - 특정 세트
        - 도메인 지식
    - 많은 개발자가 참여하는 프로젝트는 이후에 객체 생성과 사용 방법을 변경하기 어려움
        - 추상화 방법을 사용하는 것이 좋음 (최대한 모듈과 파트를 분리하는 것이 좋음)
    - 의존성 주입 프레임워크를 사용하면, 생성이 얼마나 복잡한지 신경 쓰지 않아도 됨
        - 클래스 등은 한 번만 정의하면 되기 때문
    - 테스트를 하거나, 다른 애플리케이션을 기반으로 새로운 애플리케이션을 만든다면 추상화를 사용하는 것이 좋음
    - 프로젝트가 작고 실험적이라면, 추상화를 하지 않고도 직접 변경해도 괜찮음
    - 항상 무언가 변화할 수 있다고 생각하는 것이 좋음
#### 아이템 28: API 안정성을 확인하라
- 프로그래밍에도 안정적이고 최대한 표준적인 API를 선호
- 버전 번호를 MAJOR, MINOR, PATCH로 나누어 구성
    - MAJOR 버전: 호환되지 않는 수준의 API 변경
    - MINOR 버전: 이전 변경과 호환되는 기능 추가
    - PATCH 버전: 간단한 버그 수정
- MAJOR 증가시킬 떄는 PATCH를 0으로 돌림
- 메이저 버전인 9인 경우(0.y.z)는 초기 개발 전용 버전을 의미
    - 언제든지 변경 가능성이 있고, 안정적이지 않다는 의미
- 안정적인 API 일부를 변겨해야 한다면, 전환하는데 시간을 두고 @Deprecated 어노테이션을 활용하여 사용자에게 미리 알려줘야 함
    - 적절한 대한은 있다면 ReplaceWith 붙여주는 게 좋음
#### 아이템 29: 외부 API를 랩(wrap)해서 사용하라
- 잠재적으로 불안정하다고 판단되는 외부 라이브러리 API를 랩(wrap)해서 사용
#### 아이템 30: 요소의 가시성을 최소화하라
- 작은 인터페이스는 배우기 쉽고 유지하기 쉬움
- 기능이 많은 클래스보다는 적은 클래스를 이해하는 것이 쉬움
- 구체 접근자의 가시성을 제한해서 모든 프로퍼티를 캡슐화하는 것이 좋음
- 가시성 한정자 사용하기
    - 내부적인 변경 없이 작은 인터페이스를 유지하고 싶다면, 가시성을 제한하면 됨
    - 기본적으로 클래스와 요소를 외부에 노출할 필요가 없다면 가시성을 제한해서 외부에게 접근할 수 없게 만드는 것이 좋음
    - 클래스 멤버의 가시성 한정자
        - public(디폴트): 어디에서나 볼 수 있음
        - private: 클래스 내부에서만 볼 수 있음
        - protected: 클래스와 서브클래스 내부에서만 볼 수 있음
        - internal: 모듈 내부에서만 볼 수 있음
    - 최상위 요소 가시성 한정자
        - public(디폴트): 어디에서나 볼 수 있음
        - private: 같은 파일 내부에서만 볼 수 있음
        - internal: 모듈 내부에서만 볼 수 있음
#### 아이템 31: 문서로 규약을 정의하라
- 무엇을 하는지 명확하게 설명하고 싶다면, KDoc 주석을 부여주는 것이 좋음
- 주석을 써야 할까?
    - 주석을 함꼐 사용하면 요소(함수, 클래스)에 더 많은 내용의 규약을 설명할 수 있음
    - 현대의 주석은 문서를 자동 생성하는데 많이 사용
    - 대부분의 기능은 이름 등의로도 무엇을 하는지 확실하게 알 수 있으므로, 주석을 활용한 추가적인 설명이 필요 없음
    - 함수 이름과 파라미터만드으로 정확하게 표현되는 요소에는 따로 주석을 넣지 않는 것이 좋음
- KDoc 형식
    - 첫번째 부분은 요소에 대한 요약 설명
    - 두 번재 부분은 상세 설명
    - @parm <name>: '함수 파라미터' 또는 '클래스, 프로퍼티, 함수 타입 파라미터' 문서화
    - @return: 함수의 리턴 값을 문서화
    - @constructor: 클래스의 기본 생성자를 문서화
    - @receiver: 확장 함수의 리시버를 문서화
    - @property <name>: 명확한 이름을 갖고 있는 클래스의 프로퍼티를 문서화 (기본 생성자에 정의된 프로퍼티)
    - @throws <class>, @exception <class>: 메서드 내부에서 발생할 수 있는 예외를 문서
    - @sample <identifier>: 정규화된 형식 이름을 사용해서 함수의 사용 예를 문서
    - @see <identifier>: 특정한 클래스 또는 메서드에 대한 링크를 추가
    - @author: 요소의 작성자를 지정
    - @sine: 요소의 대한 버전을 지정
    - @supress: 이를 지정하면, 만들어지는 문서에서 해당 요소가 제외
#### 아이템 32: 추상화 규약을 지켜라
- 프로그램을 안정적으로 유지하고 싶다면, 규약을 지켜야 함
- 규약을 깨야한다면 잘 문서화해야 함
### 5장. 객체 생성
#### 아이템 33: 생성자 대신 팩토리 함수를 사용하라
- 생성자 역할을 대신해주는 함수를 팩토리 함수라고 부름
- 팩토리 함수 장점
    - 생성자와 다르게 함수에 이름을 붙일 수 있음
        - 객체가 생성되는 방법과 아규먼트로 무엇이 필요한지 설명이 가능
    - 생성자와 다르게 원하는 형태로 타입을 리턴 가능
        - 다른 객체를 생성할 때 사용 가능
        - 인터페이스 뒤에 시제 객체의 구현을 숨길대 유용하게 사용할 수 있음
    - 생성자와 다르게, 호출될 때마다 새 객체를 만들 필요가 없음
        - 함수를 사용해서 객체를 생성하면 싱글톤 패턴처럼 객체를 하나만 생성하게 강제하거나, 최적화를 위해 캐싱 메커니즘을 사용할 수 있음
    - 아직 존재하지 않는 객체를 리턴할 수 있음
        - 이러한 특징 때문에 어노테이션 처리를 기반으로 하는 라이브러리에서는 팩토리 함수를 많이 사용
        - 프로젝트를 빌드하지 않고도 앞으로 만들어질 객체를 사용하거나, 프록시를 통해 만들어지는 객체를 사용 할 수 있음
    - 객체 외부에 팩토리 함수를 만들면, 가시성을 원하는 대로 제어할 수 있음
    - 팩토리 함수는 인라인으로 만들 수 있으며, 그 파라미터들을 reified로 만들 수 있음
    - 복잡한 객체를 만들어 낼 수 있음
    - 원하는 때에 생성자를 호출할 수 있음
- 팩토리 함수 주의할 점
    - 서브클래스 생성에는 슈퍼클래스의 생성자가 필요하기 때문에, 서브 클래스를 만들어 낼 수 없음
        - 팩토리 함수로 슈퍼클래스를 만들기로 했다면, 서브클래스에도 팩토리 함수를 만들어 해결
- 자바에서는 팩토리 패턴을 구현할 때 생성자를 private으로 만들지만, 코틀린에서는 그렇게 하는 경우가 거의 없음
- 코틀린에서는 추가적인 생성자보다는 팩토리를 많이 사용
- Companion 객체 팩토리 함수
    - companion 객체를 사용하는 것
    - 정적 팩토리 함수(static factory function)와 같음
    - 함수 이름
        - from: 파라미터를 하나 받고, 같은 타입의 인스턴스 하나를 리턴하는 타입변환 함수
        - of: 파라미터를 여러개 받고, 이를 통해서 인스턴스를 만들어 주는 함수
        - valueOf: from, of와 비슷한 기능을 하면서도, 의미를 조금 더 쉽게 읽을 수 있게 이름을 붙인 함수
        - instance or getInstance: 싱글톤으로 인스턴스 하나를 리턴하는 함수, 파라미터가 있을 경우 아규먼트를 기반으로 하는 인스턴스를 리턴 (일반적으로 같은 아규먼트를 넣으면, 같은 인스턴스를 리턴하는 형태로 작동)
        - createInstance or newInstance: getInstance처럼 동작하지만, 싱글톤이 적용되지 않아서, 함수를 호출할 떄마다 새로운 인스턴스를 만들어서 리턴함
        - getType: getInstance처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을때 사용하는 이름
        - newType: newInstance처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을 떄 사용하는 이름
    - companion 객체는 인터페이스를 구현, 상속 가능
    - companion 객체는 값을 가질 수 있음
        - 캐싱을 구현하거나, 테스트를 위한 가짜 객체 생성을 할수 있음
- 확장 팩토리 ㅎ마수
    - 이미 companion 객체가 존재하면, 이 객체의 함수처럼 사용할 수 있는 팩토리 함수를 만들어야 할 떄가 있음
- 최상위 팩토리 함수
    - 객체를 만드는 흔한 방법 중 하나 (listOf, setOf, mapOf)
    - 최상위 함수의 이름을 클래스 메서드 이름처럼 만들면, 다양한 혼란을 일으킬 수 있음
        - 이름을 신중하게 생각
- 가짜 생성자
    - 최상위 함수는 생상자처럼 보이고, 생성자처럼 작동, 하지만 팩토리 함수와 같은 모든 장점을 갖음
    - 진짜 생성자 대신 가짜 생성자를 만드는 이유
        - 인터페이스를 위한 생성자를 만들고 싶을 때
        - reified 타입 아규먼트를 가제 할고 싶을 때
    - invoke 연산자를 갖는 companion 객체를 사용하여 가짜 생성자를 선언할 수 있음
        - 거의 사용되지 않는 방식, 추천하는 방식은 아님
- 팩토리 클래스의 메서드
    - 팩토리 클래스는 클래스의 상태를 가질 수 있다는 특징 때문에 팩토리 함수보다 다양한 기능을 갖음
- 정리
    - 팩토리 함수를 정의하는 가장 일반적인 방법은 companion 객체를 사용하는 것
#### 아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라
- 점층적 생성자 패턴
    - 여러가지 종류의 생성자를 사용하는 간단한 패턴
- 빌더 패턴
    - 자바에서는 이름 있는 파라미터와 디폴트 아규먼트를 사용할 수 없음
    - 자바에서는 빌더 패턴을 사용
- 빌더 패턴을 사용하는 것보다 이름 있는 파라미터를 사용하는 것이 좋은 이유
    - 더 짧음
    - 명확함
    - 더 사용하기 쉬움
    - 동시성과 관련된 문제가 없음
- DSL 빌더를 활용하는 패턴이 전통적인 빌더 패턴보다 훨씬 유연하고 명확
    - 코틀린은 이와 같은 형태의 코드를 많이 사용
- 정의
    - 코틀린에서는 점층적 생성자 패턴을 사용하지 않음 
    - 빌더 패턴도  거의 사용하지 않음
    - 디폴트 아규먼트를 활용하는 것이 좋음
    - DSL을 활용하는 것이 좋음
#### 아이템 35: 복잡한 객체를 생성하기 위한 DSL을 정의하라
- DSL은 복잡한 객체, 계층 구조를 갖고 있는 객체들을 정의할 때 굉장히 유용
- DSL을 만드는 것은 약간 힘든 일이지만, 한 번 만들고 나면 보일러플레이트와 복잡성을 숨기면서 개발자의 의도를 명확하게 표현할 수 있음
- 코를린의 DSL의 type-safe이므로, 여러가지 유용한 힌트를 활용할 수 있음
- 사용자 정의 DSL 만들기
    - 리시버를 사용하는 함수 타입에 대한 개념을 이해해야 함
- 언제 사용해야 할까?
    - 단순한 기능까지 DSL을 사용한다는 것은 닭잡는데 소 잡는 칼을 쓰는 꼴
    - 복잡한 자료 구조, 계층적인 구조, 거대한 양의 데이터를 표현할 때 유용
    - DSL은 많이 사용되는 구조의 반복을 제거할 수 있게 해줌
    - 많이 사용되는 반복되는 코드가 있고 이를 간단하게 만들 수 있는 별도의 코틀린 기능이 없다면 DSL 사용을 고려해 보는 것이 좋음
### 6장
#### 아이템 36: 상속보다는 컴포지션을 사용하라
- 상속은 굉장이 강력한 기능으로 'is-a'관계의 객체 계층 구조를 만드릭 위해 설계되었음
- 상속은 관계가 명확하지 않을 때 사용하면 여러가지 무네작 발생할 수 있음
    - 단순하게 코드 추출 또는 재사용을 위해 상속을 하려고 한다면, 조금 더 신중하게 생각해야 함
- 일반적으로 상속보다 컴포지션을 사용하는 것이 좋음
- 간단한 행위 재사용
    - 상속은 하나의 클래스만을 대상으로 할 수 있음
        - 상속을 사용해서 행위를 추출하다 보면, 많은 함수를 갖는 거대한 BaseXXX 클래스를 만들게 되고, 굉장히 깊고 복잡한 계층 구조가 만들어짐
    - 상속은 클래스의 모든 것을 가져옴
        - 불필요한 함수를 갖는 클래스가 만들어짐
    - 상속은 이해하기 어려움
        - 메서의 작동 방식을 이해하기 위해 슈퍼클래스를 여러번 확인해야 한다면 문제가 있는 것
- 모든 것을 가져올 수밖에 없는 상속
    - 상속은 객체의 계층 구조를 나타낼 때 굉장히 좋은 도구, 일부분을 재사용하기 위한 목적으로는 적합하지 않음
    - 일부분만 재사용하고 싶다면 컴포지션을 사용하는 것이 좋음
- 캡슐화를 깨는 상속
    - 내부적인 구현 방법 변경에 의해서 클래스이 캡슐화가 깨질수 있음
- 오버라이딩 제한하기
    - 개발자가 상속용으로 설계되지 않은 클래스를 상속하지 못하게 하려면, final을 사용
    - 상속용으로 설계된 메서드에만 open을 붙이면 됨
- 정리
    - 컴포지션은 더 안전
        - 다른 클래스의 내부적인 구현에 의존하지 않고, 외부에서 관찰되는 동작에만 의존하므로 안전
    - 컴포지션은 더 유연
        - 상속은 한 클래스만을 대상이지만 컴포지션은 여러 클래스를 대상으로 할 수 있음
    - 컴포지션은 더 명시적
        - 장점이자 단점
        - 슈퍼클래스의 메서드를 사용할 때는 리시버를 따로 지정할 필요가 없음 (덜 명시적)
            - 코드가 짧아질 수 있지만, 메서드가 어디에서 왔는지 혼동될 수 있으므로 위험할 수 있음
        - 컴포지션을 활용하면 리시버를 명시적으로 활용할 수밖에 없으므로 메서드가 어디에 있는 것인지 확실하게 알 수 있음
    - 컴포지션은 생각보다 번거로움
        - 상속을 사용할 때보다 코드를 수정해야 하는 경우가 더 많음
    - 상속은 다형성을 활용할 수 있음
        - 상속을 사용할 경우 슈퍼클래스와 서브클래스의 규약을 항상 잘 지켜서 코드를 작성해야 함
    - 일반적으로 상속보다 컴포지션을 사용하는 것이 좋음
    - 슈퍼클래스를 상속하는 몯느 서브 클래스는 슈퍼클래스로도 동작할 수 있어햐 함
#### 아이템 37: 데이터 집합 표현에 data 한정자를 사용하라
- data 한정자를 붙이면 몇가지 함수가 자동으로 생성
    - toString
    - equals, hashCode
    - copy
    - componentN
- 튜플 대신 데이터 클래스 사용하기
    - 튜플은 데이터 클래스와 같은 역할을 하지만 가독성이 나쁨
    - 튜플만 보고 어떤 타입을 나타내는지 예측할 수 없음
    - 튜블은 값에 간단하게 이름을 붙일 때, 표준 라이브러리에서 볼 수 있는 것처럼 미리 알 수 없는 집합을 표현할 때 사용하면 좋음
#### 아이템 38: 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라
- SAM(Single-Abstract Method): 연산 또는 액션을 전달할 대 메서드가 하나만 있는 인터페이스
- 인터페이스를 사용해야 하는 특별한 이유가 없다면, 함수 타입을 활용하는게 좋음
- 함수 타입은 다양한 지원을 받을 수 있으며, 코틀린 개발자들 사이에서 이미 널리 사용되고 있음
- 언제 SAM을 사용해야 할까?
    - 딱 한가지 경우에는 SAM을 사용하는게 좋음
        - 코틀린이 아닌 다른 언어에서 사용할 클래스를 설계할 때
        - 함수 타입으로 만들어진 클래스는 자바에서 타입 별칭과 IDE 지원 등을 제대로 받을 수 없음
#### 아이템 39: 태그 클래스보다는 클래스 계층을 사용하라
- 코틀린은 일반적으로 태그 클래스보다 sealed 클래스를 많이 사용
- 한 클래스에 여러 모드를 만드는 방법 대신에, 각각의 모드를 여러 클래스로 만들고 타입 시스템과 다형성을 활용하는 것
- sealed 한정자
    - 반드시 sealed 한정자를 사용해야 하는 것은 아님
    - sealed 한정자는 외부 파일에서 서브클래스를 만드는 행위 자체를 제한함
    - 외부에서 추가적인 서브클래스를 만들 수 없으므로, 타입이 추가되지 않을거라는게 보장
    - when을 사용할 때 else 브랜치를 만들 필요가 없음
- 태그 클래스와 상태 패턴의 차이
    - 상태 패턴은 객체의 내부 상태가 변화할 때, 객체의 동작이 변하는 소프트웨어 디자인 패턴
    - 상태 패턴을 사용한다면, 서로 다른 상태를 나타내는 클래스 계층 구조를 만듬
#### 아이템 40: equals의 규약을 지켜라
- 코틀린의 Any에는 equals, hashCode, toString 메서드를 제공
- 동등성
    - 구조적 동등성
        - equals 메서드와 이를 기반으로 만들어진 '==' 연산자로 확인하는 동등성
        - a가 nullable이 아니라면 'a == b'는 'a.equals(b)'로 변환되고, nullable이라면 'a?.equals(b) ?: (b === null)'로 변환
    - 레퍼런스적 동등성
        - '===' 연산자로 확인하는 동등성
        - 두 피연사자가 같은 객체를 가리키면 true 리턴
- equals가 필요한 이유
    - Any 클래스에 구현되어 있는 equals 메서드는 디포트로 '==='처럼 두 인스턴스가 완전히 같은 객체인지를 비교
    - 데이터 클래스로 정의하면 자동으로 동등성으로 동작 (데이터 클래스 내부에 어떤 값을 갖고 있는지가 중요)
    - 데이터 클래스의 동등성은 모든 프로퍼티가 아니라 일부 프로퍼티만 비교해야 할 때만 유용-
    - equals를 직접 구현해야 하는 경우
        - 기본적으로 제공되는 동작과 다른 동작을 해야 하는 경우
        - 일부 프로퍼티만으로 비교해야 하는 경우
        - data 한정자를 붙이는 것을 원하지 않거나, 비교해야 하는 프로퍼티가 기본 생성자에 없는 경우
- equals의 규약
    - equals, toString, hashCode의 동작은 매우 빠를 거라고 예측되므로, 빠르게 동작해야 함
- URL과 관련된 equals 문제
    - java.net.URL 객체 2개를 비교하면 동일한 IP 주소로 해석될 때는 true, 아닐 때는 false
    - 문제는 이 결과가 네트워크 상태에 따라서 달라짐 (인터넷 연결이 끊겨있으면 false를 출력)
    - 동작이 일관되지 않음
        - 네트워크 설정에 따라 달라짐
    - 일반적으로 equals, hashCode 처리가 빠를 거라 예상하지만, 네트워크 처리는 굉장히 느림
    - 동작 자체에 문제가 있음
        - 동일한 IP 주소를 갖는다고 동일한 콘텐츠를 나타내느 것은 아님
        - 가상 호스팅을 한다면 관련없는 사이트 같은 IP 주소를 공유할 수 있음
    - java.net.URL이 아니라 java.net.URI를 사용해서 이런 문제를 해결
- equals 구현하기
    - 특별한 이유가 없는 이상 직접 equals를 구현하는 것은 좋지 않음
    - 기본적으로 제공되는 것을 그대로 쓰거나, 데이터 클래스로 만들어서 사용하는 것이 좋음
    - 직접 구현해야 한다면 final로 만드는 것이 좋고, 만약 상속을 한다면 서브클래스에서 equals가 작동하는 방식을 변경하면 안된다는 것을 기억
    - 상속을 지원하면서도 완벽한 사용자 정의 equals 함수를 만드는 것은 거의 불가능에 가까움
#### 아이템 41: hasCode의 규약을 지켜라
- hashCode 함수는 수많은 컬렉션과 알고리즘에 사용되는 자료 구조인 해시 테이블을 구축할 때 사용
- 해시 테이블
    - 해시 테이블은 각 요소에 숫자를 할당하는 함수가 필요, 이를 해시 함수라고 부르며 같은 요소라면 항상 같은 숫자를 리턴
    - 해시 함수의 특성
        - 빠르다
        - 충돌이 적다 (다른 값이라만 최댛나 다른 숫자를 리턴한다는 의미)
    - 해시 함수는 각각의 요소에 특정한 숫자를 할당하고, 이를 기반으로 요소를 다른 버킷에 넣음
    - 같은 요소는 동일한 버킷에 넣음
    - 버킷 하나에 평균 1,000개의 요소가 들어 있음
    - 데이터 베이스, 인터넷 프로토콜, 여러 언어의 표준 라이브러리 컬렉션에 사용
- 가변성과 관련된 문제
    - 요소가 추가될 떄만 해시 코드를 계산함
    - 요소가 변경되어도 해시 코드는 계산되지 않으며, 버킷 재배치로 이루어지지 않음 (LinkedHashSet, LinkedHashMap의 키는 한번 추가한 요소를 변경할 수 없음)
- hashCode의 규약
    - 어떤 객체를 변경하지 않았다면, hashCode는 여러 번 호출해도 그 결과가 항상 같아야 함
    - equals 메서드의 실행 결과로 두 객체가 같다고 나온다면, hashCode 메서드의 호출 결과도 같다고 나와야 함
    - hashCode는 최대한 요소를 넓게 퍼뜨려야 함
- hashCode 구현하기
    - equals를 따로 정의했다면, 반드시 hashCode도 함께 정의해 줘야 함
    - hashCode는 기본적으로 equals에서 비교에 사용되는 프로퍼티를 기반으로 해시 코드를 만들어야 함
    - 일반적으로 모든 해시 코드의 값을 더함, 더하는 과정마다 이전까지의 결과에 31을 곱한 뒤 더해 줌
        - 관례적으로 31을 많이 사용
        - data 한정자를 붙일 때도 이렇게 구현
    - 코틀린/JVM의 Objects.hashCode 사용하여 해시를 계산
#### 아이템 42: comporeTo의 규약을 지켜라
- compareTo 메서드는 Compareable<T> 인터페이스에도 들어 있음
- compareTo를 따라 정의해야 할까?
    - 코틀린에서 compareTo를 따로 정의해야 하는 상황은 거의 없음 (보통 하나의 프로퍼티 순서를 지정하는 것으로 충분하기 떄문)
- compareTo 구현하기
    - compareTo를 구현할 떄 유용한 최상위 함수가 있음
        - compareValues
        - compareValuesBy
#### 아이템 43: API의 필수적이지 않는 부분을 확장 함수로 추출하라
- 일반 멤버와 확장의 가장 큰 차이점은 확장은 따로 가져와서 사용해야 함
    - 일반적으로 확장은 다른 패키지에 위치
    - 확장은 우리가 직접 멤버를 추가할 수 없는 경우, 데이터와 행위를 분리하도록 설계된 프로젝트에서 사용
- 확장함수는 컴파일 시점에 정적으로 선택
    - 확장 함수는 '첫 번째 아규먼트로 리시버가 들어가는 일반 함수'로 컴파일
- 확장 함수는 클래스 레퍼런스에서 멤버로 표시되지 않음
    - 확장 함수는 어노테이션 프로세스가 따러 처리하지 않음
    - 필수적이지 않은 요소를 확장 함수로 추출하면, 어노테이션 프로세스로부터 숨겨짐
    - 확장함수가 클래스 내부에 있는 것은 아니기 때문
정리
    - 확장 함수는 읽이 들어야 함
    - 확장 함수는 virtual이 아님
    - 멤버는 높은 우선 순위를 갖음
    - 확장 함수는 클래스 위가 아니라 타입 위에 만들어짐
    - 확장 함수는 클래스 레퍼런스에 나오지 않음
    - API의 필수적인 부분은 멤버로 두는 것이 좋지만, 필수적이지 않은 부분은 확장 함수로 만드는 것이 여러모로 좋음
#### 아이템 44: 멤버 확장 함수의 사용을 피하라
- 확장 함수는 첫 번재 아규먼트로 리시버를 받는 단순한 일반 함수로 컴파일
- 확장 함수를 클래스를 멤버로 정의할 수도 있고, 인터페이스 내부에 정의할 수도 있음
    - DSL을 만들 때를 제외하면 이를 사용하지 않는 것이 좋음
    - 가시성을 제한하지 못함
    - 레퍼런스를 지원하지 않음
    - 암묵적 접근을 할 때, 두 리시버 중에 어떤 리시버가 선택될지 혼동
    - 확장 함수가 외부에 있는 다른 클래스를 리시버로 받을 때, 해당 함수가 어떤 동작을 하는지 명확하지 않음

## 3장. 효율성
### 7장. 비용 줄이기
- 오늘날에는 코드의 효율성을 관대하게 바라봄
    - 메모리가 저렴해졌음
    - 개발자는 비싸졌음
- 장기적으로 보았을 때 효율성이 중요
- 최적화를 초기 단계에서부터 하는 것은 얻는 것보다 잃는 것이 많은 경우가 많음
#### 아이템 45: 불필요한 객체 생성을 피하라
- 불필요한 객체 생성을 피하는 것이 최적화의 관점에서 좋음
- JVM에서는 하나의 가상 머신에서 동일한 문자열을 처리하는 코드가 여러개 있다면, 기존의 문자여을 재사용함
- Integer, Long 처럼 박스화환 기본 자료형도 작은 경우에는 재사용 (Int는 -128 ~ 127 범위 캐시)
- 객체 생성 비용은 항상 클까?
    - 어떤 객체를 wrap하면, 크게 세가지 비용이 발생
    - 객체는 더 많은 용량을 차지
        - 64bit JDK에서 객체는 8바이트의 배수만큼 공간을 차지함
        - 앞부분 12바이트는 헤더로서 반드시 있어야 하므로, 최소 16바이트 (32bit JVM에서는 8바이트)
        - 추가로 객체에 대한 레퍼런스도 공간을 차지함
            - -Xms32G까지는 32bit, 64bit 플랫폼 모두 4바이트
            - -Xmx32G 부터는 8바이트
    - 요소가 캡슐화되어 있다면, 접근에 추가적인 함수 호출이 필요
        - 함수를 사용하는 처리는 굉장히 빠르므로 큰 비용이 발생하지는 않지만, 매우 많은 객체를 처리하면 비용도 커짐
    - 객체는 생성되어야 함
        - 객체를 생성되고, 메모리 영역에 할당되고, 이에 대한 레퍼런스를 만드는 등의 작업이 필요함
        - 적은 비용이지만 모이면 큰 비용이 듬
- 객체 선언
    - 매순간 객체를 생성하지 않고, 객체를 재사용하는 간단한 방법은 객체 선언을 사용하는 것 (싱글톤)
    - mutable 객체는 캐시하지 않는다는 규칙을 지키는 것이 좋음
- 캐시를 활용하는 팩토리 함수
    - 팩토리 함수는 캐시를 가질수 있음 (emptyList)
    - 객체 생성이 무겁거나, 동시에 여러 mutable 객체를 사용해야 하는 경우에는 이처럼 객체 풀(쓰레드 풀)을 사용하는 것이 좋음
    - 메모이제이션(momoiza-tion): 
        - 모든 순수 함수는 캐싱을 활용할 수 있음
        - parameterized 팩토리 메서드도 캐싱을 활용 할 수 있음
        - 객체를 map에 저장해 둘 수 있음
    - 캐시는 언제나 메모리와 성능의 트레이드 오프가 발생하므로, 캐시를 잘 설계하는 것은 쉽지 않음
- 무거운 객체를 외부 스코프로 보내기
    - 성능을 위한 굉장히 유요한 트릭으로, 무거운 객체를 외부 스코프로 보내는 방법이 있음
    - 컬렉션 처리에서 이루어지는 무거운 연산은 컬렉션 처리 함수 내부에서 외부로 빼는 것이 좋음
- 지연 초기화
    - 무거운 클래스를 만들 때는 지연되게 만드는 것이 좋을 때가 있음
    - 내부에 있는 인스턴스들을 지연 초기화하면, 객체를 생성하는 과정을 가볍게 만들 수 있음
    - 단점
        - 클래스가 무거운 객체를 가졌지만, 메서드의 호출은 빨라야 하는 경우가 있음
            - 백엔드 애플리케이션에서 좋지 않을 수 있음
        - 성능 테스트가 복잡해지는 문제가 있음
- 기본 자료형 사용하기
    - wrap한 자료형이 사용되는 경우
        - nullable 타입을 연산할 때
        - 타입을 제네릭으로 사용할 때
    - 코드와 라이브러리의 성능이 굉장히 중요한 부분에서만 이를 적용
#### 아이템 46: 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라
- inline 한정자의 역할은 컴파일 시점에 '함수를 호출하는 부분'을 '함수의 본문'으로 대체하는 것
- inline 사용 시 점프하는 과정을 거치지 않음
- 타입 아규먼트를 reified로 사용할 수 있다
    - reified 한정자를 지정하면, 타입 파라미터를 사용한 부분이 타입 아규먼트로 대체
- 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다
    - inline 한정자를 붙이면 조금 더 빠르게 동작
    - 함수 호출과 리턴을 위해 점프하는 과정과 백스택을 추적하는 과정이 없기 때문에
    - '인라인 함수'와 '인라인 함수가 아닌 함수'의 중요한 차이는 함수 리터럴 내부에서 지역 변수를 캡처할 떄 확인할 수 있음
        - 캡처된 값은 객체로 래핑해야 하며, 사용할 때마다 객체를 통해 작업이 이루어져야 함
- 비지역적 리턴(non-local return)을 사용할 수 있다
    - 인라인 함수에서 return시 호출한 영역 부분에서 return 함
- inline 한정자의 비용
    - inline 함수는 재귀적으로 동작할 수 없음
    - inline 함수는 가시성 제한을 가진 요소를 사용할 수 없음
        - public 인라인 함수 내부에서는 private, internal 가시성을 가진 함수와 프로퍼티를 사용할 수 없음
    - inline 한정자를 남용하면, 코드의 크기가 쉽게 커짐
        - 서로 호출하는 인라인 함수가 많아지면, 코드가 가하급수적으로 증가하므로 위험함
- crossinlin과 noinline
    - crossinline: 아규먼트로 인라인 함수를 받지만, 비지역적 리턴을 하는 함수는 받을 수 없게 만듬
    - noinline: 아규먼트로 인라인 함수를 받을 수 없게 만듬
#### 아이템 47: 인라인 클래스의 사용을 고려하라
- 인라인으로 만들 수 있는 것은 함수 뿐아니라 객체도 만들 수 있음
- 인라인 클래스는 다른 자료형을 래핑해서 새로운 자료형을 만들 때 많이 사용
    - 이때 어떠한 오버헤드도 발생하지 않음
    - 측정 단위를 표현할 때
    - 타입 오용으로 발생하는 문제를 막을 때
- 인라인 클래스와 인터페이스
    - 인라인 클래스도 다른 클래스와 마찬가지도 인터페이스를 구현할 수 있음
    - 인터페이스를 통해서 타입을 나타내면, 객체를 래핑해서 사용해야 하기 때문에 인터페이스를 구현하는 인라인 클래스는 아무런 의미가 없음
- typealias
    - typealias를 사용하면, 타입에 새로운 이름을 붙여 줄 수 있음
    - typealias는 안전하지 않음
        - 단위 등을 표현하려면, 파라미터 이름 또는 클래스를 사용
        - 이름은 비용이 적게 들고 클래스는 안전
        - 인라인 클래스를 사용하면, 비용과 안전이라는 두마리 토끼를 모두 잡음
- 정리
    - 인라인 클래스를 사용하면 성능적인 오버헤드 없이 타입을 래피할 수 있음
    - 인라인 클래스는 타입 시스템을 통해 실수로 코드를 잘못 작성하는 것을 막아주므로, 코드의 안정성을 향상
    - 의미가 명확하지 않은 타입, 여러 측정 단위들을 함께 사용하는 경우 인라인 클래스를 꼭 사용
#### 아이템 48: 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라
- 객체에 대한 참조를 companion(또는 static)으로 유지해 버리면, 가비지 컬렉터가 해당 객체에 대한 메모리 해제를 할 수 없음
- 쓸데없는 최적화가 모든 악의 근원이라는 말도 있지만, 오브젝트에 null을 설정하는 것은 그렇게 어려운 일이 아니므로, 무조건 하는 것이 좋음
    - 특히 많은 변수를 캡처할 수 있는 함수 타입, Any 또는 제네릭 타입과 같은 미지의 클래스일 때는 이러한 처리가 중요
- 메로리와 성능 뿐만 아니라 가독성과 확장성을 항상 고려해야 함
    - 일반적으로 가독성이 좋은 코드는 메모리와 성능적으로도 좋음
    - 가독성이 좋지 않은 코드는 메모리와 CPU 리소스의 낭비를 숨기고 있을 가능성이 높음
    - 일반적으로 가독성과 확장성을 더 중시하는 것이 좋지만, 라이브러리를 구현할 때는 메모리와 성능이 더 중요
- 변수를 지역 스코프에 정의하고, 최상위 프로퍼티 또는 객체 선언으로 큰 데이터를 저장하지 않는 것
### 8장. 효율적인 컬렉션 처리
- 단순하게 짧아지는 장점만 있는 것이 아니라, 코드를 읽기 쉬워진다는 장점도 있음
- 컬렉션 처리 최적화는 생각보다 어렵지만 굉장히 중요함
#### 아이템 49: 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라
- Iterable과 Sequence는 완전히 다른 목적으로 설계되어서, 완전히 다른 형태로 동작
    - 시퀀스는 지연 처리
        - 시퀀스 처리 함수들을 사용하면 데코레이터 패턴으로 꾸며진 새로운 시퀀스가 리턴 
        - 최종 연산이 이루어질 때 수행 (count, toList 등)
    - Iterable
        - 처리 함수를 사용할 때마다 연산이 이루어져 List가 만들어짐
- 시퀀스 지연처리 장점
    - 자연스러운 처리 순서를 유지
    - 최소한만 연산
    - 무한 시퀀스 형태로 사용할 수 있음
    - 각각 단계에서 컬렉션을 만들지 않음
- 순서의 중요성
    - 시퀀스 처리는 요소 하나하나에 지정한 연선을 한꺼번에 적용 (element-by-element or lazy order)
    - 이터러블은 요소 전체를 대상으로 연산을 차근차근 적용함 (step-by-step order or eager order)
    - 시퀀스 처리는 기본적인 반복문과 조건문을 사용하는 코드와 같으므로, 컴파일러 최적화가 처리를 더 빠르게 만들어 줄 수 있음
- 최소 연산
    - 중간 처리 단계를 모든 요소에 적용할 필요가 없는 경우에는 시퀀스를 사용하는 것이 좋음
-  무한 시퀀스
    - 무한 시퀀스를 만들고, 필요한 부분까지만 값을 추출하는 것도 가능
    - 무한 시퀀스는 종결 연산으로 take, first 정도만 사용하는 것이 좋음
- 각각의 단계에서 컬렉션을 만들어 내지 않음
    - 크고 무건운 컬렉션을 처리할 때는 굉장히 큰 비용이 들어감
    - 시퀀스를 사용하면 메모리를 절약할 수 있을 뿐만아니라 성능도 향상시킬 수 있음
- 시퀀스가 빠르지 않은 경우
    - 컬렉션 전체를 기반으로 처리해야 하는 연산은 시퀀스를 사용해도 빨라지지 않음 (예제로는 soreted)
    - 무한 시퀀스에 soreted 적용하면, 무한 반복에 빠지는 문제가 있음
    - soreted는 시퀀보다 컬렉션이 더 빠름, 다른 처리는 모두 시퀀스가 빠름
- 자바 스트림의 경우
    - 자바 8부터 컬렉션 처리를 위해 스트림 기능이 추가 (코틀린의 시퀀스와 비슷한 형태로 동작)
    - 자바의 스트림과 코틀린의 시퀀스 차이점
        - 코틀린의 시퀀스가 더 많은 처리 함수를 갖고 있음
        - 자바 스트림은 병렬 함수를 사용해서 병렬 모드로 실행할 수 있음
        - 코틀린의 시퀀스는 코트린/JVM , 코틀린/JS, 코틀린/네이티브 등의 일반적인 모듈에서 모두 사용, 자바 스트림은 코틀린/JVM에서만 동작
#### 아이템 50: 컬렉션 처리 단계 수를 제한하라
- 전체 컬렉션에 대한 반복 중간과 중간 컬렉션 생성이라는 비용이 발생,  
이 비용은 적절한 컬렉션 처리 함수들을 활용해서 줄일 수 있음
#### 아이템 51: 성능이 중요한 부분에는 기본 자료형 배열을 사용하라
- 기본 자료형 특징
    - 가볍습니다 (일반적인 객체와 다르게 추가적으로 포함되는 것들이 없기 때문)
    - 빠릅니다 (값에 접근할 때 추가 비용이 들어가지 않음)
- 대규모 데이터를 처리할 때 기본 자료형을 사용하면, 상당히 큰 최적화가 이루어짐
- 성능이 중요한 코드라면 IntArray, LongArray 등의 기본 자료형을 활용하는 배열을 사용하는 것이 좋음
    - IntArray, List<Int>의 바이트 할당은 5배 정도 차이가 발생
#### 아이템 52: mutable 컬렉션 사용을 고려하라
- immutable 컬렉션보다 mutable 컬렉션이 좋은 점은 성능적인 측면에서 다 빠르다는 것
- 지역 변수로 사용할 때는 mutable 컬렉션을 사용하는 것이 더 합리적이라고 할 수 있음
- 정리
    - 일반적으로 지역 스코프에서 이러한 세부적인 조정이 필요하지 않으므로,  
    가변 컬렉션을 사용하는 것이 좋음
