# 이펙티브 코틀린

## 코틀린의 철학
- 생산성: 애플리케이션을 빠르게 생산합니다
- 확장성: 애플리케이션의 규모가 커져도, 개발 비용이 급격하게 증가하지 않습니다
- 유지보수성: 유지보수를 굉장히 쉽게 할수 있습니다
- 신뢰성: 애플리케이션이 예상한 대로 동작하므로 오류가 적습니다
- 효율성: 애플리케이션이 굉장히 빠르게 동작하면, 리소스가 적게 필요합니다

## 1부. 좋은 코드
### 1장. 안정성
#### 아이템 1: 가변성을 제한하라
- 상태를 갖게 하는 것은 양날의 검
    - 시간의 변화에 따라서 변화하는 요소를 표현할 수 있다는 것은 유용, 상태를 적절히 관리하는 것은 어려움
    - 프로그램을 이해하고 디버그하기 힘듬
    - 코드의 실행을 추론하기 어려움 (시점에 따라 값이 달라질 수 있음)
    - 멀티스레드 환경에서는 적절한 동기화가 필요
    - 테스트 하기 어려움 (모든 상태를 테스트가 필요, 변경이 많을수록 더 많은 조합을 테스트해야 함)
    - 상태 변경이 일어날 때, 다른 부분에 알려야 하는 경우가 있음
- 코틀린에서 가변성 제한하기
    - 읽기 전용 프로퍼티(val)
    - 가변 컬렉션과 읽기 전용 컬렉션 구분
    - 데이터 클래스의 copy
- 다른 종류의 변경 가능 지점
    - 첫째번째: mutable 컬렉션을 사용, 두번째: var로 읽고 쓸 수 있는 프로퍼티 사용
    - mutable 컬렉션을 사용하는 것이 처음에는 더 간단하게 느껴지겠지만, mutable 프러퍼티를 사용하면 객체 변경을 제어하기 더 쉬움
    - 최악의 방식은 프로퍼티와 컬렉션을 모두 변경 가능한 지점으로 만드는 것
- 변경 가능 지점 노출하지 말기
    - 상태를 나타내는 mutable 객체를 외부에 노출하는 것은 굉장히 위험
    - 돌발적인 수정이 이어날 때 위험할 수 있음
        - 방어적 복제(defensive copying)로 해결
        - 컬렉션은 객체를 일긱 전용 슈퍼타입으로 업캐스트하여 가변성을 제한
- 정리
    - var 보다는 val
    - mutable 보다는 immutable 프로퍼티 사용
    - mutable 객체와 클래스보다는 immutable 객체와 클래스를 사용
    - 변경이 필요한 대상을 만들어야 한다면, immutable 데이터 클래스로 만들고 copy 활용
    - 컬렉션에 상태를 저장해야 한다면, mutable 컬렉션보다는 읽기 전용 컬렉션을 사용
    - mutable 객체를 외부에 노출하지 않는 것이 좋음
#### 아이템 2: 변수의 스코프를 최소화하라
 - 프로퍼티보다는 지역 변수를 사용하는 것이 좋음
 - 최대한 좁은 스코프를 갖게 변수를 사용
    - 프로그램을 추적하고 관리하기 쉬움
- 변수는 읽기 전용 또는 읽고 쓰기 전용 여부와 상관없이, 변수를 정의할 때 최기화되는 것이 좋음
- 캡처링
    - 시퀀스 빌더를 사용해서 
#### 아이템 3: 최대한 플랫폼 타입을 사용하지 말라
- 플랫폼 타입이란, 다른 프로그래밍 언어에서 전달되어서 nullable인지 아닌지 알 수 없는 타입
- 플랫폼 타입은 타입 이름 뒤에 '!' 기호를 붙여서 표기
- 플랫폼 타입은 안전하지 않으므로, 최대한 빨리 제거하는 것이 좋음
#### 아이템 4: inferred 타입으로 리턴하지 말라
- 코틀린의 타입 추론(type inference)은 JVM 세계에서 가장 널리 알려진 코틀린의 특징
- 자바도 자바10부터 코틀린을 따라 타입 추론을 도입
- inferred 타입은 정확하게 오른쪽에 있는 피연사에 맞게 설정 (슈퍼클래스 or 인터페이스로 설정 불가)
- 리턴 타입은 외부에서 확인할 수 있게 명시적으로 지정해 주는 것이 좋음
- 정리
    - 타입을 확실하게 지정해야 하는 경우 명시적으로 타입을 지정해야 함
    - 안전을 위해서 외부 API를 만들 때는 반드시 타입을 지정하고, 지정한 타입을 특별한 이유와 확실한 확인 없이는 제거하지 말자
#### 아이템 5: 예외를 활용해 코드에 제한을 걸어라
- require: 아규먼트를 제한
- check:  상태와 관련된 동작을 제한
- assert: 어떤 것이 true인지 확인 (assert 블록은 테스트 모드에서만 작동)
- return or  throw와 함께 활용하는 Elvis 연산자
- 제한을 걸어 주면 다양한 장점
    - 제한을 걸면 문서를 보지 않은 개발자도 문제를 확인
    - 예상하지 못한 동작을 하지 않고 예외를 throw 함
    - 코드가 어느정도 자체적으로 검사
    - 스마트 캐스트 기능을 활용
- 아규먼트(require)
    - 예제
        - 숫자를 아규먼트로 받아서 팩토리얼 계산한다면 숫자는 양의 정수여야 함
        - 좌표들을 아큐먼트로 받아서 클러스터를 찾을 때는 비어 있지 않은 좌표 목록이 필요함
        - 사용자로부터 이메일 주소를 입력받을 때는 값이 입려되어 있는지, 이메일 형식이 올바른지 확인
- 상태(check)
    - 예제
        - 어떤 객체가 미리 초기화되어 있어댜지만 처리를 하게 하고 싶은 함수
        - 사용자가 로그인했을 때만 처리를 하게 하고 싶은 함수
        - 객체를 사용할 수 있는 시점에 사용하고 싶은 함수
    - require와 비슷하지만 지정된 예측을 만족하지 못할 때, 상태가 올바른지 확인할 때 사용
    - 일반적으로 require 블록 뒤에 배치
- Assert 계열 함수 사용
    - 단위 테스트 대신 함수에서 assert를 사용하면 장점
        - Assert 계열의 함수는 코드를 자체 점검하며, 더 효율적으로 테스트
        - 특정 상황이 아닌 모든 상황에 대한 테스트 확인
        - 실행 시점에 정확하게 어떻게 되는지 확인할 수 있음
        - 실제 코드가 더 빠른 시점에 실패하게 만듬 (예상하지 못한 동작이 언제 어디서 실행되었는지 쉽게 찾을 수 있음)
    - 이를 활용해도 단위 테스트는 따로 작성해야 함
    - assert는 파이썬에서 굉장히 많이 사용되고, 자바에서는 딱히 사용되지 않음 (코틀린에서 안정적으로 코드를 만들고 싶을 때 양념처럼 사용할 수 있음)
- 정리
    - 제한을 훨씬 더 쉡게 확인
    - 애플리케이션을 더 안정적으로 지킬수 있음
    - 코드를 잘못 쓰는 상황을 막을 수 있음
    - 스마트 캐스팅을 활용
#### 아이템 6: 사용자 정의 오류보다는 표준 오류를 사용하라
- 가능하다면 직접 오류를 정의하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 좋음
- 표준 라이브러리의 오류는 많은 개발자가 알고 있으므로, 이를 재사용하는 것이 좋음
- 일반적으로 사용되는 예외
    - IllegalArgumentException or IllegalStateException: require, check 사용하여 throw 할 수 있는 예외
    - IndexOutOfBoundsException: 인덱스 파라미터의 값이 범위를 벗어남
    - ConcurrentModificationException: 동시 수정을 금지했는데 발생했을 때
    - UnsupportedOperationException: 사용자가 사용하려고 했던 메서드가 현재 객체에서는 사용할 수 없다는 것을 나타냄
    - NoSuchElementException: 사용자가 사용하려고 했던 요소가 존재하지 않음
#### 아이템 7: 결과 부족이 발생할 경우 null과 Failure를 사용하라
- 함수가 원하는 결과를 만들어 낼 수 없을 때가 있음
    - null or '실패를 나타내는 sealed클래스(일반적으로 Failure라는 이름붙임)' 반환
    - 예외를 throw 함
- 예외는 정보를 전달하는 방법으로 사용해서는 안됨
- 예외는 잘못된 특별한 상황을 나타내야 하며, 처리
- null or Failure는 예상되는 오류를 표현할 때 굉장히 좋음
    - 명시적, 효율적이며 간단한 방법으로 처리
    - 예측할 수 있는 범위의 오류는 null or Failure를 사용
    - 예측하기 어려운 예외적인 범위의 오류는 예외를 throw해서 처리하는 것이 좋음
    - try-catch 블록 내부에 코드를 배치하면, 컴파일러가 할 수 있는 최적화가 제한
#### 아이템 8: 적절하게 null을 처리하라
- nullable 타입은 세가지 방법으로 처리
    - ?., 스마트 캐스팅, Elvis 연산자 등을 활용해서 안전하게 처리
    - 오류를 throw 
    - 함수 또는 프로퍼티를 리팩터링해서 nullable 타입이 나오지 않게 바꿈
- not-null assertion(!!)과 관련된 문제
    - '!!'연산자를 사용하는 방법은 좋은 방법이 아님 (문제는 미래의 어느 순간에 일어남)
    - lateinit or Delegates.notNull 대체하여 사용
    - 코틀린을 대상으로 설계된 API를 활용한다면 '!!' 연산자를 사용하는 것은 이상하게 생각해야 함
- 의미 없는 nullability 피하기
    - 클래스에서 nullability에 따라 여러 함수를 만들어서 제공 (ex. get(), getOrNull())
    - 어떤 값이 클래스 생성 이후 확실하게 설정된다는 보장이 있다면 lateinit or Delegates.notNull 사용
    - 빈 컬렉션 대신 null 리턴하지 말기
- lateinit 프로퍼티와 notNull 델리게이트
    - lateinit 사용
        - 비용 발생
        - 초기화 전에 값을 사용하려면 예외 발생
        - Int, Long, Double, Boolean 같은 기본 타입과 연결된 타입은 사용할 수 없음
            - Delegates.notNull 사용해서 해결
#### 아이템 9: use를 사용하여 리소를 닫아라
- use 사용하면 Closeable/AutoCloseable을 구현한 객체를 쉽고 안전하게 처리할 수 있음
- 파일을 처리할 때는 파일을 한 줄씩 읽어 들이는 useLines를 사용하는 것이 좋음
#### 아이템 10: 단위 테스트를 만들어라
- 코드를 안전하게 만드는 가장 궁극적인 방법은 다양한 종류의 테스트를 하는 것
- 단위 테스트는 개발자가 작성하며, 개발자에게 유용
- 테스트가 잘 만들어져 있다면, 리팩터링하는 것이 두렵지 않음
- 수동 테스트보다 단위 테스트로 확인하는 것이 빠름
- 단점
    - 단위 테스트를 만드는데 시간이 걸림
    - 테스트를 활용할 수 있게 코드를 조정
    - 좋은 단위 테스트를 만드는 작업이 꽤 어려움
        - 잘못 만들어진 단위 테스트는 득보다 실이 큼
### 2장. 가독성
#### 아이템 11: 가독성을 목표로 설계하라
- 인식 부하 감소
    - 가독성이란 코드를 읽고 얼마나 빠르게 이해할 수 있는지를 의미함
    - 뇌는 기본적으로 짧은 코드를 빠르게 읽을 수 있겠지만, 익숙한 코드는 더 빠르게 읽을 수 있음
- 컨벤션
    - 연산자는 의미에 맞게 사용 (invoke 형태로 사용하면 안됨)
    - invoke 연산자와 함께 '람다를 마지막 아규먼트'로 사용하는 것은 신중해야 함
#### 아이템 12: 연산자 오버로드를 할 때는 의미에 맞게 사용하라
- 분명하지 않은 경우
    - 관례를 충적하는지 아닌지 확실하지 않을 때가 문제
    - 의미가 명확하지 않다면, infix를 활영한 확장 함수를 사용하는 것이 좋음
    - 최상위 함수를 사용하는 것도 좋음
- 규칙을 무시해도 되는 경우
    - 도메인 특화 언어(DSL)를 설계할 때
- 정리
    - 연산자 오버라이딩은 그 이름의 의미에 맞게 사용
    - 연자의 의미가 명확하지 않다면, 연산자 오버로딩을 사용하지 않는 것이 좋음
        - infix 확장 함수, 최상위 함수 사용
#### 아이템 13: Unit?을 리턴하지 말라
- 'Unit?' 표현하는 것은 오해의 소지가 있으며, 예측하기 어려운 오류를 만들 수 있음
- 'Unit?' 리터한거나, 이를 기반으로 연산하지 않는 것이 좋음
#### 아이템 14: 변수 타입이 명확하지 않은 경우 확실하게 지정하라
- 가독성 향상 이외에 안전을 위해서도 타입을 지정하는 것이 좋음
- 타입을 무조건 지정하라는 것이 아님(상황에 맞게 사용)
#### 아이템 15: 리시버를 명시적으로 참조하라
- 여러 개의 리시버
    - 스코프 내부에 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내면 좋음
    - also, let을 사용하는 것이 nullable 값을 처리할 때 훨씬 좋은 선택
    - 리시버가 명확하지 않다면, 명시적으로 리시버를 적어서 이를 명확하게 해줘야 함
- DSL 마커
    - 코틀린 DSL 사용할 때는 여러 리시버를 가진 요소들이 중첩되더라도, 리시버를 명시적으로 붙이지 않음
- 정리
    - 짧게 적을 수 있다는 이유만으로 리시버를 제거하지 말기
    - 여러개의 리시버가 있는 상황 등에는 리시버를 명시적으로 적어 주는 것이 좋음
    - 리시버를 명시적으로 지정하면 어떤 리시버의 함수인지를 명확하게 알 수 있으므로 가독성 향상
    - DSL에서 외부 스코프에 있는 리시버를 명시적으로 적게 강제하고 싶다면, DSLMarker 메타 에노테이션을 사용
#### 아이템 16: 프로퍼티는 동작이 아니라 상태를 나타내야 한다
- val 사용해서 읽기 전용 프로퍼티를 만들 때는 field가 만들어지 않음
- 인터페이스에도 프로피터를 정의할 수 있음
- 프로퍼티는 본질적으로 함수이므로, 확장 프로퍼티를 만들 수도있음
- 프로퍼티는 원칙적으로 상태를 나타내거나 설정하기 위한 목적으로만 사용하는 것이 좋고, 다른 로직 등을 포함하지 않아야 함
- 프로퍼티 대신에 함수를 사용하는 것이 좋은 경우
    - 연산 비용이 높거나, 복잡도가 O(1)보다 큰 경우
    - 비즈니스 로직을 포함하는 경우
    - 같은 동작을 연속적으로 두 번했는데 다른 값이 나올 수 있다면, 함수를 사용하는 것이 좋음
    - 게터에서 프로피터의 상태가 변경이 일어나는 경우 함수를 사용하는 것이 좋음
#### 아이템 17: 이름 있는 아규먼트를 사용하라
- 디폴트 아규먼트의 경우 아규먼트 이름 사용
    - 프로퍼티가 디폴트 아규몬트를 가질 경우, 항상 이름을 붙여서 사용하는 것이 좋음
- 같은 타입의 파라미터가 많은 경우 아규먼트 이름 사용
- 함수 타입 파라미터
    - 함수 타입 파라미터는 마지막 위치에 배치하는 것이 좋음
#### 아이템 18: 코딩 컨벤션을 지켜라
- 컨벤션 도구
    - intellij 포메터
    - klint
- 많은 파라미터를 갖고있는 클래스, 함수는 각각의 파라미터를 한 줄씩 작성하는 방법을 사용
- 프로젝트의 모든 코드는 마치 한사람이 작성한 것처럼 작성되어야 함

## 2부. 코드 설계
### 3장. 재사용성
#### 아이템 19: knowledge를 반복하여 사용하지 말라
- 프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다
- knowledge
    - 프로그래밍에서 knowledge는 넓은 의미로 '의도적인 정보'를 뜻함
    - 로직: 프로그램이 어떠한 식으로 동작하는지와 프로그램이 어떻게 보이는지
    - 공통 알고리즘: 원하는 동작을 하기 위한 알고리즘
- 모든 것은 변화한다
    - 모든 것은 변화하고, 우리는 이데 대비해야 함
    - 변화할 때 가장 큰 적은 knowledge가 반복되어 있는 부분
    - knowledeg 반복은 프로젝트의 확장성을 막고, 쉡게 깨지게 만듬
- 언제 코드를 반복해도 될까?
    - 함께 변경될 가능성이 높은가? 따로 변경될 가능성이 높은가? 라는 질문으로 결정
    - 코드를 추출하는 이유는 변경을 쉽게 만들기 위함
- 단일 책임 원칙
    - 단일 책임 원칙이란 '클래스를 변경하는 이유는 단 한가지여야 한다'라는 의미
    - 서로 다른 곳에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많음(완전히 다른 knowledge로 취급하는 것이 좋음)
#### 아이템 20: 일반적인 알고리즘을 반복해서 구현하지 말라
- 나만의 유틸리티 구현하기
    - 함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋음 (side-effect 없는게 좋음)
    - 최상위 함수와 비교해서, 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있으므로 좋음
    - 수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 확장 리시버로 사용하는 것이 가독성 측에서 좋음
    - 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능 등으로 제안이 이루어지므로 쉽게 찾을 수 있음
- 정리
    - 일반적인 알고리즘을 반복해서 만들지 않기
    - 대부분 stdlid에 이미 정의되어 있을 가능성이 높음
#### 아이템 21: 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라
- 프로퍼티 위임을 사용하면 일반적인 프로퍼티의 행위를 추출해서 재사용할 수 있음
    - 대표적인 예로 지연 프로퍼티가 있음
- 프로퍼티 위임을 사용하면, 이외에도 변화가 있을 때 이를 감지하는 observable 패턴을 쉽게 만들 수 있음
- 코틀린은 프로퍼티 위임을 사용해서 간단하고 type-safe하게 구현할 수 있음
- getValue, setValue 메서드가 여러개 있어도 문제가 없음
    - 상황에 따라서 적절한 메서드가 선택
#### 아이템 22: 일반적인 알고리즘을 구현할 때 제네릭을 사용하라
- 타입 파라미터는 컴파일러에 타입과 관련된 정보를 제공하여 컴파일러가 타입을 조금이라도 더 정확하게 추측할 수 있게 해줌
- 제너릭 제한
    - 타입 파라미터의 중한 기능 중 하나는 구체적인 타입의 서브타입만 사용하게 제한하는 것
#### 아이템 23: 타입 파라미터의 섀도잉을 피하라
- 쉐도잉: 지역 파라미터가 외부 스코프에 있는 파라미터를 가릴때 (파라미터 이름을 사용하는 경우)
- 타입 파라미터 쉐도잉을 피해야 함
- 타입 파라미터 새도잉이 발생한 코드는 이해하기 어려울 수 있음
#### 아이템 24: 제네릭 타입과 variance 한정자를 활용하라
- 함수 타입
    - 함수 타입을 사용할 떄는 자동으로 variance 한정자가 사용
    - 코틀린 함수 타입의 모든 파라미터 타입은 contravariant(in)
    - 모든 리턴 타입은 covariant(out)
- variance 한정자의 안정성
    - 자바의 배열은 convariant
        - 배열 기반으로 제네릭 연산자는 정렬 함수 등을 만들기 위해서
#### 아이템 25: 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라
- 풀스택 개발
    - 코틀린이 자바스크립트로 컴파일될 수 있음
    - 코틀린을 활용하여 다양한 웹 애플리케이션을 만들 수 있음 (백엔드 + 프론트)
    - 단순하게 만들 수 있다는 개념을 떠나서, 서로 코드를 공유할 수 있다는 의미
- 모바일 개발
    - 코틀린의 멀티 플랫폼 기능을 활용하면, 로직을 한 번만 구현하고, 두 플랫폼에서 이를 재사용할 수 있음 (android, ios)
- 라이브러리
    - 공통 모듈을 정의할 수 있다는 것은 라이브러리에 있어서 강력한 도구
    - 플랫폼에 크게 의존하지 않음
- 함께 사용하기
    - 코틀린/jvm 백엔드 개발: 스프링, Ktor 등
    - 코트린/js 웹사이트 개발: 리액트 등
    - 코틀린/jvm 안드로이드 개발: 안드로이드 SDK 등
    - 코틀린/네이티브 Objective-C/스위프트로 IOS 개발
    - 코틀린/jvm 사용한 데스크톱 개발: TornadoFX 등
    - 코틀린/네이티브로 사용한 라이베리파이, 리눅스, macOS 프로그램 개발
### 4장. 추상화 설계
- 추상화는 프로그래밍 세계에서 가장 중요한 개념 중 하나
- 프로그래밍에서의 추상화
    - 추상화를 설계한다는 것은 단순하게 모듈 또는 라이브러리로 분리한다는 의미가 아님
    - 강력한 프로그래밍 언어들이 당연히 갖고 있는 기능 중 하나는 공통 패턴에 이름을 붙여서 추상화를 만든느 기능
        - 함수, 델리게이트, 클래스 등이 대표적인 예
- 추상화 목적
    - 복잡성을 숨기기 위해
    - 코드를 체계화하기 위해
    - 만드는 사람에게 변화의 자유를 주기 위해
#### 아이텀 26: 함수 내부의 추상화 레벨을 통일하라
- 추상화 레벨
    - 높은 레벨로 갈수록 물리 장치로부터 점점 멀어짐
    - 프로그래밍에서는 일반적으로 높은 레벨일수록 프로세서로부터 멀어진다고 표현
    - 높은 레벨일수록 단순함을 얻지만, 제어력을 잃음
- 추상화 레벨 동일
    - 함수도 높은 레벨과 낮은 레벨을 구분해서 사용해야 한다는 원칙이 있음
        - 추상화 레벨 통일 (Single Level of Abstraction, SLA)원칙이라고 부름
    - 함수는 간단해야 함
#### 아이템 27: 변화로부터 코드를 보호하려면 추상화를 사용하라
- 상수
    - 리터널은 아무것도 설명하지 않음
    - 반복적으로 등장하는 리터럴을 상수 프로퍼티로 변경하면 해당 값에 의미있는 이름을 붙일 수 있음
    - 상수의 값을 변경해야 할 때 쉽게 변경할 수 있음
    - 두 번 이상 사용되는 값은 상수로 추출하는 것이 좋음
- 함수
    - 일반적인 알고리즘을 확장함수로 추출하면 코드를 항상 기억해 두지 않아도 괜찮음
        - 사용하는 방법이 변경되어도, 확장 함수 부분만 수정되면 되므로 유지보수성이 향상
    - 함수는 매우 단순한 추상화지만, 제한이 많음
    - 함수는 상태를 유지하지 않음
    - 함수 시그니처를 변경하면 프로그램 전체에 큰 영향을 줄 수 있음
- 클래스
    - 구현을 추상화할 수 있는 더 강력한 방법으로는 클래스가 있음
        - 상태를 가질 수 있음
        - 많은 함수를 가질 수 있음
    - 만약 클래스가 final이면, 해당 클래스 타입 아래에 어떤 구현이 있는지 알 수 있음
    - open 클래스를 활용하면 더 자유를 얻을 수 있음
- 인터페이스
    - 코틀린 표준 라이브러리를 읽어보면, 거의 모든 것이 인터페이스로 표현
        - listOf 함수는 List 리턴 (List 인터페이스), listOf는 팩토리 메서드라고 할 수 있음
        - Iterable 또는 Collection의 함수로서 List, Map 등을 리턴함 (모두 인터페이스)
        - 프로퍼티 위임은 ReadOnlyProperty 또는 ReadWriteProperty 뒤에 숨겨짐
            - 모두 인터페이스, 실질적인 클래스는 일반적으로 private
            - 함수 lazy는 Lazy 인터페이스를 리턴 함
        - 라이브러리를 만드는 사람은 내부 클래스의 가시성을 제한하고, 인터페이스를 통해 이를 노출하는 코드를 많이 사용 
        - 인터페이스 뒤에 객체를 숨김으로써 실질적인 구현을 추상화하고, 사용자가 추상화된 것에만 의존하게 만들 수 있음 (즉 결합을 줄일 수 있음)
- 추상화가 주는 자유
    - 상수로 추출
    - 동작을 함수로 래핑
    - 함수를 클래스로 래핑
    - 인터페이스 뒤에 클래스를 숨김
    - 보편적인 객체를 특수한 객체로 래핑
- 추상화의 문제
    - 추상화는 많음 것을 숨길 수 있는 테크닉, 어느 정도 숨겨야 개발이 쉬워지는 것도 사실이지만 너무 많은 것을 숨기면 결과를 이해하는 것 자체가 어려움
    - 추상화가 너무 많으면 코드를 이해하기 어려움
    - 추상화가 많은 코드를 보면, 이해하기 어렵다는 생각 때문에 코드를 제대로 읽기도 전에 두려움에 사로잡힐 수 있음
    - 단위 테스트와 문서의 예제는 추상화가 어떻게 사용되는지 확실하게 보여줌
- 어떻게 균형을 맞춰야 할까?
    - 모든 추상화는 자유를 주지만, 코드가 어떻게 돌아가는 것인지 이해하기 어렵게 만듬
    - 여러 요소들에 따라 달라짐
        - 팀의 크기
        - 팀의 경험
        - 프로젝트 크기
        - 특정 세트
        - 도메인 지식
    - 많은 개발자가 참여하는 프로젝트는 이후에 객체 생성과 사용 방법을 변경하기 어려움
        - 추상화 방법을 사용하는 것이 좋음 (최대한 모듈과 파트를 분리하는 것이 좋음)
    - 의존성 주입 프레임워크를 사용하면, 생성이 얼마나 복잡한지 신경 쓰지 않아도 됨
        - 클래스 등은 한 번만 정의하면 되기 때문
    - 테스트를 하거나, 다른 애플리케이션을 기반으로 새로운 애플리케이션을 만든다면 추상화를 사용하는 것이 좋음
    - 프로젝트가 작고 실험적이라면, 추상화를 하지 않고도 직접 변경해도 괜찮음
    - 항상 무언가 변화할 수 있다고 생각하는 것이 좋음
#### 아이템 28: API 안정성을 확인하라
- 프로그래밍에도 안정적이고 최대한 표준적인 API를 선호
- 버전 번호를 MAJOR, MINOR, PATCH로 나누어 구성
    - MAJOR 버전: 호환되지 않는 수준의 API 변경
    - MINOR 버전: 이전 변경과 호환되는 기능 추가
    - PATCH 버전: 간단한 버그 수정
- MAJOR 증가시킬 떄는 PATCH를 0으로 돌림
- 메이저 버전인 9인 경우(0.y.z)는 초기 개발 전용 버전을 의미
    - 언제든지 변경 가능성이 있고, 안정적이지 않다는 의미
- 안정적인 API 일부를 변겨해야 한다면, 전환하는데 시간을 두고 @Deprecated 어노테이션을 활용하여 사용자에게 미리 알려줘야 함
    - 적절한 대한은 있다면 ReplaceWith 붙여주는 게 좋음
#### 아이템 29: 외부 API를 랩(wrap)해서 사용하라
- 잠재적으로 불안정하다고 판단되는 외부 라이브러리 API를 랩(wrap)해서 사용
#### 아이템 30: 요소의 가시성을 최소화하라
- 작은 인터페이스는 배우기 쉽고 유지하기 쉬움
- 기능이 많은 클래스보다는 적은 클래스를 이해하는 것이 쉬움
- 구체 접근자의 가시성을 제한해서 모든 프로퍼티를 캡슐화하는 것이 좋음
- 가시성 한정자 사용하기
    - 내부적인 변경 없이 작은 인터페이스를 유지하고 싶다면, 가시성을 제한하면 됨
    - 기본적으로 클래스와 요소를 외부에 노출할 필요가 없다면 가시성을 제한해서 외부에게 접근할 수 없게 만드는 것이 좋음
    - 클래스 멤버의 가시성 한정자
        - public(디폴트): 어디에서나 볼 수 있음
        - private: 클래스 내부에서만 볼 수 있음
        - protected: 클래스와 서브클래스 내부에서만 볼 수 있음
        - internal: 모듈 내부에서만 볼 수 있음
    - 최상위 요소 가시성 한정자
        - public(디폴트): 어디에서나 볼 수 있음
        - private: 같은 파일 내부에서만 볼 수 있음
        - internal: 모듈 내부에서만 볼 수 있음
#### 아이템 31: 문서로 규약을 정의하라
- 무엇을 하는지 명확하게 설명하고 싶다면, KDoc 주석을 부여주는 것이 좋음
- 주석을 써야 할까?
    - 주석을 함꼐 사용하면 요소(함수, 클래스)에 더 많은 내용의 규약을 설명할 수 있음
    - 현대의 주석은 문서를 자동 생성하는데 많이 사용
    - 대부분의 기능은 이름 등의로도 무엇을 하는지 확실하게 알 수 있으므로, 주석을 활용한 추가적인 설명이 필요 없음
    - 함수 이름과 파라미터만드으로 정확하게 표현되는 요소에는 따로 주석을 넣지 않는 것이 좋음
- KDoc 형식
    - 첫번째 부분은 요소에 대한 요약 설명
    - 두 번재 부분은 상세 설명
    - @parm <name>: '함수 파라미터' 또는 '클래스, 프로퍼티, 함수 타입 파라미터' 문서화
    - @return: 함수의 리턴 값을 문서화
    - @constructor: 클래스의 기본 생성자를 문서화
    - @receiver: 확장 함수의 리시버를 문서화
    - @property <name>: 명확한 이름을 갖고 있는 클래스의 프로퍼티를 문서화 (기본 생성자에 정의된 프로퍼티)
    - @throws <class>, @exception <class>: 메서드 내부에서 발생할 수 있는 예외를 문서
    - @sample <identifier>: 정규화된 형식 이름을 사용해서 함수의 사용 예를 문서
    - @see <identifier>: 특정한 클래스 또는 메서드에 대한 링크를 추가
    - @author: 요소의 작성자를 지정
    - @sine: 요소의 대한 버전을 지정
    - @supress: 이를 지정하면, 만들어지는 문서에서 해당 요소가 제외
#### 아이템 32: 추상화 규약을 지켜라
- 프로그램을 안정적으로 유지하고 싶다면, 규약을 지켜야 함
- 규약을 깨야한다면 잘 문서화해야 함
### 5장. 객체 생성
#### 아이템 33: 생성자 대신 팩토리 함수를 사용하라
- 생성자 역할을 대신해주는 함수를 팩토리 함수라고 부름
- 팩토리 함수 장점
    - 생성자와 다르게 함수에 이름을 붙일 수 있음
        - 객체가 생성되는 방법과 아규먼트로 무엇이 필요한지 설명이 가능
    - 생성자와 다르게 원하는 형태로 타입을 리턴 가능
        - 다른 객체를 생성할 때 사용 가능
        - 인터페이스 뒤에 시제 객체의 구현을 숨길대 유용하게 사용할 수 있음
    - 생성자와 다르게, 호출될 때마다 새 객체를 만들 필요가 없음
        - 함수를 사용해서 객체를 생성하면 싱글톤 패턴처럼 객체를 하나만 생성하게 강제하거나, 최적화를 위해 캐싱 메커니즘을 사용할 수 있음
    - 아직 존재하지 않는 객체를 리턴할 수 있음
        - 이러한 특징 때문에 어노테이션 처리를 기반으로 하는 라이브러리에서는 팩토리 함수를 많이 사용
        - 프로젝트를 빌드하지 않고도 앞으로 만들어질 객체를 사용하거나, 프록시를 통해 만들어지는 객체를 사용 할 수 있음
    - 객체 외부에 팩토리 함수를 만들면, 가시성을 원하는 대로 제어할 수 있음
    - 팩토리 함수는 인라인으로 만들 수 있으며, 그 파라미터들을 reified로 만들 수 있음
    - 복잡한 객체를 만들어 낼 수 있음
    - 원하는 때에 생성자를 호출할 수 있음
- 팩토리 함수 주의할 점
    - 서브클래스 생성에는 슈퍼클래스의 생성자가 필요하기 때문에, 서브 클래스를 만들어 낼 수 없음
        - 팩토리 함수로 슈퍼클래스를 만들기로 했다면, 서브클래스에도 팩토리 함수를 만들어 해결
- 자바에서는 팩토리 패턴을 구현할 때 생성자를 private으로 만들지만, 코틀린에서는 그렇게 하는 경우가 거의 없음
- 코틀린에서는 추가적인 생성자보다는 팩토리를 많이 사용
- Companion 객체 팩토리 함수
    - companion 객체를 사용하는 것
    - 정적 팩토리 함수(static factory function)와 같음
    - 함수 이름
        - from: 파라미터를 하나 받고, 같은 타입의 인스턴스 하나를 리턴하는 타입변환 함수
        - of: 파라미터를 여러개 받고, 이를 통해서 인스턴스를 만들어 주는 함수
        - valueOf: from, of와 비슷한 기능을 하면서도, 의미를 조금 더 쉽게 읽을 수 있게 이름을 붙인 함수
        - instance or getInstance: 싱글톤으로 인스턴스 하나를 리턴하는 함수, 파라미터가 있을 경우 아규먼트를 기반으로 하는 인스턴스를 리턴 (일반적으로 같은 아규먼트를 넣으면, 같은 인스턴스를 리턴하는 형태로 작동)
        - createInstance or newInstance: getInstance처럼 동작하지만, 싱글톤이 적용되지 않아서, 함수를 호출할 떄마다 새로운 인스턴스를 만들어서 리턴함
        - getType: getInstance처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을때 사용하는 이름
        - newType: newInstance처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을 떄 사용하는 이름
    - companion 객체는 인터페이스를 구현, 상속 가능
    - companion 객체는 값을 가질 수 있음
        - 캐싱을 구현하거나, 테스트를 위한 가짜 객체 생성을 할수 있음
- 확장 팩토리 ㅎ마수
    - 이미 companion 객체가 존재하면, 이 객체의 함수처럼 사용할 수 있는 팩토리 함수를 만들어야 할 떄가 있음
- 최상위 팩토리 함수
    - 객체를 만드는 흔한 방법 중 하나 (listOf, setOf, mapOf)
    - 최상위 함수의 이름을 클래스 메서드 이름처럼 만들면, 다양한 혼란을 일으킬 수 있음
        - 이름을 신중하게 생각
- 가짜 생성자
    - 최상위 함수는 생상자처럼 보이고, 생성자처럼 작동, 하지만 팩토리 함수와 같은 모든 장점을 갖음
    - 진짜 생성자 대신 가짜 생성자를 만드는 이유
        - 인터페이스를 위한 생성자를 만들고 싶을 때
        - reified 타입 아규먼트를 가제 할고 싶을 때
    - invoke 연산자를 갖는 companion 객체를 사용하여 가짜 생성자를 선언할 수 있음
        - 거의 사용되지 않는 방식, 추천하는 방식은 아님
- 팩토리 클래스의 메서드
    - 팩토리 클래스는 클래스의 상태를 가질 수 있다는 특징 때문에 팩토리 함수보다 다양한 기능을 갖음
- 정리
    - 팩토리 함수를 정의하는 가장 일반적인 방법은 companion 객체를 사용하는 것
#### 아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라
- 점층적 생성자 패턴
    - 여러가지 종류의 생성자를 사용하는 간단한 패턴
- 빌더 패턴
    - 자바에서는 이름 있는 파라미터와 디폴트 아규먼트를 사용할 수 없음
    - 자바에서는 빌더 패턴을 사용
- 빌더 패턴을 사용하는 것보다 이름 있는 파라미터를 사용하는 것이 좋은 이유
    - 더 짧음
    - 명확함
    - 더 사용하기 쉬움
    - 동시성과 관련된 문제가 없음
- DSL 빌더를 활용하는 패턴이 전통적인 빌더 패턴보다 훨씬 유연하고 명확
    - 코틀린은 이와 같은 형태의 코드를 많이 사용
- 정의
    - 코틀린에서는 점층적 생성자 패턴을 사용하지 않음 
    - 빌더 패턴도  거의 사용하지 않음
    - 디폴트 아규먼트를 활용하는 것이 좋음
    - DSL을 활용하는 것이 좋음
#### 아이템 35: 복잡한 객체를 생성하기 위한 DSL을 정의하라
- DSL은 복잡한 객체, 계층 구조를 갖고 있는 객체들을 정의할 때 굉장히 유용
- DSL을 만드는 것은 약간 힘든 일이지만, 한 번 만들고 나면 보일러플레이트와 복잡성을 숨기면서 개발자의 의도를 명확하게 표현할 수 있음
- 코를린의 DSL의 type-safe이므로, 여러가지 유용한 힌트를 활용할 수 있음
- 사용자 정의 DSL 만들기
    - 리시버를 사용하는 함수 타입에 대한 개념을 이해해야 함
- 언제 사용해야 할까?
    - 단순한 기능까지 DSL을 사용한다는 것은 닭잡는데 소 잡는 칼을 쓰는 꼴
    - 복잡한 자료 구조, 계층적인 구조, 거대한 양의 데이터를 표현할 때 유용
    - DSL은 많이 사용되는 구조의 반복을 제거할 수 있게 해줌
    - 많이 사용되는 반복되는 코드가 있고 이를 간단하게 만들 수 있는 별도의 코틀린 기능이 없다면 DSL 사용을 고려해 보는 것이 좋음
### 6장
#### 아이템 36: 상속보다는 컴포지션을 사용하라
- 상속은 굉장이 강력한 기능으로 'is-a'관계의 객체 계층 구조를 만드릭 위해 설계되었음
- 상속은 관계가 명확하지 않을 때 사용하면 여러가지 무네작 발생할 수 있음
    - 단순하게 코드 추출 또는 재사용을 위해 상속을 하려고 한다면, 조금 더 신중하게 생각해야 함
- 일반적으로 상속보다 컴포지션을 사용하는 것이 좋음
- 간단한 행위 재사용
    - 상속은 하나의 클래스만을 대상으로 할 수 있음
        - 상속을 사용해서 행위를 추출하다 보면, 많은 함수를 갖는 거대한 BaseXXX 클래스를 만들게 되고, 굉장히 깊고 복잡한 계층 구조가 만들어짐
    - 상속은 클래스의 모든 것을 가져옴
        - 불필요한 함수를 갖는 클래스가 만들어짐
    - 상속은 이해하기 어려움
        - 메서의 작동 방식을 이해하기 위해 슈퍼클래스를 여러번 확인해야 한다면 문제가 있는 것
- 모든 것을 가져올 수밖에 없는 상속
    - 상속은 객체의 계층 구조를 나타낼 때 굉장히 좋은 도구, 일부분을 재사용하기 위한 목적으로는 적합하지 않음
    - 일부분만 재사용하고 싶다면 컴포지션을 사용하는 것이 좋음
- 캡슐화를 깨는 상속
    - 내부적인 구현 방법 변경에 의해서 클래스이 캡슐화가 깨질수 있음
- 오버라이딩 제한하기
    - 개발자가 상속용으로 설계되지 않은 클래스를 상속하지 못하게 하려면, final을 사용
    - 상속용으로 설계된 메서드에만 open을 붙이면 됨
- 정리
    - 컴포지션은 더 안전
        - 다른 클래스의 내부적인 구현에 의존하지 않고, 외부에서 관찰되는 동작에만 의존하므로 안전
    - 컴포지션은 더 유연
        - 상속은 한 클래스만을 대상이지만 컴포지션은 여러 클래스를 대상으로 할 수 있음
    - 컴포지션은 더 명시적
        - 장점이자 단점
        - 슈퍼클래스의 메서드를 사용할 때는 리시버를 따로 지정할 필요가 없음 (덜 명시적)
            - 코드가 짧아질 수 있지만, 메서드가 어디에서 왔는지 혼동될 수 있으므로 위험할 수 있음
        - 컴포지션을 활용하면 리시버를 명시적으로 활용할 수밖에 없으므로 메서드가 어디에 있는 것인지 확실하게 알 수 있음
    - 컴포지션은 생각보다 번거로움
        - 상속을 사용할 때보다 코드를 수정해야 하는 경우가 더 많음
    - 상속은 다형성을 활용할 수 있음
        - 상속을 사용할 경우 슈퍼클래스와 서브클래스의 규약을 항상 잘 지켜서 코드를 작성해야 함
    - 일반적으로 상속보다 컴포지션을 사용하는 것이 좋음
    - 슈퍼클래스를 상속하는 몯느 서브 클래스는 슈퍼클래스로도 동작할 수 있어햐 함
#### 아이템 37: 데이터 집합 표현에 data 한정자를 사용하라
- data 한정자를 붙이면 몇가지 함수가 자동으로 생성
    - toString
    - equals, hashCode
    - copy
    - componentN
- 튜플 대신 데이터 클래스 사용하기
    - 튜플은 데이터 클래스와 같은 역할을 하지만 가독성이 나쁨
    - 튜플만 보고 어떤 타입을 나타내는지 예측할 수 없음
    - 튜블은 값에 간단하게 이름을 붙일 때, 표준 라이브러리에서 볼 수 있는 것처럼 미리 알 수 없는 집합을 표현할 때 사용하면 좋음
    - 
#### 아이템 38: 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라
#### 아이템 39: 태그 클래스보다는 클래스 계층을 사용하라
#### 아이템 40: equals의 규약을 지켜라
#### 아이템 41: hasCode의 규약을 지켜라
#### 아이템 42: comporeTo의 규약을 지켜라
#### 아이템 43: API의 필수적이지 않는 부분을 확장 함수로 추출하라
#### 아이템 44: 멤버 확장 함수의 사용을 피하라

## 3장. 효율성
### 7장
#### 아이템 45: 불필요한 객체 생성을 피하라
#### 아이템 46: 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라
#### 아이템 47: 인라인 클래스의 사용을 고려하라
#### 아이템 48: 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라