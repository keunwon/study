# 이펙티브 코틀린

## 코틀린의 철학
- 생산성: 애플리케이션을 빠르게 생산합니다
- 확장성: 애플리케이션의 규모가 커져도, 개발 비용이 급격하게 증가하지 않습니다
- 유지보수성: 유지보수를 굉장히 쉽게 할수 있습니다
- 신뢰성: 애플리케이션이 예상한 대로 동작하므로 오류가 적습니다
- 효율성: 애플리케이션이 굉장히 빠르게 동작하면, 리소스가 적게 필요합니다

## 1부. 좋은 코드
### 1장. 안정성
#### 아이템 1: 가변성을 제한하라
- 상태를 갖게 하는 것은 양날의 검
    - 시간의 변화에 따라서 변화하는 요소를 표현할 수 있다는 것은 유용, 상태를 적절히 관리하는 것은 어려움
    - 프로그램을 이해하고 디버그하기 힘듬
    - 코드의 실행을 추론하기 어려움 (시점에 따라 값이 달라질 수 있음)
    - 멀티스레드 환경에서는 적절한 동기화가 필요
    - 테스트 하기 어려움 (모든 상태를 테스트가 필요, 변경이 많을수록 더 많은 조합을 테스트해야 함)
    - 상태 변경이 일어날 때, 다른 부분에 알려야 하는 경우가 있음
- 코틀린에서 가변성 제한하기
    - 읽기 전용 프로퍼티(val)
    - 가변 컬렉션과 읽기 전용 컬렉션 구분
    - 데이터 클래스의 copy
- 다른 종류의 변경 가능 지점
    - 첫째번째: mutable 컬렉션을 사용, 두번째: var로 읽고 쓸 수 있는 프로퍼티 사용
    - mutable 컬렉션을 사용하는 것이 처음에는 더 간단하게 느껴지겠지만, mutable 프러퍼티를 사용하면 객체 변경을 제어하기 더 쉬움
    - 최악의 방식은 프로퍼티와 컬렉션을 모두 변경 가능한 지점으로 만드는 것
- 변경 가능 지점 노출하지 말기
    - 상태를 나타내는 mutable 객체를 외부에 노출하는 것은 굉장히 위험
    - 돌발적인 수정이 이어날 때 위험할 수 있음
        - 방어적 복제(defensive copying)로 해결
        - 컬렉션은 객체를 일긱 전용 슈퍼타입으로 업캐스트하여 가변성을 제한
- 정리
    - var 보다는 val
    - mutable 보다는 immutable 프로퍼티 사용
    - mutable 객체와 클래스보다는 immutable 객체와 클래스를 사용
    - 변경이 필요한 대상을 만들어야 한다면, immutable 데이터 클래스로 만들고 copy 활용
    - 컬렉션에 상태를 저장해야 한다면, mutable 컬렉션보다는 읽기 전용 컬렉션을 사용
    - mutable 객체를 외부에 노출하지 않는 것이 좋음
#### 아이템 2: 변수의 스코프를 최소화하라
 - 프로퍼티보다는 지역 변수를 사용하는 것이 좋음
 - 최대한 좁은 스코프를 갖게 변수를 사용
    - 프로그램을 추적하고 관리하기 쉬움
- 변수는 읽기 전용 또는 읽고 쓰기 전용 여부와 상관없이, 변수를 정의할 때 최기화되는 것이 좋음
- 캡처링
    - 시퀀스 빌더를 사용해서 
#### 아이템 3: 최대한 플랫폼 타입을 사용하지 말라
- 플랫폼 타입이란, 다른 프로그래밍 언어에서 전달되어서 nullable인지 아닌지 알 수 없는 타입
- 플랫폼 타입은 타입 이름 뒤에 '!' 기호를 붙여서 표기
- 플랫폼 타입은 안전하지 않으므로, 최대한 빨리 제거하는 것이 좋음
#### 아이템 4: inferred 타입으로 리턴하지 말라
- 코틀린의 타입 추론(type inference)은 JVM 세계에서 가장 널리 알려진 코틀린의 특징
- 자바도 자바10부터 코틀린을 따라 타입 추론을 도입
- inferred 타입은 정확하게 오른쪽에 있는 피연사에 맞게 설정 (슈퍼클래스 or 인터페이스로 설정 불가)
- 리턴 타입은 외부에서 확인할 수 있게 명시적으로 지정해 주는 것이 좋음
- 정리
    - 타입을 확실하게 지정해야 하는 경우 명시적으로 타입을 지정해야 함
    - 안전을 위해서 외부 API를 만들 때는 반드시 타입을 지정하고, 지정한 타입을 특별한 이유와 확실한 확인 없이는 제거하지 말자
#### 아이템 5: 예외를 활용해 코드에 제한을 걸어라
- require: 아규먼트를 제한
- check:  상태와 관련된 동작을 제한
- assert: 어떤 것이 true인지 확인 (assert 블록은 테스트 모드에서만 작동)
- return or  throw와 함께 활용하는 Elvis 연산자
- 제한을 걸어 주면 다양한 장점
    - 제한을 걸면 문서를 보지 않은 개발자도 문제를 확인
    - 예상하지 못한 동작을 하지 않고 예외를 throw 함
    - 코드가 어느정도 자체적으로 검사
    - 스마트 캐스트 기능을 활용
- 아규먼트(require)
    - 예제
        - 숫자를 아규먼트로 받아서 팩토리얼 계산한다면 숫자는 양의 정수여야 함
        - 좌표들을 아큐먼트로 받아서 클러스터를 찾을 때는 비어 있지 않은 좌표 목록이 필요함
        - 사용자로부터 이메일 주소를 입력받을 때는 값이 입려되어 있는지, 이메일 형식이 올바른지 확인
- 상태(check)
    - 예제
        - 어떤 객체가 미리 초기화되어 있어댜지만 처리를 하게 하고 싶은 함수
        - 사용자가 로그인했을 때만 처리를 하게 하고 싶은 함수
        - 객체를 사용할 수 있는 시점에 사용하고 싶은 함수
    - require와 비슷하지만 지정된 예측을 만족하지 못할 때, 상태가 올바른지 확인할 때 사용
    - 일반적으로 require 블록 뒤에 배치
- Assert 계열 함수 사용
    - 단위 테스트 대신 함수에서 assert를 사용하면 장점
        - Assert 계열의 함수는 코드를 자체 점검하며, 더 효율적으로 테스트
        - 특정 상황이 아닌 모든 상황에 대한 테스트 확인
        - 실행 시점에 정확하게 어떻게 되는지 확인할 수 있음
        - 실제 코드가 더 빠른 시점에 실패하게 만듬 (예상하지 못한 동작이 언제 어디서 실행되었는지 쉽게 찾을 수 있음)
    - 이를 활용해도 단위 테스트는 따로 작성해야 함
    - assert는 파이썬에서 굉장히 많이 사용되고, 자바에서는 딱히 사용되지 않음 (코틀린에서 안정적으로 코드를 만들고 싶을 때 양념처럼 사용할 수 있음)
- 정리
    - 제한을 훨씬 더 쉡게 확인
    - 애플리케이션을 더 안정적으로 지킬수 있음
    - 코드를 잘못 쓰는 상황을 막을 수 있음
    - 스마트 캐스팅을 활용
#### 아이템 6: 사용자 정의 오류보다는 표준 오류를 사용하라
- 가능하다면 직접 오류를 정의하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 좋음
- 표준 라이브러리의 오류는 많은 개발자가 알고 있으므로, 이를 재사용하는 것이 좋음
- 일반적으로 사용되는 예외
    - IllegalArgumentException or IllegalStateException: require, check 사용하여 throw 할 수 있는 예외
    - IndexOutOfBoundsException: 인덱스 파라미터의 값이 범위를 벗어남
    - ConcurrentModificationException: 동시 수정을 금지했는데 발생했을 때
    - UnsupportedOperationException: 사용자가 사용하려고 했던 메서드가 현재 객체에서는 사용할 수 없다는 것을 나타냄
    - NoSuchElementException: 사용자가 사용하려고 했던 요소가 존재하지 않음
#### 아이템 7: 결과 부족이 발생할 경우 null과 Failure를 사용하라
- 함수가 원하는 결과를 만들어 낼 수 없을 때가 있음
    - null or '실패를 나타내는 sealed클래스(일반적으로 Failure라는 이름붙임)' 반환
    - 예외를 throw 함
- 예외는 정보를 전달하는 방법으로 사용해서는 안됨
- 예외는 잘못된 특별한 상황을 나타내야 하며, 처리
- null or Failure는 예상되는 오류를 표현할 때 굉장히 좋음
    - 명시적, 효율적이며 간단한 방법으로 처리
    - 예측할 수 있는 범위의 오류는 null or Failure를 사용
    - 예측하기 어려운 예외적인 범위의 오류는 예외를 throw해서 처리하는 것이 좋음
    - try-catch 블록 내부에 코드를 배치하면, 컴파일러가 할 수 있는 최적화가 제한
#### 아이템 8: 적절하게 null을 처리하라
- nullable 타입은 세가지 방법으로 처리
    - ?., 스마트 캐스팅, Elvis 연산자 등을 활용해서 안전하게 처리
    - 오류를 throw 
    - 함수 또는 프로퍼티를 리팩터링해서 nullable 타입이 나오지 않게 바꿈
- not-null assertion(!!)과 관련된 문제
    - '!!'연산자를 사용하는 방법은 좋은 방법이 아님 (문제는 미래의 어느 순간에 일어남)
    - lateinit or Delegates.notNull 대체하여 사용
    - 코틀린을 대상으로 설계된 API를 활용한다면 '!!' 연산자를 사용하는 것은 이상하게 생각해야 함
- 의미 없는 nullability 피하기
    - 클래스에서 nullability에 따라 여러 함수를 만들어서 제공 (ex. get(), getOrNull())
    - 어떤 값이 클래스 생성 이후 확실하게 설정된다는 보장이 있다면 lateinit or Delegates.notNull 사용
    - 빈 컬렉션 대신 null 리턴하지 말기
- lateinit 프로퍼티와 notNull 델리게이트
    - lateinit 사용
        - 비용 발생
        - 초기화 전에 값을 사용하려면 예외 발생
        - Int, Long, Double, Boolean 같은 기본 타입과 연결된 타입은 사용할 수 없음
            - Delegates.notNull 사용해서 해결
#### 아이템 9: use를 사용하여 리소를 닫아라
- use 사용하면 Closeable/AutoCloseable을 구현한 객체를 쉽고 안전하게 처리할 수 있음
- 파일을 처리할 때는 파일을 한 줄씩 읽어 들이는 useLines를 사용하는 것이 좋음
#### 아이템 10: 단위 테스트를 만들어라
- 코드를 안전하게 만드는 가장 궁극적인 방법은 다양한 종류의 테스트를 하는 것
- 단위 테스트는 개발자가 작성하며, 개발자에게 유용
- 테스트가 잘 만들어져 있다면, 리팩터링하는 것이 두렵지 않음
- 수동 테스트보다 단위 테스트로 확인하는 것이 빠름
- 단점
    - 단위 테스트를 만드는데 시간이 걸림
    - 테스트를 활용할 수 있게 코드를 조정
    - 좋은 단위 테스트를 만드는 작업이 꽤 어려움
        - 잘못 만들어진 단위 테스트는 득보다 실이 큼
### 2장. 가독성
#### 아이템 11: 가독성을 목표로 설계하라
- 인식 부하 감소
    - 가독성이란 코드를 읽고 얼마나 빠르게 이해할 수 있는지를 의미함
    - 뇌는 기본적으로 짧은 코드를 빠르게 읽을 수 있겠지만, 익숙한 코드는 더 빠르게 읽을 수 있음
- 컨벤션
    - 연산자는 의미에 맞게 사용 (invoke 형태로 사용하면 안됨)
    - invoke 연산자와 함께 '람다를 마지막 아규먼트'로 사용하는 것은 신중해야 함
#### 아이템 12: 연산자 오버로드를 할 때는 의미에 맞게 사용하라
- 분명하지 않은 경우
    - 관례를 충적하는지 아닌지 확실하지 않을 때가 문제
    - 의미가 명확하지 않다면, infix를 활영한 확장 함수를 사용하는 것이 좋음
    - 최상위 함수를 사용하는 것도 좋음
- 규칙을 무시해도 되는 경우
    - 도메인 특화 언어(DSL)를 설계할 때
- 정리
    - 연산자 오버라이딩은 그 이름의 의미에 맞게 사용
    - 연자의 의미가 명확하지 않다면, 연산자 오버로딩을 사용하지 않는 것이 좋음
        - infix 확장 함수, 최상위 함수 사용
#### 아이템 13: Unit?을 리턴하지 말라
- 'Unit?' 표현하는 것은 오해의 소지가 있으며, 예측하기 어려운 오류를 만들 수 있음
- 'Unit?' 리터한거나, 이를 기반으로 연산하지 않는 것이 좋음
#### 아이템 14: 변수 타입이 명확하지 않은 경우 확실하게 지정하라
- 가독성 향상 이외에 안전을 위해서도 타입을 지정하는 것이 좋음
- 타입을 무조건 지정하라는 것이 아님(상황에 맞게 사용)
#### 아이템 15: 리시버를 명시적으로 참조하라
- 여러 개의 리시버
    - 스코프 내부에 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내면 좋음
    - also, let을 사용하는 것이 nullable 값을 처리할 때 훨씬 좋은 선택
    - 리시버가 명확하지 않다면, 명시적으로 리시버를 적어서 이를 명확하게 해줘야 함
- DSL 마커
    - 코틀린 DSL 사용할 때는 여러 리시버를 가진 요소들이 중첩되더라도, 리시버를 명시적으로 붙이지 않음
- 정리
    - 짧게 적을 수 있다는 이유만으로 리시버를 제거하지 말기
    - 여러개의 리시버가 있는 상황 등에는 리시버를 명시적으로 적어 주는 것이 좋음
    - 리시버를 명시적으로 지정하면 어떤 리시버의 함수인지를 명확하게 알 수 있으므로 가독성 향상
    - DSL에서 외부 스코프에 있는 리시버를 명시적으로 적게 강제하고 싶다면, DSLMarker 메타 에노테이션을 사용
#### 아이템 16: 프로퍼티는 동작이 아니라 상태를 나타내야 한다
- val 사용해서 읽기 전용 프로퍼티를 만들 때는 field가 만들어지 않음
- 인터페이스에도 프로피터를 정의할 수 있음
- 프로퍼티는 본질적으로 함수이므로, 확장 프로퍼티를 만들 수도있음
- 프로퍼티는 원칙적으로 상태를 나타내거나 설정하기 위한 목적으로만 사용하는 것이 좋고, 다른 로직 등을 포함하지 않아야 함
- 프로퍼티 대신에 함수를 사용하는 것이 좋은 경우
    - 연산 비용이 높거나, 복잡도가 O(1)보다 큰 경우
    - 비즈니스 로직을 포함하는 경우
    - 같은 동작을 연속적으로 두 번했는데 다른 값이 나올 수 있다면, 함수를 사용하는 것이 좋음
    - 게터에서 프로피터의 상태가 변경이 일어나는 경우 함수를 사용하는 것이 좋음
#### 아이템 17: 이름 있는 아규먼트를 사용하라
- 디폴트 아규먼트의 경우 아규먼트 이름 사용
    - 프로퍼티가 디폴트 아규몬트를 가질 경우, 항상 이름을 붙여서 사용하는 것이 좋음
- 같은 타입의 파라미터가 많은 경우 아규먼트 이름 사용
- 함수 타입 파라미터
    - 함수 타입 파라미터는 마지막 위치에 배치하는 것이 좋음
#### 아이템 18: 코딩 컨벤션을 지켜라
- 컨벤션 도구
    - intellij 포메터
    - klink
- 많은 파라미터를 갖고있는 클래스, 함수는 각각의 파라미터를 한 줄씩 작성하는 방법을 사용
- 프로젝트의 모든 코드는 마치 한사람이 작성한 것처럼 작성되어야 함

## 2부. 코드 설계
### 3장. 재사용성
#### 아이템 19: knowledge를 반복하여 사용하지 말라
#### 아이템 20: 일반적인 알고리즘을 반복해서 구현하지 말라
#### 아이템 21: 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라
#### 아이템 22: 일반적인 알고리즘을 구현할 때 제네릭을 사용하라
#### 아이템 23: 타입 파라미터의 섀도잉을 피하라
#### 아이템 24: 제네릭 타입과 variance 한정자를 활용하라
#### 아이템 25: 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라