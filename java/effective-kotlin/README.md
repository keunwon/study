# 이펙티브 코틀린

## 코틀린의 철학
- 생산성: 애플리케이션을 빠르게 생산합니다
- 확장성: 애플리케이션의 규모가 커져도, 개발 비용이 급격하게 증가하지 않습니다
- 유지보수성: 유지보수를 굉장히 쉽게 할수 있습니다
- 신뢰성: 애플리케이션이 예상한 대로 동작하므로 오류가 적습니다
- 효율성: 애플리케이션이 굉장히 빠르게 동작하면, 리소스가 적게 필요합니다

## 1부. 좋은 코드
### 1장. 안정성
#### 아이템 1: 가변성을 제한하라
- 상태를 갖게 하는 것은 양날의 검
    - 시간의 변화에 따라서 변화하는 요소를 표현할 수 있다는 것은 유용, 상태를 적절히 관리하는 것은 어려움
    - 프로그램을 이해하고 디버그하기 힘듬
    - 코드의 실행을 추론하기 어려움 (시점에 따라 값이 달라질 수 있음)
    - 멀티스레드 환경에서는 적절한 동기화가 필요
    - 테스트 하기 어려움 (모든 상태를 테스트가 필요, 변경이 많을수록 더 많은 조합을 테스트해야 함)
    - 상태 변경이 일어날 때, 다른 부분에 알려야 하는 경우가 있음
- 코틀린에서 가변성 제한하기
    - 읽기 전용 프로퍼티(val)
    - 가변 컬렉션과 읽기 전용 컬렉션 구분
    - 데이터 클래스의 copy
- 다른 종류의 변경 가능 지점
    - 첫째번째: mutable 컬렉션을 사용, 두번째: var로 읽고 쓸 수 있는 프로퍼티 사용
    - mutable 컬렉션을 사용하는 것이 처음에는 더 간단하게 느껴지겠지만, mutable 프러퍼티를 사용하면 객체 변경을 제어하기 더 쉬움
    - 최악의 방식은 프로퍼티와 컬렉션을 모두 변경 가능한 지점으로 만드는 것
- 변경 가능 지점 노출하지 말기
    - 상태를 나타내는 mutable 객체를 외부에 노출하는 것은 굉장히 위험
    - 돌발적인 수정이 이어날 때 위험할 수 있음
        - 방어적 복제(defensive copying)로 해결
        - 컬렉션은 객체를 일긱 전용 슈퍼타입으로 업캐스트하여 가변성을 제한
- 정리
    - var 보다는 val
    - mutable 보다는 immutable 프로퍼티 사용
    - mutable 객체와 클래스보다는 immutable 객체와 클래스를 사용
    - 변경이 필요한 대상을 만들어야 한다면, immutable 데이터 클래스로 만들고 copy 활용
    - 컬렉션에 상태를 저장해야 한다면, mutable 컬렉션보다는 읽기 전용 컬렉션을 사용
    - mutable 객체를 외부에 노출하지 않는 것이 좋음
#### 아이템 2: 변수의 스코프를 최소화하라
 - 프로퍼티보다는 지역 변수를 사용하는 것이 좋음
 - 최대한 좁은 스코프를 갖게 변수를 사용
    - 프로그램을 추적하고 관리하기 쉬움
- 변수는 읽기 전용 또는 읽고 쓰기 전용 여부와 상관없이, 변수를 정의할 때 최기화되는 것이 좋음
- 캡처링
    - 시퀀스 빌더를 사용해서 
#### 아이템 3: 최대한 플랫폼 타입을 사용하지 말라
- 플랫폼 타입이란, 다른 프로그래밍 언어에서 전달되어서 nullable인지 아닌지 알 수 없는 타입
- 플랫폼 타입은 타입 이름 뒤에 '!' 기호를 붙여서 표기
- 플랫폼 타입은 안전하지 않으므로, 최대한 빨리 제거하는 것이 좋음
#### 아이템 4: inferred 타입으로 리턴하지 말라
- 코틀린의 타입 추론(type inference)은 JVM 세계에서 가장 널리 알려진 코틀린의 특징
- 자바도 자바10부터 코틀린을 따라 타입 추론을 도입
- inferred 타입은 정확하게 오른쪽에 있는 피연사에 맞게 설정 (슈퍼클래스 or 인터페이스로 설정 불가)
- 리턴 타입은 외부에서 확인할 수 있게 명시적으로 지정해 주는 것이 좋음
- 정리
    - 타입을 확실하게 지정해야 하는 경우 명시적으로 타입을 지정해야 함
    - 안전을 위해서 외부 API를 만들 때는 반드시 타입을 지정하고, 지정한 타입을 특별한 이유와 확실한 확인 없이는 제거하지 말자
#### 아이템 5: 예외를 활용해 코드에 제한을 걸어라
- require: 아규먼트를 제한
- check:  상태와 관련된 동작을 제한
- assert: 어떤 것이 true인지 확인 (assert 블록은 테스트 모드에서만 작동)
- return or  throw와 함께 활용하는 Elvis 연산자
- 제한을 걸어 주면 다양한 장점
    - 제한을 걸면 문서를 보지 않은 개발자도 문제를 확인
    - 예상하지 못한 동작을 하지 않고 예외를 throw 함
    - 코드가 어느정도 자체적으로 검사
    - 스마트 캐스트 기능을 활용
- 아규먼트(require)
    - 예제
        - 숫자를 아규먼트로 받아서 팩토리얼 계산한다면 숫자는 양의 정수여야 함
        - 좌표들을 아큐먼트로 받아서 클러스터를 찾을 때는 비어 있지 않은 좌표 목록이 필요함
        - 사용자로부터 이메일 주소를 입력받을 때는 값이 입려되어 있는지, 이메일 형식이 올바른지 확인
- 상태(check)
    - 예제
        - 어떤 객체가 미리 초기화되어 있어댜지만 처리를 하게 하고 싶은 함수
        - 사용자가 로그인했을 때만 처리를 하게 하고 싶은 함수
        - 객체를 사용할 수 있는 시점에 사용하고 싶은 함수
    - require와 비슷하지만 지정된 예측을 만족하지 못할 때, 상태가 올바른지 확인할 때 사용
    - 일반적으로 require 블록 뒤에 배치
- Assert 계열 함수 사용
    - 단위 테스트 대신 함수에서 assert를 사용하면 장점
        - Assert 계열의 함수는 코드를 자체 점검하며, 더 효율적으로 테스트
        - 특정 상황이 아닌 모든 상황에 대한 테스트 확인
        - 실행 시점에 정확하게 어떻게 되는지 확인할 수 있음
        - 실제 코드가 더 빠른 시점에 실패하게 만듬 (예상하지 못한 동작이 언제 어디서 실행되었는지 쉽게 찾을 수 있음)
    - 이를 활용해도 단위 테스트는 따로 작성해야 함
    - assert는 파이썬에서 굉장히 많이 사용되고, 자바에서는 딱히 사용되지 않음 (코틀린에서 안정적으로 코드를 만들고 싶을 때 양념처럼 사용할 수 있음)
- 정리
    - 제한을 훨씬 더 쉡게 확인
    - 애플리케이션을 더 안정적으로 지킬수 있음
    - 코드를 잘못 쓰는 상황을 막을 수 있음
    - 스마트 캐스팅을 활용
#### 아이템 6: 사용자 정의 오류보다는 표준 오류를 사용하라
#### 아이템 7: 결과 부족이 발생할 경우 null과 Failure를 사용하라
#### 아이템 8: 적절하게 null을 처리하라
#### 아이템 9: use를 사용하여 리소를 닫아라
#### 아이템 10: 단위 테스트를 만들어라