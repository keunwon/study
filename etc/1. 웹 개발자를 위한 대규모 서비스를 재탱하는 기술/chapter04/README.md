# 4. 분산을 고려한 MYSQL 운용

## 11. 인덱스를 올바르게 운용하기
### 분산을 고려한 MYSQL 운용, 세가지 포인트
1. OS 캐시 활용
2. 인덱스
3. 확장을 한다는 전제로  시스템을 설계
### OS 캐시 활용
- 전체 데이터 크기에 주의해서 데이터량이 물리 메모리보다 가능한 적어지도록 유지
- 메모리가 부족할 경우에는 증설
- 대량의 데이터를 저장하려는 테이블은 레코드가 가능한 작아지도록 컴팩트하게 설계
### 인덱스의 중요성 - B트리
- 인덱스는 주로 탐색을 빠르게 하기 위한 것
- MYSQL의 인덱스는 기본적으로 B-Tree 구조
- B트리에 데이터를 삽입할 때는 일정한 규칙에 따라 삽입할 필요가 있는데,  
그 규칙 덕분에 검색할 때 노드를 순회하는 것만으로 자연스럽게 찾고하 하는 데이터에 도달
### 인덱스의 작용
- 기본적으로 인덱스가 사용되는 것
    - where, order by, group by의 조건에 지정된 컬럼

## 12. MYSQL의 분산 (확장을 전재로 한 시스템 설계)
### MYSQL의 리플리케이션 기능
- MYSQL에는 기본 기능으로 리플리케이션 기능이 있음
    - 마스터를 정하고 마스터를 뒤따르는 슬레이브를 정해두면, 마스터에 쓴 내용을 슬레이브가 폴링해서 동일한 내용으로 자신을 갱신하는 기능
### 마스터/슬레이브의 특징 (참조계열은 확장하고 갱신계열은 확장하지 않음)
- 마스터를 분산할 수 없다는 문제가 있음
- 웹 어플리케이션에서는 마스터가 병목이 되어 곤란한 상황이 발생하는 경우가 많지 않음
    - 웹 애플리케이션에서는 대락 90% 이상이 참조계열 쿼리, 쓰기는 상대적으로 훨씬 적음
#### 갱신/쓰기계열을 확장하고자 할 때
- 테이블을 분할해서 테이블 크기를 작게 함
- 처음부터 RDBMS를 사용하지 않는 방법
    - RDB가 갖는 복잡한 통계처리나 범용적인 정렬처리가 필요하지 않는 경우
    - key-value 스토어드 사용

## 13. MYSQL의 스케일아웃과 파티셔닝
### MYSQL의 스케일아웃 전략
- 데이터가 메모리에 올라가는 크기이면 메모리에 올리고, 올라가지 않으면 메모리를 증설
- 인덱스는 제대로 걸자
- 메모리 증설이 불가능하다면 파티셔닝
### 파티녀닝(테이블 분하)에 관한 보충
- 파티셔닝이란 테이블 A와 테이블 B를 서로 다른 서버에 놓아서 분산하는 방법
### 파티셔닝을 전제로 한 설계
- 기본적으로 JOIN 쿼리는 대상이 되는 테이블을 앞으로도 서버 분할하지 않을 것이라고 보장할 때에만 사용
### 파티셔닝의 상반관계
#### 운용이 복잡해진다
- 어디에 어떤 DB가 있는지 파악하는게 매우 힘듬
- 각 서버는 무슨 일을 하고는지 머리속으로 파악해야 하므로 운용이 상당히 복잡
#### 고장률이 높아진다
- 대수가 늘어나는 만큼 고장확률이 높아짐
#### 다중화에 필요한 서버 대수는 몇 대?
- 4대를 1세트로 생각
    - 슬레이브가 3대가 있으면, 1대가 고장 나더라도 남은 2대 중에 1대를 중지하고 새로운 서버로 데이터를 복사해서  
    고장 난 슬레이브 이외의 슬레이브 3대를 정리해서 복구할 수 있음
    - 슬레이블끼리 복사하려면 복사 대상 슬레이브는 멈춤
#### 서버 대수와 고장률
- 분할하면 대수가 한꺼번에 늘어남, 당연히 고장 확률도 올라감
- 메모리를 늘림으로서 분할 대수를 줄일 수 있음
- 분할하더라도 메모리 크기나 여러 비용을 생각해서 선택
