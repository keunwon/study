# 현대 웹 서비스 구축에 필요한 실전 기술

## 1. 작업큐 (Job-Queue) 시스템
### 웹 서비스와 요청
- 웹 서비스에서는 기본적으로 요청이 동기적으로 실행
- 성장하는 웹 서비스에서는 데이터가 서서히 축적되면서 데이터를 추가하고 갱신하는 처리가 점점 무거워 짐
- 작업큐 시스템을 사용함으로써 나중으로 미뤄도 되는 처리를 비동기로 실행할 수 있고 사용 경험도 개선할 수 있음
### 작업큐 시스템 입문
- 웹 애플리케이션의 일부 처리를 가장 간단하게 비동기화하는 방법은 비동기화하고자 하는 처리를 독립된 스크립트로 해서 해당 스크립트를 애플리케이션 내부에서 호출
    - 일시적으로 대량의 비동기 처리를 실행시키려 하면 그 수만큼의 프로세스를 실행시키려고 하기 때문에 이것도 성능상 단점이 생김
    - 서규모 애플리케이션에서만 적용하는게 좋음
- 어느 정도 양이 있는 비동기 처리를 안정적으로 수행하려면 작업큐와 워커를 세트로 한 작업큐 시스템을 사용하는 것이 일반적
- 작업큐 시스템에서는 작업큐에 실행하고자 하는 처리(작업)를 등록
- 워커가 큐에서 작업을 추출해서 실제로 처리
- 일시적으로 대량의 처리가 등록되었을 때 부하를 흡수

## 2. 스토리지 선택
### 증가하는 데이터를 어떻게 저장할까?
#### 적절한 스토리지 선택의 어려움
- 저장하고자 하는 데이터의 특성에 맞는 스토리지를 선택하는 것이 비용과 성능, 안정성의 균형을 높은 차원으로 달성하기 위한 열쇠
### 스토리지 선택의 전제가 되는 조건
- 평균 크기
- 최대 크기
- 신규 추가 빈도
- 갱신빈도
- 삭제빈도
- 참조빈도
### RDBMS
- 표 형식으로 저장하고 대부분은 SQL 언어로 데이터 조작을 수행하는 시스템
- 범용성이 높은 스토리지
#### MYISAM
- DB 프로세스가 비정상 종료하면 테이블이 파손될 가능성이 높다거나 트랜잭션 기능이 없음
- 테이블 락을 사용하여 갱신이 많은 용도로는 성능적으로 불리함
#### InnoDB
- 트랜잭션을 지원
- 복구 기능
- 레코드 락 사용

## 3. 캐시 시스템
### 웹 애플리케이션의 부하와 프록시/캐시 시스템
- 시스템 용량이 부족해졌을 때에는 AP 서버나 DB 서버 증성함으로써 대응할 수 있지만,  
HTTP 레벨의 캐싱을 수행하는 HTTP 가속기를 사용함으로 낮은 비용으로 효과가 높은 대책을 세울 수 있음
- 포워드 프록시와 리버스 프록시 2종류가 있음
    - 포워드 프록시: 클라이언트가 외부 서버에 접속할 때 사에에 두는 프록시
    - 리버스 프록시: 외부 클라이언트가 내부 서버에 접속할 때 사이에 두는 프록시
- 프록시에서는 요청에 대한 캐싱해둠으로써 다음에 같은 요청이 전달됐을 때 캐싱해둔 응답을 반환
#### 리버스 프록시 캐시 서버
- 웹 애플리케이션에서는 리버스 프록시가 많은 서비스에 사용

## 4. 계산 클러스터 (Hadoop)
### 대량 로그 데이터의 병렬처리
- 대규모 웹 서비스를 운영하다 보면 로그 데이터도 대량을 쌓임
- 대량으로 쌓인 로그 데이터의 처리는 이를 한 번에 읽어들이는 것도 어렵고, 통계처리나 분석을 하려고 하면 큰 계산 리소스를 필요
### MapReduce의 계산모델
- MapReduce란 Google이 2004년에 발표한 계산 모델
- MapReduce는 거대한 데이터를 빠르게 병렬로 처리하는 것을 목적, 다수의 계산 노드로 구성된 클러스터와 대량 데이터를 분산해서 저장하기 위한 분산파일시스템
- MapReduce 계산 모델은 Key value 쌍의 리스트를 입력 데이터로 해서 최종 적으로 value의 리스트를 출력
- 계산은 기본적으로 Map단계와 Reduce 단계로 구성
    - Map 단계
        1. 마스터 노드에 입력 데이터를 잘게 분할해서 각 노드로 분산
        2. 각 노드에서는 분할된 입력 데이터를 계산하고, 계산결과를 key, vlaue 쌍으로 구성된 중간 데이터로 출력
        - (k1, v1) -> list(k2, v2);
    - Reduce 단계
        1. Map 단계에서의 출력 데이터를 key별로 정리해서 key와 key에 대응하느 값의 리스트로 재구성
        2. 각각의 key를 각 노드로 분산 (Shuffile Phase 라고 함)
        3. 각 노드에 있는 Key와 key에 대응하는 값의 리스트를 입력 데이터로 해서 각 리스트를 최종적인 출력 데이터로 하는 처리를 수행
        - (k2, list(v2)) -> (k2, list(v3))
- 로그 분석, 검색엔진의 인덱스 생성 등 응용범위는 광범위
- 분산 파일시스템에서는 수 GB 단위의 거대한 파일을 수십 MB 크기로 분할, 다수의 노드에 사전에 데이터를 분산 배치 함,  
그리고 실제로 처리를 실행할 때 가능한 데이터가 로컬에 존재하는 노드에서 처리를 실행
