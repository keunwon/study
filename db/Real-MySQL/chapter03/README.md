# 3. 아키텍처

## 1. MYSQL 아키텍처
### 1.1. MYSQ의 전체 구조
#### MYSQL 엔진
- MYSQL 엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기,  
쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룸
- 성능 향상을 위해 MyISAM의 키 캐시, InnoDB의 버퍼 풀과 같은 보조 저장소 기능이 포함
#### 스토리지 엔진
- MYSQL 엔진은 요청된 SQL 문장을 분석하거 최적화하는 등 DBMS의 두 뇌에 해당하는 처리를 수행,  
실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽이어는 부분은 스토리지 엔진에서 전담
#### 핸들러 API
- MYSQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에서 쓰기 또는 읽기를 요청하는데,  
이러한 요청을 핸들러욫어이라고 하고, 여기서 사용되는 API를 핸들러 API라고 함
- InnoDB 스토리지 엔진 또한 이 핸들러 API를 이용해 MYSQL 엔진과 데이터를 주고 받음
### 1.2. MYSQL 스레딩 구조
- MYSQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동, 크게 포그라운드 스레드와 백그라운드 스레드로 구분
#### 포그라운드 스레드(클라이언트 스레드)
- 포그라운드 스레드는 최소한 MYSQL 서버에 접속된 클라이언트의 수만큼 존재, 주로 클라이언트 사용자가 요청하는 쿼리 문장을 처리
- 클라이언트 사용자가 마치고 커넥션을 종료하면, 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시 (Thread pool)로 되돌아감
- 스레드 캐시의 스레드 개수를 조절하는 옵션은 thread_cache_size
- 포그라운드 스레드는 데이터를 MYSQL의 데이터 버퍼나 캐시로부터 가져오며, 없으면 직접 디스크를 읽어와 처리
- MYISAM 테이블은 디스크 쓰기 작업까지 포라운드 스레드가 처리, InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드로 처리하고, 나머지는 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리
#### 백그라운드 스레드
- InnoDB는 여러 가지 작업이 백그라운드로 처리
- 대표적으로 Insert Buffer or Change Buffer를 병합하는 스레드, 로그를 디스크로 기록하는 스레드, InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드, 데이터를 버퍼로 읽어 들이는 스레드, 기타 여러가지 잠금이나 데드락 모니터링하는 스레드가 있음
- SQL 처리 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터 읽기 작업은 절대 지연될 수 없음
    - 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재
    - MYISAN은 사용자 스레드가 쓰기 작업까지 함께 처리함
    - InnoDB에서는 INSERT, DELETE, UPDATE 쿼리로 데이터 변경되는 경우, 데이터가 디스크의 데이터를 파일로 완전히 저장될 때까지 기다리지 않아도 됌
### 1.3. 메모리 할당 및 사용 구조
- 글로벌 영역과 로컬영역의 차이는 MYSQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 아닌지에 따라 구분
- 글로벌 영역
    - 모든 스레드가 공유
- 로컬 영역
    - 세션 메모리 영역이라고도 표현
    - 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역
        - 커넥션 버퍼, 정렬 버퍼 등
    - 절대 공유되어 사용되지 않는 특징
### 1.4. 쿼리 실행 구조
#### 파서
- 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미
- 문법 오류는 이 과정에서 발견
#### 전처리기
- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
- 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러짐
#### 옵티마이저
- 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 담당
#### 실행엔진
- 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할
#### 핸들러 (스토리지 엔진)
- 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당
### 1.6. 복제 (Replication)
- MYSQL의 복제는 리플리케이션이라고 하는데, 복제는 2대 이상의 MYSQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술
#### 마스터
- MYSQL의 바이너리 로그가 활성화되면 어떤 MYSQL 서버든 마스터가 될 수 있음
- 마스터 장비는 주로 데이터가 생성 및 변경, 삭제되는 주체라고 볼 수 있음
- DML, DDL의 모든 쿼리 문장을 바이너리 로그에 기록
- 슬레이브 서버에서 변경 내역을 요청하면 마스터 장비는 바이너리 로그를 읽어 슬레이브로 넘김
    - 마스터 장비의 프로세스 가운데 binlogdump라는 스레드가 이 일을 전담
    - 만약 10개의 슬레이브가 연결돼 있다면 binlogdump 스레드가 10개가 표시 
#### 슬레이브
- 마스터 장비의 정보를 가지고 있는 경우 슬레이브가 된다
- 읽기전용으로 설정
- 마스터 서버에 접속해 변경 내용을 요청하고, 받아 온 내역을 릴레이 로그에 기록
- 릴레이 로그에 기록된 내역을 재실행 함으로써 슬레이브의 데이터를 마스터와 동일한 상태로 유지
#### 복제를 사용할 경우 주로 잘못 생각하거나 간과하는 부분
- 슬레이브는 하나의 마스터만 설정 가능
    - 하나의 마스터에 N개의 슬레이브가 일반적인 형태이며 그 밖에 링형태나 트리 형태의 구성도 가능
    - 마스터-마스터 형태의 복제도 사용
- 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정
    - 슬레이브는 읽기 전용으로 설정하는 것이 일반적
- 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합
    - 슬레이브 서버용 장비는 마스터 서버용 장비보다 한 단계 낮은 장비로 선택하려고 할 때가 있음
    - 마스터 서버에서 수많은 동시 사용자가 실행한 데이터 변경 문장이 슬레이브 서버에서는에서는 하나의 스레드로 모두 처리돼야 함
    - 변경이 매우 잦은 MYSQL 서버일수록 마스터 서버의 사양보다 슬레이브 서버의 사양이 더 좋아야 마스터에서 동시에 여러 개의 스레드로 실행된 쿼리가 슬레이브에서 지연되지 않고 하나의 스레드로 처리 될 수 있음
    - 보통은 마스터, 슬레이브 사양을 동일하게 사용 함
- 복제가 불필요한 경우에는 바이너리 로그 중지
    - 바이너리 로그를 안정적으로 기록하기 위해 갭 락을 유지하고, 매번 트랜잭션이 커밋될 때마다 데이터를 변경시킨 쿼리 문장을 바이너리 로그에 기록해야 한다
- 바이너리 로그와 트랜잭션 격리 수준 (Isolation level)
    - 바이러리 로그 파일은 어떤 내용이 기록되냐에 따라 여러 포멧 방식이 존재
        - STATEMENT:  바이너리 로그 파일에 마스터에서 실행되는 쿼리 문장을 기록
        - ROW: 마스터에 실행된 쿼리에 의해 변경된 레코드 값을 기록하는 방식
### 1.7. 쿼리 캐시
- 쿼리 캐시는 타 DBMS에는 없는 MYSQL의 독특한 기능 중 하나, 적절히 설정만 해두면 상당한 성능 향상 효과를 얻을 수 있음
- 동일한 쿼리 요청이 왔을 때 간단하게 쿼리 캐시에서 찾아서 바로 겨로가를 내려 줄 수 있기 때문에 기대 이상의 효과를 거둘 수 있음
- 쿼리 결과를 메모리에 캐시 두는 기능
#### 요청된 쿼리 문장이 쿼리 캐시에 존재하는가?
- 쿼리 캐시는 앞단에 위치하며, 캐시된 결과를 찾기 위해 쿼리 문장을 분석해서 복잡한 비교 과정을 거치는 것이 아님 (간단하고 빠르게 진행)
#### 해당 사용자가 그 결과를 볼 수 있는 권한을 가지고 있는가?
- 사용자가 해당 테이블에 읽기 권한이 없다면 쿼리 캐시의 결과를 보여주면 안됌
#### 트랜잭션 내에서 실행된 쿼리인 경우 가시 범위 내에 있는 결과인가?
- InnoDB의 모든 트랜잭션은 각 트랜잭션 ID를 가짐
- 트랜잭션 시작 시점을 기준으로 순차적으로 증가하는 6바이트 숫자 값이어서 트랜잭션 ID 값을 비교해 보면 어느 쪽이 먼저 시작된 트랜잭션인지 구분할 수 있음
- 자신의 ID보다 ID값이 큰 트랜잭션에서 변경한 작업 내역이나 쿼리 결과는 참조 할수 없음 (트랜잭션의 가시 범위)
#### CURRENT_DATE(), SYSDATE(), RAND() 등과 호출 시점에 따라 결과가 달라지는 요소가 있는가?
- 쿼리 시점에 따라 결과가 달라질 가능성이 있는 쿼리를 사용하지 않는 편이 쿼리 캐시의 효율을 높이는데 도움
#### 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치치 않는가?
- 프리페어 스테이트먼트의 경우에는 쿼리 문장 자체에 변수가 '?'가 사용되기 때문에 쿼리문장 자체로 쿼리 캐시를 찾을 수 없음
    - 서버 프리페어 스테이트먼트를 사용하여 해결
#### 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?
- 쿼리에 캐시가 크면 테이블에 새로운 레코드를 INSERT하면 MYSQL 서버는 쿼리 캐시에 채워져 있는 내용을 제거해야 함
#### 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크기 않은가?
- 특정한 크기 미만의 쿼리 결과만 캐시하도록 설정 (query_cache_limit)
- GROUP BY, DISTINCT, COUNT와 같은 집합 함수의 결과가 쿼리 캐스를 사용하기에 아주 적합
#### 그 외
- Qcache_select: 쿼리 캐시가 얼마나 효율적으로 사용되고 있는지 조사해봄
- Qcache_hits: 쿼리 캐시로 처리된 SELECT 쿼리의 수를 의미
- Com_select: 쿼리 캐시에서 결과를 찾지 못해서 MYSQL 서버가 쿼리를 실행한 횟수를 의미
- 쿼리의 히트율이 20%이상이면 일반적으로 쿼리 캐시를 사용하는 것이 좋음

## 2. InnoDB 스토리지 엔진 아키텍처
- InnoDB는 MYSQL에서 사용할 수 있는 스토리지 엔진 중에서 거의 유일하게 레코드 기반 잠금을 제공,  
높은 동시성 처리가 가능하고 또한 안정적
### 2.1. InnoDB 스토리지 엔진의 특성
#### 프라이머리 키에 의한 클러스터링
- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장, 프라이머리 순서대로 디스크에 저장
- 프라이머리 키에 의한 레인지 스캔은 상당히 빠르게 처리
#### 잠금이 필요 없는 일관된 읽기
- InnoDB 스토리지 엔진은 MVCC라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행
- 락을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 락을 기다리지도 않음
#### 외래키 지원
- InnoDB에서 외래키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고 그로인해 데드락이 발생할 때가 많음
#### 자동 데드락 감지
- InnoDB는 그래프 기반의 데드락 체크 방식을 사용하기 때문에 데드락이 발생함과 동시에 바로 감지
- 감지된 데드락은 ROLLBACK을 했을 때 복구 작업이 가장 작은 트랜잭션을 강제 종료
#### 자동화된 장애 복구
- InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재
### 2.2. InnoDB 버퍼 풀
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 함
- InnoDB의 버퍼 풀 크기를 설정하는 파라미터(innodb_buffer_pool_size)는 신중하게 설정 (전체 메모리에 50 ~ 80%)
- 더티 페이지: 아직 드스크에 기록되지 않은 변경된 데이터를 가지고 페이지
### 2.3. 언두(Undo) 로그
- 언두 영역은 UPDATE 문장이나 DELETE와 같은 문장으로 데이터를 변경했을 때 변경되지 전의 데이터를 보관하는 곳
- 트랜잭션의 롤백 대비용
- 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공하는데 사용
### 2.4. 인서트 버퍼(Insert Buffer)
- InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행, 그렇지 않으면 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 사용자에게 반환하는 형태로 성능을 향상
- 중복 체크해야 하는 유니크 인덱스는 인서트 버퍼를 사용할 수 없음
- 인서트 버퍼에 임시로 저장돼 있는 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합 (인서트 버퍼 머지 스레드)
- MYSQL 5.5 이후 CHAGE_BUFFER를 이용하여 DELETE도 임시 버퍼 사용 가능
### 2.5. 리두(Redo) 로그 및 로그 버퍼
- 리두 파일: DBMS 변경 이력을 순차적으로 디스크에 기록하는 로그 파일
- MYSQL 서버 자체가 사용하는 로그 파일이므로 사람이 읽을 수 없음
- 리두 로그 덕분에 DBMS 데이터는 버퍼링을 통해 한꺼번에 디스크에 변경된 내용을 처리할 수 있음
- 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼
### 2.6. MVCC(Multi Version Concurrency Control)
- 잠금을 사용하지 않는 일관된 읽기를 제공
- 언두 로그를 이용해 이 기능을 구현
- 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제
### 2.7. 잠금 없는 일관된 읽기(Non-locking consistent read)
- InnoDB에서 SERIALIZABLE이 아닌 격리 수준에서는 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행
### 2.8. InnoDB와 MyISAM 스토리지 엔진 비교
- MYISAM은 운영체제의 캐시에 의존, InnoDB 스토리지 엔진은 자체적인 버퍼 풀을 가지고 있어 업무에 맞는 캐싱이나 버퍼링 수행
### 2.9. InnoDB와 MEMORY(HEAP) 스토리지 엔진 비교
- MEMORY 스토리지 엔진의 가장 큰 장점은 데이터와 인덱스를 모두 메모리에 저장하기 때문에 저장 작업이나 읽기 작업이 매우 빠름
- MEMORY 스토리지 엔진을 사용는 테이블은 레코드 수준의 잠금이 아니라 테이블 수준의 잠금을 이용

## 4. MEMORY 스토리지 엔진 아키텍처
- MEMORY 스토리지 엔진은 HEAP 스토리지 엔진이라고 함
- 데이터의 크기가 작고 아주 빠른 처리가 필요한 경우에 적합
### 4.1. 주의 사항
- 테이블의 최대크기
    - max_heap_talbe_size 파라미터로 크기 지정 (동적으로 변경 가능한 변수)
- 고정 길이 컬럼만 지원
- BLOB or TEXT 같은 타입은 지원하지 않음
- MEMORY 테이블은 기본적으로 해시 인덱스 사용
### 4.2. MEMORY 스토리지 엔진의 용도
- MEMORY 테이블은 MYSQL 엔진이 쿼리를 처리하는 과정에서 임시로 생성되는 임시 테이블 용도로 더 자주 사용

## 5. NDB 클러스터 스토리지 엔진
- NDB 클러스터는 데이터의 분산이나 그로 인한 성능 향상보다는 가용성에 집중된 스토리 엔진
### 5.1. NDB 클러스터의 특성
#### 무공유(Shared-nothing) 클러스터링
- NDB 클러스터는 클러스터 그룹 내의 모든 노드가 아무것도 공유하지 않는 무공유 아키텍처로 구현
- NDB 클러스터는 데이터를 저장하는 스토리지도 분산되어 관리되기 때문에 하나의 데이터 저장소가 작동을 멈추더라도 서비스에 영향을 미치지 않음
- NDB 클러스터는 관리노드, 데이터 노드, 그리고 SQL 노드로 구성 (3가지 종류의 노드 모두 이중화해서 구현할 수 있음)
#### 메모리 기반의 스토리지 엔진
- NDB 클러스터는 메모리를 기본 데이터 스토리지로 사용
- 노드 간의 빠른 데이터 동기화를 위해 메모리를 사용
- NDB 클러스터는 데이터 스토리지까지 분산하기 때문에 각 노드의 물리적 메모리를 모두 합친 것이 실제 저장 가능한 최대 용량
- NDB 클러스터는 주기적으로 메모리의 모든 데이터를 디스크로 내려 쓰고 있으며, InnoDB 스토리지 엔진과 같이 트랜잭션 로그를 디스크에 기록하는 식으로 작동
#### 자동화된 페일 오버(Fail-over)
- NDB 클러스터는 모든 구성 노드가 서로의 상태를 계속 체크하고 있기 때문에 특정 노드에 문제가 발생해도 다른 사용 가능한 노드가 그 역할을 이어받는 형태로 페일 오버가 가능
#### 분산된 데이터 저장소간의 동기 방식(Sync) 복제
- NDB 클러스터에서 데이터 저장소는 분산되어 관리되는데, 각 데이터 저장소는 전체 데이터를 N등분해서 자신이 전담하는 파티션과 백업으로 보조 파티션을 구성함
- 분산된 서로의 데이터를 동기화해야 하는데 동기방식으로 서로의 데이터로 전달
- 동기 방식이란 클러스터의 모든 데이터 노드에 변경된 데이터가 전달되어 완전히 저장되고 나서야 트랜잭션이 완료될 수 있음
#### 온라인 스키마 변경
- NDB 클러스터에서는 테이블에 컬럼이나 인덱스를 추가하면서 동시에 INSERT나 UPDATE와 같은 DML 쿼리를 처리 가능
#### 네트워크 DB
- NDB 클러스터는 내부적으로 데이터를 저장하고 읽기 위해 네트워크를 기반으로 작동

### 5.2. NDB 클러스터의 아키텍처
#### NDB 클러스터 노드의 종류
- 관리노드, 데이터 노드, SQL 노드로 구성 (모두 이중화될 수 있도록 구현)
    - 관리 노드
        - NDB 클러스터가 정상 상태로 서비스 되는 도중에는 거의 하는 일이 없음
        - 관리노드는 NDB 클러스터의 전체적인 구조에 대한 정보를 다른 노드에게 전파하거나 각 노드의 장애 상황을 전파하는 역학을 담당
        - NDB 클러스터가 처음 시작하거나 새로운 노드를 추가/제거할 때 반드시 필요
        - 각 노드에 대한 IP 주소나 포트 번호화 같은 정보와 각 노드의 주요 환경 설정 값은 관리 노드에 있음
    - 데이터 노드
        - NDB 클러스터의 핵심으로, 클러스터에 대한 전반적인 작업을 수행
        - 데이터를 저장하는 스토리지를 관리하고 SQL 노드에서 오는 데이터 조작 요청을 모두 처리
        - 데이터 노드는 내부적으로 데이터의 클러스터링을 위해 데이터를 쪼개고(파티션) 해당 데이터를 복사해서 백업해둠
        - 수직 파티션되어 각 데이터 노드에 분산 (프라이 머리 키값에 의해 자동으로 파티션)
    - SQL 노드
        - MYSQL 서버를 이용해 NDB 클러스터에 접속하는 경우를 SQL 노드
        - 데이터를 읽고 쓰기 위한 클라이언트 부분은 SQL 노드 or API 노드 중에 선택
        - 요청된 SQL 문장을 분석해 NDB 클러스터가 이해할 수 있는 형태의 명령으로 재조립해서 데이터 노드로 요청, 데이터 노드로부터의 결과를 MYSQL 포멧으로 변환해서 반환함
#### 데이터 노드 간의 파티션 관리
- 하나의 클러스터에 데이터 노드는 2개 이상 존재, 각 데이터 노드는 클러스터 전체 데이터의 일부만 가짐
- 각 데이터 노드는 2개의 파티션으로 구성
    - 원본 파티션을 프라이머리 파티션, 백업된 파티션을 세컨트리 파티션이라고 함
    - NDB 클러스터는 데이터 노드가 손상되어도 서비스가 가능하도록 클러스터 데이터를 파티션해서 각 파티션을 최소 2개 이상의 데이터 노드에 복제
- 데이터 노드는 부여된 아이디 값의순번대로 노드 그룹이 결정 (하나의 노드 그룹에 2개의 데이터 노드가 포함)
### 5.3. 클러스터 간의 복제 구성
- NDB 클러스터에서는 2개 이상의 MYSQL 서버가 동시에 쓰기와 읽기용 쿼리를 처리
- NDB 클러스터의 데이터 노드는 자기 자신에게 발생한 데이터 변경에 대한 내용을 MYSQL 서버로 피드백을 줌
    - 피드백 받은 MYSQL 서버에서는 피드백 내용을 바이너리 로그에 기록 (변경 내용이 바이너리 로그에 기록)
### 5.4. NDB 클러스터의 성능
- SQL노드의 개수가 늘어날수록 성능이 선형적으로 증가
- 적은 SQL 노드에 너무 많은 요청이 발생하는 경우 SQL 노드가 제대로 처리하지 못하는 동시성 문제가 있음
### 5.5. NDB 클러스터의 네트워크 영향
- 네트워크 전송속도가 쿼리 성능에 상당한 영향을 미침
### 5.6. NDB 클러스터의 용도
- 세션 전용 데이터 베이스로 상당히 널리 사용
- 회원의 로그인 정보(세션 정보)는 회원의 수에 따라 발생 가능한 최대 건수를 예측할 수 있으므로 필요한 저장 공간의 양이 고정적

## 8. MYSQL 로그 파일
### 8.1. 에러 로그 파일
- log_error 라는 이름의 파라미터에 정의된 경로에 있는 파일, '.err' 확장자가 붙은 파일
#### 에러 메시지 주요 내용
- MYSQL이 시작하는 과정과 관련된 정보성 및 에러 메시지
- 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나느 InnoDB의 트랜잭션 복구 메시지
- 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
- 비정상적으로 종료된 커넥션 메시지
- InnoDB의 모니터링 명령이나 상태조회 명령의 결과 메시지
- MySQL의 종료 메시지
### 8.2. 제너럴 쿼리 로그 파일 (General log)
- 서버에서 실행되는 쿼리로 어떤 것들이 있는지 로그 파일로 기록
- 시간 단위로 실행됐던 쿼리의 내용이 모두 기록
- general_log_file 파라미터에 정의된 경로에 있는 파일
- MYSQL 5.1 이상에서는 쿼리 로그를 파일이 아닌 테이블에 저장하도록 설정
    - log_output 파라미터 결정
### 8.3. 슬로우 쿼리 로그
- long_query_time 파라미터에 초 단위를 초과하면 슬로우 쿼리로 간주하여 로그에 기록
### 8.4. 바이너리 로그와 릴레이 로그
- 바이너리 로그에는 순수한 SELECT 문장과 같이 데이터의 구조나 내용을 변경하지 않는 쿼리는 기록되지 않음
- 바이너리 파일은 이진 파일로 구성
    - 이진 파일을 텍스트 형태로 바꾸려면 mysqlbinlog 프로그램 사용
    - mysqlbinlog에 날짜와 시간을 정해서 바이너리 로그의 내용을 SQL 텍스트로 읽을 수 있음
