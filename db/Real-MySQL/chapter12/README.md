# 12. 쿼리 종류별 잠금
- MYSQL에서 잠금과 관련된 문제는 까다롭다
    - MYSQL에서 복제를 위한 바이너리 로그를 처리하기 위해 다른 DBMS에는 존재하지 않는 갭 락(Gap lock)이나 넥스트 키 락(Net key lock)을 사용
- MYISAM 스토리지 엔진은 트랜잭션 자체를 지원하지 않고 테이블 단위로 잠금을 사용하므로 SQL의 처리 성능은 떨러어지지만 잠금 방식이 복잡하지는 않음

## 1. InnoDB의 기본 잠금 방식
### 1.1. SELECT
- REPEATABLE-READ 이하의 트랜잭션 격리 수준에서는 InnoDB 테이블에 대한 SELECT 쿼리는 기본적으로 아무런 잠금을 사용하지 않음, 또한 이미 잠긴 레코드를 읽는 것도 아무런 제약이 없음
- REPEABLE-READ 보다 더 높은 격리 수준인 SERIALIZABLE 격리 수준에서는 모든 SELECT 쿼리에 자동적으로 'LOCK IN SHARE MODE'가 덧붙여져서 실행되는 효과를 냄 (모든 SELECT 쿼리는 읽기 잠금을 걸고 레코드를 읽음)
    - SERIALIZABLE 격리 수준에서는 MYSQL 서버 처리 성능이 떨어짐
- SELECT 쿼리로 읽은 레코드를 잠그는 방법은 읽기 모드와 쓰기 모드 잠금으로 두가지가 있음 (LOCK IN SHARE MODE, FOR UPDATE)
- LOCK IN SHARE MODE
    - 읽기 잠금만 걸기 때문에 잠금을 획득한 트랜잭션에서도 변경하려면 쓰기 잠금을 다시 획득해야함
    - 쓰기 잠금을 획득하기 위해 다른 트랜잭션이 완료 될 때까지 기다려야 할 수 있음 (데드 락)
- FOR UPDATE
    - SELECT 쿼리 문장으로 읽은 레코드를 쓰기 모드로 잠그는데, 이는 다른 트랜잭션에 대해 영향도가 크기 때문에 반드시 읽은 레코드를 변경해야 할 때만 사용하는 것이 좋음
### 1.2. INSERT, UPDATE, DELETE
- INSERT, UPDATE, DELETE 쿼리는 모두 기본적으로 쓰기 잠금을 사용하며, 필요 시에는 읽기 잠금을 사용할 수도 있음
- UPDATE, DELETE 문장을 실행할 때 SQL 문장이 조건에 일치하는 레코드를 찾기 위해 참조(스캔)하는 인덱스의 모든 레코드에 잠금을 검
    - 참조(스캔)한 레코드에 잠금을 걸었다는 것은 WHERE 조건에 일치하지 않는 레코드도 잠금의 대상이 될 수 잇음을 의미
- MYSQL 쿼리에 사용된 잠금 중에 인덱스를 적절히 사용할 수 있는 조건만 스토리지 엔진으로 전달
    - 레코드를 찾을 때 조건을 전부 사용하지 않을 수도 있음
- InnoDB 스토리지 엔진은 WHERE절에 포함된 모든 조건이 아니라 인덱스를 사용할 수 있는 조건만 MYSQL 엔진으로 전달받기 때문에 인덱스를 사용할 수 있는 조건만 일치하면 모두 잠금 (InnoDB에서는 인덱스 기반으로 레코드를 잠금)
- 쿼리를 실행하기 위해서 레코드에 잠금을 거는 주체는 InnoDB 스토리지 엔진이고, 업데이트 할 레코드를 최종 결정하는 주체는 MYSQL 엔진
- InnoDB에서 UPDATE, DELETE 문장이 실행될 때는 항상 잠금 대상 레코드가 변경 레코드 보다 범위가 크거나 같음
- 인덱스를 사용하지 않는 UPDATE, DELETE
    - InnoDB에서는 테이블의 모든 레코드에 잠금을 걸고, 조건에 일치하는 값을 변경
    - 동시성이 떨어짐
- 복제를 사용하지 않는 MYSQL 서버는 바이너리 로그가 필요하지 않을 수도 있음
    - InnoDB의 격리 수준을 READ-COMMITED에서는 인덱스와 관계없이 실제 변경되는 레코드만 잠금을 검

## 2. SQL 문자별로 사용하는 잠금
### 2.1. SELECT 쿼리의 잠금
#### SELECT ... FROM ...
- InnoDB 테이블에서 기본 형태의 SELECT 쿼리는 별도의 잠금을 사용하지 않음
- 만약 다른 트랜잭션에 의해 변경되거나 삭제 중이라면 InnoDB에서 관리하는 '언두 로그'를 이용해 레코드를 읽음
- SELECT만 수행할 때는 다른 트랜잭션의 형향을 받지 않고, 별도의 레코드를 읽기 위해 대기하지 않음
- DDL 문장으로 테이블 구조가 변경되어도 SELECT ... FROM ... 처리 가능
- 만약 트랜잭션 격리 수준이 SERIALZABLE 이면 SELECT 쿼리에 LOCK IN SHARE MODE 옵션이 자동으로 덧붙여져서 실행 (읽기 잠금 획득이 필요) 
#### SELECT ... FROM ... LOCK IN SHARE MODE
- LOCK IN SHARE MODE 옵션이 사용된 SELECT 쿼리 문장은, WHERE 절에 일치하는 레코드 뿐 아니라 검색을 위해 접근한 모든 레코드에 공유 넥스트 키락이 필요
- 다른 트랜잭션이 쓰기 잠금이 걸렸으면, 잠금이 해제될 때까지 기다려야 함 (다른 트랜잭션이 읽기 잠금이 걸려있어도 읽기 잠금끼리는 상호 호환이 되므로 별도의 대기 없이 읽기 잠금을 획득 할 수 있음)
- COMMIT, ROLLBACK 명령으로 트랜잭션이 종료되면 잠금을 해제
#### SELECT ... FROM ... FOR UPDATE
- FOR UPDATE 옵션이 사용된 SELECT 쿼리 문장도 WHERE 조건절에 일치하는 레코드를 검색하기 위해 접근한 모든 레코드에 대해 베타적 넥스트 키락을 검
- 다른 트랜잭션이 의래 읽기, 쓰기 잠금을 사용하고 있다면 잠금이 해제될 때까지 대기
### 2.2. INSERT 쿼리의 잠금
#### INSERT ...
- INSERT 문장은 베타적 레코드 잠금, 인서트 인텐션 락(INSERT INTENTION LOCK)이라는 색다른 잠금 방식도 사용
- 프라이머리 키나 유니크 키가 존재하면 중복 체크를 위해 공유 레코드 잠금을 먼저 획득해야 함
- 인서트 인텐션 락
    - 모든 INSERT 쿼리에는 인서트 인텐션 락을 획득한 후 INSERT 실행
    - INSERT된 레코드에 대해서는 베타적 레코드 잠금을 자동으로 획득
    - 인서트 인텐션 락은 갭락의 일종
        - 인서트 인텐션 락끼리 서로 호환
        - 여러 트랜잭션이 동시에 인서트 인텐션 락을 획득할 수 있음
        - 이미 다른 트랜젝션이 레코드나 갭 락을 걸고 있다면 인서트 인텐션 락을 걸기 위해 기다려야 함
- InnoDB에서 인스트 인텐션 락을 사용하는 이유
    - InnoDB의 갭 락으로 인한 동시성 감소를 최소화하기 위해서
#### 인서트 인텐션 락이 없다면
- 각각의 트랜잭션의 작업이 끝나야 다음 작업을 할 수 있음 (동시성 처리가 어려움)
#### 인서트 인텐션 락을 사용하면
- 모든 트랜젝션에서 배타적 갭 락을 사용하지 않고 인서트 인텐션 락을 사용
- 서로 충돌하는 값을 INSERT하지 않는 이상, 동일 간격에 대해 서로 간섭을 받지 않고 동시에 INSERT가 처리
- INSERT 시 프라이머리 키나 유니크 키와 같이 중복이 허용되지 않는 컬럼은 공유 레코드 락을 얻어야 함
    - 이 과정으로 인해 데드락이 발생할 수도 있음
    - 베타적 잠금
        - 해당 트랜잭션에서 그 레코드나 간격을 변경하기 위해 획득해야 하는 잠금
        - 내가 쓰기를 하는 동안 남들이 쓰지 못하게 하는것
    - 공유 잠금
        - 레코드나 간격을 읽을 때 다른 트랜잭션이 변경하지 못하게 하는 용도의 잠금
        - 내가 읽는 동안 남들이 내가 읽고 있는 데이터를 변경하거나 삭제하지 못하게 막는 장치
    - INSERT를 전제로 읽기 작업 중에 다른 트랜잭션에서 레코드를 변경하거나 삭제하면 일관성이 깨지기 때문에 공유 잠금을 사용
#### INSERT INTO ... ON DUPLICATE KEY UPDATE ...
- INSERT하려는 레코드에 중복 키값이 이미 있는지 판단하기 위해 공유 잠금을 걸어야 함
- 레코드가 존재하면 배타적 잠금을 걸고 업데이트 수행
- 레코드가 존해하지 않으면 일반적인 INSERT 문장과 같이 INSERT INTENTION 락을 걸고 INSERT 실행, 새로운 INSERT된 레코드에 대해서 배타적 잠금을 획득
#### REPLACE
- REPLACE 문장에서는 중복된 키 값이 판단하기 위해 공유 잠금을 걸어야 함
- 중복된 레코드가 존재하면 배타적 잠금을 걸고 레코드를 삭제
#### INSERT INTO tb_new ... SELECT ... FROM tb_old
- INSERT되는 레코드에 대해 배타적 레코드에 대해 배타적 레코드 락을 획득해야 함
- tb_old 테이블의 대상 레코드에 공유 넥스트 키락을 설정
- 만약 tb_old 테이블의 레코드가 실행 중 변경되면 복제 마스터의 tb_new 테이블과 복제 슬레이브의 tb_new 테이블의 레코드 건수가 설로 달라질 수도 있음
#### REPLACE INTO tb_new ... SELECT ... FROM tb_old ...
- tb_old 테이블에는 공유 잠금이 걸림, tb_new 테이블의 레코드는 배타적 레코드 락이 걸림
### 2.3. UPDATE 쿼리의 잠금
#### UPDATE ... WHERE ...
- WHERE 조건에 일치하는 레코드를 찾기 위해서 참조(스캔)하는 모든 레코드에 배타적 넥스트 키락을 검
    - 간격까지 잠금는 이유는 팬텀 레코드 발생을 막기 위해서
#### UPDATE tb_test1 a, test_test2 b on ... set a.column = b.column
- JOIN UPDATE 문장에서는 여러 개의 테이블이 동시에 사용
- 최종적으로 UPDATE되는 컬럼이 포함된 모든 테이블의 레코드에서는 배타적 넥스트 키 락이 걸리고, 단순 참조용으로는 공유 넥스트 키락이 설정
### 2.4. DELETE 쿼리의 잠금
#### DELETE FROM ... WHERE ...
- WHERE 조건에 일치하는 레코드를 찾기 위해 참조(스캔)한 모든 레코들에 대해 배타적 넥스트 키 락을 검
#### DELETE a FROM tb_test1 a, tb_test b ...
- 최종적으로 DELETE되는 레코드가 포함된 모든 테이블의 레코드에는 배타적 넥스트 키 락이 걸리고, 단순 참조용으로만 사용되는 테이블에는 공유 넥스트 키 락이 설정
### 2.5. DDL 문장의 잠금
#### CREATE TABLE tb_new ... SELECT ... FROM tb_old ...
- 읽어 오는 테이블인 tb_old 테이블에는 공유 잠금, tb_new 테이블에 INSERT되는 레코드는 배타적 레코드 락이 설정
#### RENAME TABLE tb_test to tb_backup, tb_swap to tb_test, ...
- RENAME TABLE 절에 명시된 모든 테이블에 대해 네임 락(Name lock)을 검
- 네임 락은 테이블 수준의 잠금이며 DDL 문장이라서 작업이 완료되면 자동으로 COMMIT되고 즉지 잠금을 해제
- 테이블의 이름을 변경하는 동안 테이블의 레코드를 읽거나 쓰는 트랜잭션은 모두 대기

## 3. InnoDB에서 데드락 만들기
- InnoDB에서 대부분의 데드락은 공유 잠금을 가진 상태에서 배타적 잠금을 얻으려고 하는 잠금 상황에서 자주 발생
- 하나의 기능이 동시에 병렬로 실행되면서 서로 간섭을 일으키는 경우도 많음
### 3.1. 패턴 1(상호 거래 관련)
- 포인트 차감과 증가 순서가아 아니라 테이블의 프라이머리 키 값을 기준으로 처리해주는게 좋음
### 3.2. 패턴 2(유니크 인덱스 관련)
#### 데드락 과정
1. 트랜잭선 1번이 배타적 잠금을 가짐
2. 트랜잭션 2, 3번은 공유 레코드 잠금을 획득하기 위해 대기
3. 트랜잭선 1번이 ROLLBACK, 배타적 잠금 해제
4. 트랜잭션 2, 3번은 배타적 잠금을 걸려고 함
    - 트랜잭서 2, 3번이 각각 공유 잠금을 가지고 있음 (공유 잠금은 상호 호환)
    - 서로의 공유 잠금으로 인해 배타적 잠금을 걸지 못하고 서로 대기
5. 데드락 발생
- 'show engine innodb status' 명령어를 이용하여 InnoDB 스토리지 엔진의 여러 가지 상태 정보를 확인
    - 내용 위쪽에 가장 최근에 발생했던 데락 정보가 나옴
### 3.3. 패턴 3(외래키 관련)
- FOREIGN KEY로 인한 데드락은 INSERT와 UPDATE의 순서를 반대로 실행해주면 해결
### 3.4. 패턴 4(서로 다른 인덱스를 통한 잠금)
- 이런 패턴의 데드락은 발생 빈도가 낮지만 각 트랜잭션에서 UPDATE 쿼리 하나씩만 실행하는 과정 중에도 데드락이 발생할 수 있음을 확인할 수 있음
- 단일 레코드 UPDATE 문장이라더라도 InnoDB 내부적으로는 절대 단일 작업이 아님
- 데드락이 발생하면 그 데드락을 해결할 수 있는 처리 내용을 넣으면 됌
