# 4. 트랜잭션과 잠금

## 1. 트랜잭션
### 1.1. MYSQL에서의 트랜잭션
- 트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두개 이상의 쿼리가 있는 관계없이 작업 셋 자체가 100% 적용을 보장(COMMIT or ROLLBACK)
- 부분 업데이트 방지
### 1.2. 주의 사항
- 트랜잭션의 범위를 최소화
- 각 단위의 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어듬

## 2. MYSQL 엔진의 잠금
- MYSQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MYSQL 엔진 레벨로 나눠볼 수 있음
- MYSQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치게 되지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않음
- MYSQL 엔진에서는 테이블 데이터 동기화를 위한 테이블 락, 유저 락, 네임락 제공
### 2.1. 글로벌 락
- FLUSH TABLES WITH READ LOCK 명령으로만 획득
- 가장 범위가 큼
- 다른 세션에서 SELECT 제외한 대부분의 DDL, DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남음
- mysqldump로 일괄 백업을 받아야 할 때는 글로벌 락을 사용
### 2.2. 테이블 락(talble lock)
- 개발 테이블 단위로 설정되는 잠금
- LOCK TABLES table_name [READ | WRITE] 명령으로 특정 테이블의 락을 획득
- 테이블 락은 MYISAM, InnoDB 스토리 엔진을 사용하는 테이블도 동일하게 설정
- UNLOCK TABLES 명령으로 잠금을 반납
- 묵시적인 테이블 락은 MYISAM, MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
- InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공
### 2.3. 유저 락(user lock)
- GET_LOCK() 이용해 임의로 락을 설정
- 사용자가 지정한 문자열에 대해 락을 획득/반납
### 2.4. 네임 락
- 데이터베이스의 객체(테이블, 뷰)의 이름을 변경하는 경우 획득하는 잠금

## 3. MYISAM과 MEMORY 스토리지 엔진의 잠금
- MYISAM, MEMORY 스토리지 엔진은 자체적인 잠금을 가지지 않고 MYSQL 엔진에서 제공하는 테이블 락을 그대로 사용
### 3.1. 잠금 획득
- 읽기 잠금: 테이블에 쓰기 잠금이 걸려 있지 않으면 바로 읽기 잠금을 획득하고 읽기 작업을 시작
- 쓰기 잠금: 테이블에 아무런 잠금이 걸려 있지 않아야만 쓰기 잠금을 획득할 수 있고, 그렇지 않으면 잠금이 해제될 때까지 대기
### 3.2. 잠금 튜닝
- Table_locks_immediate는 잠금이 풀리기를 기다리지 않고 잠금을 획득한 횟수
- Table_locks_waited는 다른 자금이 이미 해당 테이블을 사용하고 있어서 기다려야 했던 횟수를 누적해서 저장
### 3.3. 테이블 수준의 잠금 확인 및 해제
- show open tables from table_name 을 이용하여 테이블 잠금 여부를 보여줌
- kill query 클라이언트_id 명령으로 클라이언트가 실행하고 있는 쿼리만 종료
- kill 클라이언트_id 명령으로 클라이언트 커넥션을 종료

## 4. InnoDB 스토리지 엔진의 잠금
- 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재
- MYISAM 보다 훨씬 뛰어난 동시성 처리를 제공
- INFORMATION_SCHEMA라는 데이터베이스에 존재하는 INNODB_TXR, INNODB_LOCKS, INNODB_LOCK_WAITS 라는 테이블을 조인해서 조회하면 현재 어떤 트랜잭션이 어떤 잠금을 대기하고 있고 해당 잠금은 어느 트랜잭션이 가지고 있는지 확인할 수 있음
### 4.1. InnoDB의 잠금 방식
#### 비관적 잠금
- 현재 트랙잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식
#### 낙관적 잠금
- 각 트랜잭션이 같은 레코드를 변경할 가능성은 상당히 희박할 것이라고 가정
- 잠금 충돌이 있었는지 확인해 문제가 있었다면 ROLLBACK처리하는 방식
### 4.2. InnoDB의 잠금 종류
#### 레코드 락 (Record lock)
- 레코드 자체만을 잠그는 것을 레코드 락
- 레코드 자체가 아니라 인덱스의 레코드를 잠금
- 대부분의 보조 인덱스를 이용한 변경 작업은 넥스트 키락, 갭락을 사용하지만, 프라이머리 키 또는 유니크 키 인덱스에 의한 변경 작업은 갭 락을 사용하지 않고 레코드 락만 사용
#### 갭 락 (Gap lock)
- 갭 락은 레코드를 잠그는 것이 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠금
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어
#### 넥스트 키 락(Net key lock)
- 넥스트 키 락 = 레코드 락 + 갭락 합친 락
- innodb_locks_unsafe_for_binlog 를 비활성화되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸림
- InnoDB의 갭락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에 실행될 때 마스터에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 목적
- 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생
#### 자동 증가 락(Auto increment lock)
- AUTO_INCREMENT 컬럼이 사용된 테이블에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가한 일련번호 값을 가져야 함
- AUTO_INCREMNT 락이라고 하는 테이블 수준의 잠금을 사용
### 4.3. 인덱스와 잠금
- InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠끄는 방식으로 처리
- 인덱스가 없는 경우 테이블을 풀 스캔함 (이 과정에서 모든 레코드를 잠금)
### 4.4. 트랜잭션 격리 수준과 잠금
- 레코드의 자금 현상은 InnoDB의 넥스트 키락 때문에 발생
- 넥스트 키 락을 필요하게 만드는 주 원인은 복제를 위한 바이로너리 로그 때문
- innodb_locks_unsafe_for_binlog 시스템 설정 값을 1로 설정하고 트랜잭션 격리 수준을 READ-COMMITTED로 설정해 대부분의 갭락이나 넥스트 키 락을 제거
    - 인덱스 일치 여부를 판단하여 레코드 잠금
    - 인덱스를사용하지 않는 나머지 조건의 일치여부를 판단하여 레코드 잠금 해제
    - 불필요한 잠금이 생기는 현상은 없어짐
### 4.5. 레코드 수준의 잠금 확인 및 해제
- INFORMATION_SCHEMA라는 DB에 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS 테이블이 준비
    - INNODB_LOCKS: 어떤 잠금이 존재하는지 관리
    - INNODB)TRX: 어떤 트랜잭션이 어떤 클라이언트(프로세스)에 의해 기동되고 있으며, 어떤 잠금을 기다리고 있는지를 관리
    - INNODB_LOCK_WAITS: 잠금에 의한 프로세스 간의 의존 관계를 관리

## 5. MYSQL의 격리 수준
- 트랜잭션의 격리 수준이란 동시에 여러 트랜잭션이 처리 될때, 특정 트랜잭션이 다른 트랜잭셔에서 변경 조화하는 데이터를 볼 수 있도록 허용할지 말지를 결정
- 'READ UNCOMMITTED'(DIRTHY READ), 'READ COMMITTED', 'REPEATABLE READ', 'SERIALIZABLE' 4가지로 나뉨
### 5.1. READ UNCOMMITTED
- 각 트랜잭션에서의 변경 내용이 COMMIT, ROLLBACK 여부에 상관 없이 다른 트랜잭션에 보여짐
- 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상을 더티 리드(Dirty read)라 함
### 5.2. READ COMMITTED
- 온라인 서비스에서 가장 많이 선택되는 격리 수준
- 더티 리드 발생하지 않음
- 어떤 트랜잭션에서 데이터를 변경했더라고 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회 할 수 있음
- 언두 로그 사용
- NON-REPETABLE READ 발생
    - 한 트랜잭션에서서 동일한 SELECT 시 결과값이 동일하지 않은 상태
### 5.3. REPEATABLE READ
- READ COMMITTED 격리 수준에서 발생하는 'NON-REPEATABLEREAD' 부정합이 발생하지 않음
- REPEATABLE READ는 MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장
- 언두 로그 사용
- 팬텀 리드 (팬텀 로우): 다른 트랜잭션에서 변경 작업에 의해 레코드가 보였다가 안보였다하는 현상
- InnoDB의 REPEATABLE READ는 팬텀 리드가 발생하지 않음
### 5.4. SERIALIZABLE
- 가장 엄격한 격리 수준
- 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어짐
- 읽기 작업도 공유잠금(읽기 잠금)을 획득해야 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못함
- 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없음
- 팬텀 리드 문제가 발생하지 않음
### 5.5. REPEABLE READ 격리 수준과 READ COMMITTED 격리 수준의 성능 비교
- READ COMMITTED이나 REPEATABLE READ 격리 수준의 성능 차이는 크지 않음
- 