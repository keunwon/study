# 16. 베스트 팩티스

## 1. 임의(랜덤) 정렬
### 1.1. 지금까지의 구현
- 대용량 테이블에서 WHERE 조건이 없다거나 WHERE 저건으로도 정렬 대상 건수를 많이 줄이지 못하면 상당한 시간과 자원을 소비하는 쿼리
### 1.2. 인덱스를 이용한 임의 정렬
- 임의의 정렬이 필요한 테이블에 대해서는 테이블을 생성할 때 새로운 컬럼을 추가하고 임의의 값을 미리 각 레코드에 부여

## 2. 페이징 쿼리
- MYSQL 서버에서 페이징하려면 LIMIT 기능을 많이 사용
- LIMIT가 사용된 페이징 쿼리가 인덱스를 이용할 수 있다면 크게 성능상의 문제 없이 사용할 수 있음
- 인덱스를 사용해도 다음 페이지로 넘어가면 조금씩 느려지는 구조

## 3. MYSQL에서 시퀀스 구현
- 특정 테이블에 의존하지 않고 독립적으로 일련번호가 발급하는 기능
### 3.1. 시퀀스용 테이블 준비
- 시퀀스 테이블을 InnoDB로 선택시 테이블 잠금 때문에 성능 저하를 유발할 수 있음
### 3.2. 시퀀스를 위한 스토어드 함수
- 시퀀스 번호를 가져와야하는데 이때 스토어드 함수로 캡슐화해서 구현해두는 편이 좋음
### 3.4. 시퀀스 사용 시 주의사항
- INSERT 시 직접적으로 시퀀스를 가져오지 말아야함, 미리 시퀀스 정보를 가져와야함

## 4. 큰 문자열 컬럼의 인덱스(해시)
- 가끔 매우 긴 문자열을 저장하는 컬럼에 대해 인덱스를 생성하거나 검색을 수행해야 할 때가 있음
    - MYISAM or InnoDB 테이블의 인덱스는 하나의 레코드가 767바이트 이상을 넘을 수 없음
    - 767 바이트보다 큰 컬럼인 경우 앞 부분 767 바이트만 잘라서 프라이머리 키나 유니크 키로 생성할 수 있는데 이를 프리픽스 인덱스라고 함
- 다른 방법으로는 긴 문자열의 해시 값으로 프라이머리 키나 유니크 인덱스를 생성하는 방법을 사용

## 6. SNS의 타임라인 구현
- 친구나 팔로우라는 관계를 구현하려면 관리할 데이터가 기하급수적으로 불어남
- 자기에게 공유된 게시물 시간 순서대로 보는 타임라인 기능이 RDBMS에서는 가장 큰 문제
    - RDBMS는 쓰기는 느리지만 읽기는 빠르게 처리하는 것이 장점이자 특성인데, 타임라인 기능은 읽기보다 쓰기의 비중이 큼
    - RDBMS의 정렬은 인덱스를 이용하지 못하면 정렬 대상 건수에 비례해 상당히 느려짐
    - 이러한 문제를 해결하기 위해서 NoSQL이라고 불리는 읽기보다 쓰기 위주의 데이터베이스가 출시
### 6.3. Try & Fail 쿼리
- 실시간으로 정렬을 하기에는 너무 느리고, 그렇다고 미리 타임라인을 위한 인덱스 테이블을 만들어 두기에는 시스템적으로나 관리상 부담스럽다면 Try & Fail 쿼리를 사용
- Try & Fail 쿼리 방법은 실시간으로 처리할 수 있는 만큼만 조금씩 잘라서 정렬하고, 필요한 만큼의 레코드가 조회될 때까지 여러번 SELECT 쿼리를 실행하자는 것이 기본 원리

## 7. MYSQL 표준 설정
### 7.1. MYSQL 표준 설정의 필요성
- MYSQL 기본 확장 방식은 하드웨어의 성능을 업그레이드하는 (스케일 업),  
똑같은 성능의 하드웨어를 장착한 서버의 대수를 늘리는 형태(스케일 아웃)이 있음
- MYSQL 서버는 하나의 인스턴스에 많은 데이터가 관리되기 보다는 복수의 MYSQL 인스턴스에 골고루 데이터를 분포시키는 방식이 많이 사용

## 8. 복제를 사용하지 않는 MYSQL의 설정
- MYSQL 복제를 사용하려면 바이너리 로그 파일이 활성화돼야 함
- 시스템 설정 값 중에 'log-bin'이라는 설정에 파일 이름이나 경로가 명시되면 MYSQL은 무조건 바이너리 로그를 활성화
- 바이너리 로그는 상당히 고비용의 디스크 I/O작업이 필요
- 바이너리 로그가 안전하게 슬레이브 MYSQL 서버에 전달되게끔 MYSQL 서버 내부적으로 갭 락과 넷스트 키 락을 사용
- 바이너리 로그는 InnoDB 테이블의 락 + I/O 작업이 필요
- 복제를 사용하지 않으면 바이너리 로그를 비활성화, InnoDB가 갭락과 넥스트 키 락을 사용하지 안헥 트랜잭션 격리 수준을 READ-COMMITTED로 사용하는 것이 가장 좋음

## 9. MYSQL 복제 구축
### 9.1. MYSQL 복제의 형태
- 마스터는 쓰기 부하가 집중되는 구조이므로 최대한 읽기를 위한 쿼리는 슬레이브로 유도
#### 1:M 복제
- MYSQL 서버에 2개 이상의 슬레이브 MYSQL을 연결시키는 복제 형태
- 서비스용으로 가장 자주 사용되는 복제의 형태
    - 쿼리의 요청 수가 아주 많다면 마스터와 슬레이브 간에 적절히 분산해서 실행하는 것이 가능
    - 백업, 통계, 배치 프로그램의 용도로 슬레이브를 사용하는 데 이 구조를 사용하기도 함
- 슬레이브 MYSQL 서버는 읽기 전용으로 설정해서 마스터 슬레이브의 데이터가 달라지지 않게 해줌
    - MYSQL 서버 설정 파일에 'read-only' 설정 추가 (일반 사용자는 데이터는 변경을 할 수 없음)
    - 'read_only' 옵션이 추가되어도 SUPER권한을 가진 사용자는 데이터를 변경할 수 있으니 주의해야함
- MYSQL 복제는 비동기 방식
    - 마스터의 데이터가 슬레이브로 전달
    - 마스터에서 commit된 데이터라도 슬레이브에는 그 데이터가 아직 전달되지 않았을수도 있음
    - 데이터 변경과 동시에 SELECT하는 쿼리는 마스터 MYSQL 서버에서 실행하는 것이 좋음
- 1:M 복제구조에서 슬레이브 MYSQL 서버 대수가 많아지만 마스터 MYSQL 서버가 복제를 위해 바이너리 로그를 슬레이브로 전달하는 작업이 느려질 수도 있음
#### 1:M:M 복제
- 1:M 복제 구조에서 슬레이브 MYSQL 서버가 너무 많아서 마스터 MYSQL 서버의 성능에 악영향이 예상된다면 1:M:M 구조 복제를 고려
- 마스터 MYSQL은 슬레이브 MYSQL이 요청할 때마다 계속 바이너리 로그를 읽어서 전달해야 함, 만약 슬레이브가 개수가 많다면 바이너리 로그를 읽고 전달하는 작업 자체가 부하
    - 마스터 MYSQL 서버가 해야 할 바이너리 로그 배포 역할을 새로운 MYSQL 서버로 넘김
- MYSQL 서버를 업그레이드하거나 장비를 일괄 교체할 때도 많이 사용
### 9.2. 확장 (스케일 아웃)
- MYSQL의 복제는 읽기(SELECT)를 확장하는 방법이지 쓰기(INSERT, UPDATE, DELETE)를 확장하는 방법은 아님
- 쓰기 작업은 마스터 MYSQL로 집중
### 9.3. 가용성
- 마스터 MYSQL 서버에 문제가 발생한다면 관련된 모든 서비스가 멈춰버리는 심각한 상황이 발생
    - 이때 슬레이브 MYSQL 서버가 있다면 슬레이브 MYSQL을 마스터로 승격(프로모션)하여 간단히 서비스 복구
    - 슬레이브의 read-only 해제, 바이너리 로그 활성화 등의 작업이 필요
        - 자동으로 마스터로 승격하는 MMM 도구 사용가능
    - 슬레이브가 자동으로 마스터로 변경해 버리는 것은 상당히 위험성 있는 작업이므로 많은 주의와 테스트 필요
### 9.4. 복제가 구축된 MYSQL에서의 작업
- 마스터 MYSQL에서 사용자가 동시 다발적으로 실행한 SQL이 슬레이브 MYSQL에서는 하나의 스레드에 의해 직렬화되어 하나씩 순차적으로 실행
- 시간이 오래 걸리는 인덱스나 컬럼 추가와 같은 작업은 마스터 MYSQL 서버에서만 실행하는 방법보다는 마스터와 슬레이브 각각의 MYSQL 서버에서 별도로 실행해 주는 것이 좋음
- 서비스 도중에 인덱스나 컬럼을 추가하는 작업은 복제에 참여하는 각각의 MYSQL 서버에서 개별적으로 수행하는 것이 좋음

## 10. SQL 작성 표준
### 10.1. 조인 조건은 항상 ON 절에 기재
- 조인조건은 WHERE 절이 아니라 조인의 ON 절에 명시하는게 좋음
### 10.2. 테이블 별칭(Alias) 사용 및 컬럼 명에 테이블 별칭 포함
- 여러 테이블이 조인되는 쿼리에서는 테이블의 별칭을 표기하지 않으면 구분하기 쉽지 않음
- 가능하다면 여러 테이블의 조인 여부와 상관없이 짧은 이름으로 테이블의 별칭을 부여하고, 컬럼 이름 앞에는 테이블의 별칭을 붙이게 좋음
### 10.3. 서버 사이드 프리페어 스테이트먼트 사용
- 프레페어 스테이트먼트를 사용하는 쿼리도 쿼리 캐시를 사용할 수 있음
### 10.4. FULL GROUP BY 사용

### 10.5. DELETE, UPDATE 쿼리에서 ORDER BY .. LIMIT .. 사용 자제
- 복제가 구축된 MYSQL에서는 DELETE, UPDATE쿼리에 ORDER BY .. LIMIT ... 형태의 쿼리를 실행하면 마스터와 슬레이브의 데이터가 다를수 있음
- 복제간 된 MYSQL에서는 위 쿼리를 사용하면 안됌
### 10.6. 문자열 리터럴 표기는 홑따옴표만 사용
- 문자열 리터널은 홑따옴표만 사용, 쌍따옴표는 식별자에 사용
### 10.7. 서브쿼리는 조인으로 변경
- 서브 쿼리로만 해결할 수 밖에 없는 요건이 아니라면 반드시 쿼리 개발 후 조인으로 다시 풀어서 작성하는게 좋음
### 10.8. UNION [ALL]은 사용 자제
- UNION [ALL]은 항상 내부적으로 임시 테이블을 만들어 버퍼링 한 다음에 사용자에게 결과를 반환
### 10.9. 스토어드 함수는 가능하면 DETERMINISTIC으로 정의
- 함수나 프로시저를 개발할 때는 반드시 DETERMINISTIC 키워드를 추가해서 그 함수나 프로시저가 입력 값이  
똑같으면 출력 값도 같다는 것을 옵티마이저에게 알려주는 것이 좋음
### 10.10. 스토어드 프로그램에서는 예외 처리 코드를 작성
- 적용된 건수를 체크
### 10.12. 숫자 값은 반드시 숫자 타입의 컬럼으로 정의
- 문자열 타입 컬럼에 숫자 값을 비교하면 문자열 타입 컬럼을 숫자형 컬럼으로 변경하여 비교함
    - 인덱스가 존재해도 인덱스를 사용하지 못함
## 11. 하드웨어와 플랫폼 선정
### 11.1. 하드웨어 선정
#### RAID 컨트롤러
- DBMS는 여러 소프트웨어 종류 중에서 디스크 I/O 의존도가 높은 종류 중 하나이다
- DBMS용 장비에서 RAID 컨트롤러는 필수
- 캐시 메모리가 장착되지 않은 RAID 컨트롤러는 단순히 디스크를 스트라이핑하거나 이중화하는 역할만 할 수 있음
- MYSQL 서버 용도로는 256MB 이상의 캐시가 장착돼 있는 RAID 컨트롤러를 사용하길 권장
- RAID 컨트롤러에 장착된 캐시는 읽기와 쓰기용으로 공간을 나눠서 사용
- MYSQL 용도의 장비라면 RAID 컨트롤러의 캐시를 읽기보다는 쓰기에 집중시켜야 함 (비율 쓰기(8):읽기(2))
- RAID 컨트롤러에 쓰기 방식
    - Write-through
        - MYSQL의 쓰기를 RAID 컨트롤러의 캐시 메모리에 버퍼링하지 않고 즉시 디스크로 내려 쓰고 난 다음에야 MYSQL 서버로 응답을 보내는 방식
        - 디스크에 모든 데이터가 기뢱되고서야 MYSQL 서버에 응답이 전달, RAID 컨트롤러의 캐시 메모리를 전혀 활용하지 못하는 방식
    - Write-back
        - 요청된 데이터를 RAID 컨트롤러의 캐시 메모리에 기록하면 그 내용이 디스크에 기록됐는지 확인하지 않고 MYSQL 서버에 응답을 보내는 방식
        - 캐시 메모리에 기록된 내용을 디스크로 내려 쓰는 작업은 RAID 컨트롤러에게 일임하고, MYSQL이나 운영체제는 관여하지 않음
#### 메모리
- MYSQL에서 어떤 스토리지 엔진을 사용하든지 물리적인 메모리는 많으면 많을수록 좋다
    - MYISAM 스토리지 엔진에서는 기본 키 캐시를 4GB 밖에 사용하지 못함
    - InnoDB 스토리지 엔진을 사용하면 16GB ~ 32GB까지 장착하는 것이 좋음
#### 디스크
- 디스크 또한 많으면 많을수록 좋음
    - 디스크의 개수가(디스크의 헤더의 개수)가 많은 것이 좋다는 의미
    - 디스크의 헤더가 많으면 많을수록 동일 시점에서 더 많은 데이터 쓰기나 읽기를 처리할 수 있음
### 11.2. 운영체제의 파일 시스템 선정
- sync_binlog = 0
    - 바이너리 로그를 기록은 하지만 직접적으로 플러시(동기화)를 실행하지 않음
    - 바이너리 로그 플러시를 운영체제에 맞김 (일반적인 리눅스는 3 ~ 5초 간격으로 자동으로 플러시)
    - 별도의 동기화 작업이 없기 때문에 바이너리 로그 파일의 쓰기 작업이 매우 빠르게 처리
    - 정전이나 운영체제가 종료되면 디스크에 동기화되지 않은 바이너리 로그는 사라짐
- sync_binlog = 1
    - 매번 바이너리 로그의 쓰기가 발생할 때마다 디스크 동기화를 수행
    - 매번 바이너리 로그 파일의 쓰기마다 디스크 동기화를 실행하므로 바이너리 로그가 손실될 가능성은 없음
    - 디스크 동기화가 자주 수행되므로 디스크 I/O를 많이 유발하고 그만큼 느려짐
- sync_binlog=(>1)
    - 1보다 큰 값이 설정되면 그 횟수만큼 바이너리 로그 쓰기가 발생하면 MYSQL 서버가 한 번씩 바이너리 로그 파일의 동기화를 수행

## 12. 백업 및 모니터링
### 12.1. 백업 (EnterpriseBackup과 mysqldump)
- mysqldump 백업 옵션
    - --extened-insert
        - INSERT되는 레코드를 VALUES 뒤에 연속해서 연결하는 배치 INSERT SQL 문장 형태로 덤프하며, 나중에 다시 적재할 때 빠르게 처리될 수 있기 때문에 꼭 사용하는 것이 좋음
    - --quick
        - 가져온 테이블 레코드를 한꺼번에 모두 캐시하지 않고 레코드 단위로 MYSQL 서버로부터 가져와서 디스크에 기록하므로 메모리를 많이 사용하지 않고 큰 테이블을 백업할 수 있음
    - --lock-tables
        - 백업이 수행되는 도중 데이터가 변경되는 것을 막기 위해 이 옵션이 필요할 수 있음
    - --single-transaction
        - InnoDB 스토리지 엔진을 주로 사용하는 DB의 백업에서는 데이터 정합성을 보장하기 위해 이 옵션을 반드시 사용할 것을 권장
        - 테이블을 잠그지 않으므로 서비스용 쿼리가 테이블의 레코드를 변경하는 것이 가능
    - --all-databases
        - mysqldump로 현재 MYSQL 서버의 모든 DB를 백업할 때 사용
    - --master-data
        - 복제를 구축하기 위해 mysqldump 프로그램으로 마스터 MYSQL에서 백업을 수행할 때는 백업 시점의 바이너리 로그를 꼭 확인해야 하는데, 이때 '--master-data=1' or '--master-data=2' 옵션을 사용해야 함
        - --master-data 옵션을 지정하면 mysqldump는 'FLUSH TABLES WITH READ LOCK' 명령으로 글로벌 락을 걸고, 백업 시점의 바이너리 로그의 위치를 읽음
        - --master-data=2
            - 백업된 파일의 맨 앞부분에 백업 시점의 바이너리 로그 파일명과 바이너리 로그의 위치 정보가 SQL 주석으로 기록
    - --opt
        - 다른 여러개의 옵션을 모아둔 세트 옵션으로 기본적으로 활서화되는 옵션
        - 이 옵션에는 --lock-tables 옵션이 포함돼 있음
            - mysqldump가 실행되면 DB에 포함된 모든 테이블에 읽기 잠금을 걸고 백업을 수행
