# 10. 파티션

## 파티션?
데이터를 별도의 테이블로 분리해서 저장하지만 사용자 입장에서는 여전히 하나의 테이블로 읽기와 쓰기를 할수 있게 해주는 솔루션
## 1. 개요
### 1.2. 파티션을 사용하는 이유
하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 크거나, 데이터 특성상 주기적인 삭제 작업이 필요한 경우 파티션이 필요
#### 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리
- 인덱스가 커지만 SELECT, INSERT, UPDATE, DELETE 작업도 당연히 느려짐
- 특히 한 테이블의 인덱스 크기가 물리적으로 MYSQL이 사용 가능한 메모리 공간보다 크다면 그 영향은 더 심각함
- 파티션은 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용 할수 있게 만들어줌
#### 데이터의 물리적인 저장소를 분리
- 데이터 파일이나 인덱스 파일의 크기가 크면 백업이나 관리 작업이 어려워짐
- 파티션을 통해서 파일의 크기르 조절하거나 각 파티션 파일들이 저장될 위치나 디스크를 구분해서 지정해서 해결
#### 이력 데이터의 효율적인 관리
- 로그 데이터는 시간이 지나면 별도로 아카이빙하거나 백업한 후 삭제해버리는 것이 일반적이다
- 로그 테이블을 파티션 테이블로 관리한다면 불필요한 데이터 삭제 작업은 단순히 파티션을 추가하거나 삭제하는 방식으로 간단하고 빠르게 해결
### 1.2. MYSQL 파티션의 내부 처리
#### 파티션 테이블의 레코드 INSERT
- 파티션 키를 이용해 레코드를 저장할 파티션을 결정함
#### 파티션 테이블의 UPDATE
- UPDATE 쿼리를 실행하려명 변경 대상 레코드가 어느 파티션에 저장돼 있는지 찾아야함
- UPDATE WHERE 조건에 파티션 키 컬럼이 조건으로 존재한다면 그 값을 이용해 레코드가 저장된 파티션에서 빠르게 대상 레코드를 검색할 수 있음
- 마약 파티션 키 컬럼이 조건에 없다면 모든 파티션을 검색
#### 파티션 테이블의 인덱스 스캔과 정렬
- 인덱스는 파티션 단위로 생성
- 여러 파티션에 대해 인덱스 스캔
    - 각 파티션으로부터 조건에 일치하는 레코드를 정렬된 순서대로 읽으면서 우선순위큐에 임시로 저장  
    (각 파티션에서 읽은 레코드들은 이미 정렬돼 있는 상태여서 가능함)
    - 우선순위 큐에서 다시 필요한 순서대로 데이터를 가져감
#### 파티션 프루닝
- 파티션 프루닝: 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들을 실행 계획에서 배제

## 2. 주의 사항
### 2.1. 파티션의 제한 사항
- 키 파티션은 해시 함수를 MYSQL이 직접 선택하기 때문에 컬럼에 타입 제한이 없음
- 최대 1024개의 파티션을 가질 수 있음 (서브 파티션 포함)
- 파티션 테이블에서는 외래키 사용 금지
- 파티션 테이블은 전문 검색 인덱스 생성 불가
- 공간 확장 기능에서 제공하는 컬럼 타입(Point ..) 파티션 테이블에서 사용 불가
- 임시 테이블은 파티션 기능 사용 불가
### 2.2. 파티션 사용 시 주의사항
#### 파티션과 유니크 키(프라이머리 키 포함)
- 종류에 상관없이 테이블에 유니크 인덱스(프라이머리 키 포함)가 있으면 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 컬럼을 포함해야 함
#### 파티션과 open_files_limit 파라미터
- MYSQL에서는 일반적으로 테이블을 파일 단위로 관리하기 때문에 동시에 오픈된 파일의 개수가 상당이 많아질 수 있는데 이를 제한하기 위한 시스템 변수
#### 파티션 테이블과 잠금
- 파티션 테이블에 쿼리가 수행되면 테이블을 열고 잠금을 걸고 쿼리의 최적화를 수행
- 파티션 프루닝은 쿼리 최적화 단계에 수행하므로 테이블을 열고 잠금을 거는 작업은 파티션 프루닝이 적용되지 않음(모든 파티션을 열고 잠금)
    - 5.7 버전 이후에서는 where에 조건에 맞는 행을 포함된 파티션만 lock

## 3. MYSQL 파티션의 종류
### 3.1. 레인지 파티션
- 파티션 키의 연속된 범위로 파티션을 정의하는 방법 (가장 일반적인 파티션 방법)
#### 레인지 파티션의 용도
- 날짜를 기반으로 데이터가 누적되고 년도, 월, 일 단위로 분석하고 삭제해야 할 때
- 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
- 파티션 키 위주로 검색이 자주 실행될 때
### 3.2. 리스트 파티션
- 파티션의 값 하나하나를 리트스로 나열함
- MAXVALUE 정의할 수 없음
#### 리스트 파티션의 용도
- 파티션 키 값이 코드 값이나 카테고리와 같이 고정
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
- 파티션 키 값을 기준으로 레코드 건수가 균일하고, 검색 조건에 파티션 키가 자주 사용될 때
### 3.3. 해시 파티션
- 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법
- 파티션의 개수는 레코드를 각 파티션에 할당하는 해시 알고리즘과 연관되기 때문에 파티션을 추가하거나 삭제하는 작업에는 테이블 전체적으로 레코드를 재분배하는 작업이 따름
#### 해시 파티션 용도
- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도로 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때
- 대표적으로 회원 테이블
#### 해시 파티션의 분리와 병합
- 파티션의 분리나 병합으로 인해 파티션의 개수가 변경된다는 것은 해시 함수의 알고리즘을 변경하는 것 (전체적인 파티션이 영향을 받음, 많은 부하 발생)
- 해시나 키 파티션은 파티션 단위로 레코드를 삭제하는 방법이 없음
- 파티션의 개수를 줄일때는 COALESCE PARTITION 명령을 사용
### 3.4. 키 파티션
- 해시 파티션과 사용법과 특성이 거의 같음
- 해시 값을 계산하는 방법을 파티션 키나 표현식에 사용자가 명시
- 키 파티션에서는 파티션 키를 MYSQL 서버가 만듬
#### 키 파티션의 생성
- 프라이머리 키가 있는 경우 프라이머리 키가 자동으로 키로 사용
- 프라이머리 키가 없고 유니크 키가 존재하면 유니크 키가 파티션 키로 사용
- 프라이머리 키, 유니크 키가 존재하지 않으면 명시적으로 설정
### 3.5. 리니어 해시 파티션/리니어 키 파티션
- 해시, 키 파티션은 새로운 파티션을 추가하거나 개수를 줄일 때 모든 테이블의 전체 파티션에 저장된 레코들의 재분배 작업이 발생
- 위에 단점을 최소화하기 위해 리니어 해시 파티션/리니어 키 파티션 사용 (Power-of-two(2의 승수) 알고리즘 이용)
### 3.6. 서브 파티
서비스 요건에 따라 기간 단위로 레인지 파티션을 생성, 각 레인지 파티션 내에서 다시 지역별로 리스트 서브 파티션을 구성하는 형태의 파티션이 가능
### 3.8. 파티션 테이블 관련 벤치마킹
#### 테이블 크기
- 파티션을 이용한다고 해서 디스크의 공간적인 장점은 없음 (InnoDB의 버퍼 풀 메모리로 읽어들여야 할 데이터가 맣다는 것은 동일)
#### INSERT 성능 테스트
- 레인지 파티션이 일반 테이블보다 더 빠른 결과(35%)를 확인할 수 있음
#### SELECT 성능 테스트
- 파티션 여부에 따른 성능 변화는 거의 없음 (인덱스 사용 시)
### 3.9. 파티션 기능에 대한 결론
- SELECT 쿼리의 성능에는 그다지 큰 도움을 주지 못함, 쓰기 성능에는 어느 정도 도움
- 쓰기 성능의 개선을 위해 파티션 적용을 고려해 보는 것이 좋음
