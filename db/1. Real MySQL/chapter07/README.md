# 7. 쿼리 작성 및 최적화

## 3. MYSQL 연산자와 내장 함수
### 문자열
```sql
# 1
select * from departments where dept_no = 'd''001';
# 2
select * from departments where dept_no = 'd"001';
# 3
select * from departments where dept_no = "d'001";
# 4
select * from departments where dept_no = "d""001";
```
- 1, 2번은 SQL 표준
- 3, 4번은 MYSQL에서만 지원
### 숫자
- 숫자형 컬럼에 문자열 값을 넣으면 자동으로 숫자 형으로 변경해줌
- 문자열 컬럼에 숫자 값을 넣으면 문자열 컬럼을 숫자 컬럼으로 변경하여 비교해줌
    - 만약 문자열 컬럼에 인덱스가 걸렸있으면 이를 사용하지 못함
    - 문자열 컬럼에 알파벳과 같은 문자가 포함된 경우 숫자 값으로 변환할 수 없어 쿼리가 실해함
### 날짜
- 문자열을 자동으로 DATE, DATETIME 값으로 자동으로 변환함
### 불리언
- BOOLEAN이라는 타입이 있지만 사실은 TINYINT 타입에 대한 동의어 (쿼리 결과는 0, 1 값이 조회)
### 동등(Equal) 비교 (=, <=>)
- '=' 기호를 사용해 비교를 수행
- '<=>' 기호는 '=' 연산자와 같으며, 부가적으로 NULL 값에 대한 비교까지 수행
### REGEXP 연산자
- 문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자 (정규식 표현식)
- 인덱스를 사용할 수 없음
### LIKE 연산자
- 인덱스를 사용 가능
### BETWEEN 연산자
- 크거나 같아, 작거나 같다 두 개의 연산자를 하나로 합침
### IN 연산자
- 여러개의 값에 대해 동등 비교 연산을 수행
### MYSQL 내장 함수
#### NULL 값 비교 및 대체
- IFNULL: null 이면 다른 값으로 대체하는 용도
- ISNULL: null인지 아닌지 비교
#### 현재 시간 조회(NOW, SYSDATE)
- NOW: 하나의 SQL에서 동일한 값을 가짐
- SYSDATE: 하나의 SQL에서 사용한 시점마다 현재 시간을 출력함
#### 날짜와 시간의 포멧
|지정 문자|내용|
|:---:|:---|
|%Y|4자리 년도|
|%m|2자리 숫자 표시의 월|
|%d|2자리 숫자 표시의 일자|
|%H|2자리 숫자 표시의 시|
|%i|2자리 숫자 표시의 분|
|%s|2자리 숫자 표시의 초|
#### 날짜와 시간의 연산(DATE_ADD, DATE_SUB)
- 특정 날짜에서 년도나 월일 또는 시간을 등을 더하거나 뺄 때는 DATE_ADD(), ATE_SUB() 사용
#### 문자열 처리 (RPAD, LPAD / RTRIM, LTRIM, TRIM)
- RPAD, LPAD 함수는 문자열 좌, 우에 문자를 덧붙임
- RTRIM, LTRIM 함수는 문자열의 좌, 우에 연속된 공백 문자를 제거
- TRIM 함수는 RTRIM, LTRIM 동시에 수행
#### 문자열 결합 (CONCAT)
- 여러 개의 문자열을 연결해서 하나의 문자열로 반환하는 함수 (인자의 개수는 제한이 없음)
- CONCAT_WS(): 구분자를 지정하여 문자열을 연결할 때 구분자를 추가함
#### GROUP BY 문자열을 결합 (GROUP_CONCAT)
- COUNT(), MAX(), MIN(), AVG() 등과 같은 그룹함수 중 하나이다
- GROUP BY가 없는 SQL에서 사용하면 고유한 결과들을 가지고 정렬 한 후 연결하거나 값의 구분자 설정을 함  
(= 여러 값중에서 중복을 제거하고 연결함)
- 메모리 버퍼 공간을 사용함 (기본 1KB)
- GROUP_CONCAT() 함수를 자주 사용하면 버퍼의 크기를 적절히 늘려야 함
#### 값의 비교와 대체 (CASE WHEN .. THEN .. END)
- 프로그래밍 언어에서 제공하는 SWITCH 구문과 같은 역할
#### 타입 변환 (CAST, CONVERT)
- CAST: 명시적인 타입의 변환
- CONVERT: CAST와 비슷하지만 함수의 인자 사용 규칙이 다름
#### 암호화 및 해시 함수 (MD5, SHA)
- 비대칭 알고리즘
- MD5: 128비트 해시 값 반환 (char(32) 타입 필요 = binary(16) = unhex(md5('abc')))
- SHA: 160비트 해시값 반환 (char(40) 타입 필요 = binary(20) = unhex(sha('abc')) )
- 중복될 가능성이 매우 작기때문에 binary로 크기를 줄여서 인덱로 사용할 수도 있음
#### 밴치마크 (BENCHMARK)
- SLEEP 함수와 같이 디버깅이나 간단한 함수의 성능 테스용으로 아주 유용
- 지정한 횟수만큼 반복 실행하는데 얼마나 시간이 소요됐는지가 출력
#### IP 주소 변환(INET_ATON, INET_NTOA)
- IP 주소를 일반 문자열로 저장시 VARCHAR(15) 가 필요함
- INET_ATON: 문자열로 구성된 IP 주소를 정수형으로 변환하는 함수  
- INET_NTOA: 정수형의 IP 주소를 사람이 읽을 수 있는 형태의 '.'으로 구분된 문자열로 변환하는 함수
#### COUNT
- 컬럼의 값이 null인 경우 레코드 건수에 포함되지 않음
- count 쿼리에 order by, left join에서는 제거하는게 좋음

## 4. SELECT
### 4.1. SELECT 각 절의 처리 순서
- 기본: GROUP BY -> DISTINCT 적용 -> HAVING 조건 필터링 -> ORDER BY 정렬 -> LIMIT 적용
- ORDER BY, GROUP BY 절이 있다 하더라도 인덱스를 이용해 처리할 때는 그 단계 자체가 불필요함
### 4.2. WHERE 절과 GROUP BY 절, 그리고 ORDER BY 절의 인덱스 사용
#### 인덱스를 사용하기 위한 기본 규칙
- where, order by, group by가 인덱스를 사용하려면 인덱스 컬럼의 값 자체를 변환하지 않고 그대로 사용해야함
- 인덱스 컬럼의 값을 아무런 변환 없이 B-tree에 정렬해 정함
#### WHERE 절의 인덱스 사용
- 각 조건이 명시된 순서는 중요치 않고, 그 컬럼에 대한 조건이 있는지 없는지가 중요함  
(인덱스를 구성하는 컬럼과 얼마나 좌측부터 일치하는가에 따라 달라짐)
#### GROUP BY 절의 인덱스 사용
- GROUP BY 절에 명시된 컬럼이 인덱스 컬럼의 순서와 위치가 같아야 함
- 인덱스 앞쪽에 있는 컬럼이 GROUP BY 절에 명시되지 않으면 인덱스를 사용할 수 없음
- WHERE 조건절과 달리, GROUP BY 절에 명시된 컬럼이 하나라도 인덱스가 없으면 GROUP BY 절은 전혀 인덱스를 이용하지 못함
#### ORDER BY 절의 인덱스 사용
- MySQL의 인덱스는 모든 컬럼이 오름차순으로만 정렬돼 있기 때문에 ORDER BY 절의 모든 컬럼이 오른차순이거나 내림차순일 때만 인덱스를 사용할 수 있음
#### WHERE 조건과 ORDER BY(또는 GROUP BY)절의 인덱스 내용
- WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 이용
- WHERE 절만 인덱스를 이용
- ORDER BY 절은 인덱스를 이용한 정렬이 불가능하여, 인덱스를 통해 검색된 결과 레코드를 별도의 정렬 처리 과정을 거쳐서 정렬을 수행 (Filesort)
    - WHERE 절의 조건에 일치하는 레코드의 건수가 많지 않을 때 효율적인 방식
- ORDER BY 절만 인덱스를 이용
    - ORDER BY 절의 순서대로 인덱스를 읽으면서, 레코드 한건을 WHERE 절의 조건에 일치하는지 비교해 일치하지 않을 때는 버리는 형태로 처리 (주로 많은 레코드를 조회해서 정렬해야 할 때)
#### WHERE 조건과 ORDER BY 절, 그리고 GROUP BY 절의 인덱스 사용
1. WHERE 절이 인덱스를 사용할 수 있는가?
2. GROUP BY 절이 인덱스를 사용할 수 있는가?
3. GROUP BY 절과 ORDER BY 절이 동시에 인덱스를 사용할 수 있는가?
### 4.3. WHERE 절의 비교 조건 사용 시 주의사항
#### NULL 비교
- MYSQL에서는 NULL 값이 포함된 레코드로 인덱스로 관리 (인덱스에서는 NULL을 하나의 값으로 인정해서 관리함)
#### 문자열이나 숫자 비교
- 문자열, 숫자 컬럼을 비교할 때는 반드시 그 타입을 맞춰서 상수를 사용할 것을 권장
#### DATE나 DATETIME과 문자열 비교
- DATE, DATETIME 타입의 값과 문자열을 비교할 때는 문자열을 자동으로 DATETIME 타입의 값으로 변환해서 비교를 수행
#### DATE와 DATETIME의 비교
- DATETIME 컬럼을 DATE와 비교시 DATE를 DATETIME으로 변경 (시분초는 00:00:00 으로 세팅)
- 인덱스의 사용 여부에 영향을 미치지 않음 (성능보다는 결과에 주의해야함)
### 4.4. DISTINCT
- DISTINCT 처리가 인덱스를 사용되지 못할 때는 항상 임시 테이블이 있어야 함
#### SELECT DISTINCT ...
- 인덱스를 사용하는 SELECT DISTINCT, GROUP BY에서는 같은 방식으로 처리
### 4.5. LIMIT n
- MYSQL에 존재하는 키워드
- LIMIT은 WHERE 조건이 아니기 때문에 항상 쿼리의 마지막에 실행
- GROUP BY와 함계 사용되는 경우에는 LIMIT절이 있더라도 실질적인 서버의 작업 내용을 크게 줄여주지 못함 (GROUP BY 완료 후 처리)
### 4.6. JOIN
#### JOIN 순서와 인덱스
- 인덱스 레인지 스캔
    1. 인덱스 탐색(index seek): 인덱스 조건을 만족하는 값이 저장된 위치를 찾음
    2. 인덱스 스캔(index scan): 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 읽음
    3. 2번에서 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어옴
- 인덱스 풀 스캔, 테이블 풀 스캔 작업은 인덱스 탐색(index seek) 과정이 거의 없지만 실제 인덱스나 테이블의 모든 레코드를 읽기 때문에 부하가 높음
- 조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한번만 수행하고, 그 이후부터는 스캔만 실행함
#### JOIN 컬럼의 데이터 타입
#### OUTER JOIN의 주의사항
#### OUTER JOIN과 COUNT(*)
#### OUTER JOIN을 이용한 ANTI JOIN
#### INNER JOIN과 OUTER JOIN의 선택
#### FULL OUTER JOIN 구현
#### 조인 순서로 인한 쿼리 실패
#### JOIN과 FOREIGN KEY
#### 지연된 조인(Delayed Join)
#### 조인 버퍼 사용으로 인한 정렬 흐트러짐

