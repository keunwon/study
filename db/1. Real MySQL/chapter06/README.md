# 6. 실행 계획

## 1. 개요
### DBMS의 옵티마이저
쿼리를 최적으로 실행하기 위해 테이블 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참고하고,   
그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업을 담당
### 1.1. 쿼리 실행 절차
1. 사용자로부터 요청된 SQL 문장을 잘개 쪼개서 MYSQL 서버가 이해할 수 있는 수준으로 분리
    - SQL 파싱이라고 함
    - MySQL 서버의 SQL 파서 모듈로 처리 (문법 검사를 진행함)
    - SQL 파스 트리가 만들어지고, MySQL서버는 SQL 파스 트리를 이용하여 쿼리 실행
2. SQL의 파싱정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
    - 최적화 및 실행 계획 수립
    - MYSQL 서버의 **옵티마이저** 에서 처리
    - 두번째 단계가 완료되면 **실행계획**이 만들어짐
3. 두번째 단계에서 결정된 테이블 읽기 순서나, 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴
    - MYSQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행
- 1, 2번 단계는 거의 MYSQL 엔진에서 처리하고, 3번은 MYSQL 엔진과 스토리 엔진이 동시에 참여해 처리
### 1.2. 옵티마이저의 종류
- 데이터베이스의 서버의 두뇌
- 거이 대부분의 RDBM가 **비용 기반의 옵티마이저**를 채택 (MYSQL)
### 1.3. 통계 정보
- 비용 기반 최적화에서 가장 중요한 것은 통계 정보
- 레코드 건수가 많지 않으면 통계 정보가 상당히 부정확한 경우가 많으므로 **ANALYZE** 명령을 이용해 강제적으로 통계정보 갱신
- ANALYZE 실행 시 읽기와 쓰기 모두 불가능 (운영에서 사용 X)
- InnoDB의 통계 수집을 위한 인덱스 페이지 개수는 8개에서 2, 3배 이상을 벗어나지 않도록 설정하는 것이 좋음

##  2. 실행 계획 분석
### 2.1. id
select 쿼리 번호
### 2.2. select_type 컬럼
##### SIMPLE
- UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리
- 쿼리가 아무리 복잡하더라도 실행 계획에서 select_type이 simple인 단위 쿼리는 반드시 하나만 존재
- 일반적으로 가장 바깥 SELECT 쿼리가 SIMPLE 표시
#### PRIAMRY
- UNION이나 서브 쿼리가 포함된 SELECT 쿼리의 실행에서 가장 바깥쪽(outer)에 있는 단위 쿼리는  
select_type이 primary로 표지
- SIMPLE과 마찬가지로 select_type PRIAMRY 단위 SELECT 쿼리는 하나만 존재 (가장 바깥쪽)
#### UNION
    - UNION, UNION ALL 사용
#### DEPENDENT UNION, DEPENDENT SUBQUERY
- DEPNDET는 외부의 의해 영향을 받는 것을 의미
- 서브쿼리는 외부 쿼리보다 먼지 실행을 하는데 외부에 의존성을 가지고 있는 서브 쿼리는 외부 쿼리보다 먼저 실행 될 수가 없음
- DEPENDENT 키워드가 포함된 서버 쿼리는 비효율적인 경우가 많음
#### UNION RESULT
- UNION 결과를 담아주는 테이블을 의미
- UNION의 결과를 임시 테이블로 생성하는데 이때 임시테이블을 UNION RESULT
- 별도의 id 값은 부여 X
- 테이블 영역에 <union 1, 2>는 id가 1, 2번의 조회 결과를 union했다는 것을 의미
#### SUBQUERY
- FROM 절 이외에서 사용되는 서브쿼리 의미
- FROM 절에 사용된 서브 쿼리는 DERIVED 라고 표시
#### DERIVED
- FROM 절에 서브 쿼리 사용
- DEDERIVED인 경우에 생성되는 임시 테이블을 파생 테이블이라고 함
- 파생 테이블에는 인덱스가 전혀 없어 조인 시 성능상 불리할 때가 많음
#### UNCACHEABLE SUBQUERY
- 서브 쿼리에 포함된 요소에 의해 캐시 자체가 불가능 한 경우
#### UNCAHCEDABLE UNION
- 캐시를 사용하지 않음
### 2.3. table 컬럼
- mysql의 실행 단위는는 select 쿼리 기준이 아니라 테이블 기준이다
- table 칼럼에 <derived>, <union> 등 '<>' 사용하는 경우 임시 테이블을 의미, 숫자는 id를 지칭
> 추가: 드라이븐 테이블: 먼저 엑세스 되는 쪽, 드리븐 테이블: 나중에 엑세스 되는 쪽
### 2.4. type
MYSQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지 의미 (index, full table)
#### system
- 레코드가 1건만 존재하는 테이블 or 한 건도 존재하지 않는 테이블을 참조하는 경우
#### const
- where 절에 프라이머리 키, 유니크 키 사용하여 1건을 반환하는 쿼리 처리 방식
- 유니크 인덱스 스캔 이라고 표현하기도 함
#### eq_ref
- 첫 번째 읽은 테이블의 컬럼 값을 이용해 두번째 테이블을 프라이머리 키나 유니크 키로 동등 조건 검색
- 반드시 1개만 반환
#### ref
- 조인의 순서와 관계없이 사용, 프라이머리 키나 유니크 키등의 제약 조건도 없음
- 동등 조건, 여러개 반환 가능
#### fulltext
- MYSQL의 전문 검색(FULLtext) 인덱스를 사용해 레코드를 읽는 접근 방법
- Fulltext 인덱스는 통계 정보가 관리되지 않음
- MATCH ... AGINST 구문을 이용함
#### ref_or_null
- ref 방식 또는 NULL 비교 접근 방식
#### unique_subquery
- WHERE 조건절의 IN(subquery) 형태의 쿼리 접근 방식
- 서브쿼리에 중복되지 않은 유니크 값만 반환 (중복 제거 작업 X)
#### index_subquery
- WHERE 조건절의 IN(subquery) 형태의 쿼리 접근 방식
- 중복되는 값을 반활 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음
#### range
- 인덱스 레인지 스캔 형태 접근 방식
- <, >, IS NULL, BETWEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색
#### index_merge
- 접근 방식이 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후 그 결과를 병합하는 처리 방식
- fulltext 인덱스를 사용하는 쿼리에서는 적용되지 않음
#### index
- 인덱스 테이블 풀 스캔
#### ALL
- 풀 테이블 스캔
> 리드 어헤드(READ Ahead): MYSQL에 연속적으로 인접한 페이지가 연속으로 몇 번 읽으면 백그라운드로 작동하는 읽기 쓰레드가 최대 한번에 64개의 페이지씩 한꺼번에 디스크로부터 읽어들어 한 번에 한페이지 씩 읽을때보다 작업이 빠르다
### 2.5. possible_keys
후보로 선전했던 접근 방식에서 사용되는 인덱스 목록 (의미 없음)
### 2.6. key
최종 선택된 실행 계획에서 사용하는 인덱스 의미 (type all 이면 key 값은 null = 테이블 풀 스캔)
### 2.7. key_len
사용한 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려줌
### 2.8. ref
접근 방식이 ref이면 동등 조건으로 어떤 값이 제공됐는지 알려줌
### 2.9. rows
실행 계획의 효율성을 판단을 위해 예측했던 레코드 건수를 보여줌
### 2.10. extra
쿼리 싱행 계획에서 성능에 관련된 중요한 내용이 Extra 컬럼에 자주 표시
#### Distinct
- 쿼리의 Distinct를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 꼭 필요한 것만 조인, 꼭 필요한 레코드만 읽음
#### FULL SCAN on NULL Key
- 쿼리 실행 중 col1이 NULL을 만나면 예비책으로 풀 테이블 스캔을 사용할 것이라는 사실을 알려줌
#### Impossible HAVING
- HAVING 절의 조건을 만족하는 레코드가 없을 때 표시
- Impossible HAVING 메시지가 출력되면 쿼리를 제대로 작성되지 못한 경우가 대부분이다
#### Impossible WHERE
- WHERE 조건이 항상 FALSE가 될 수 밖에 없는 경우
- 테이블 구성상으로 알수 있는 경우 (ex. is NULL 등)
#### Impossible WHERE noticed after reading const tables
- const 접근 방식이 필요한 부분은 실행 계획 수립 단계에서 옵티마이저가 직접 쿼리의 일부를 실행함  
(실행된 결과 값을 원본 쿼리의 상수로 대체) -> WHERE 조건문이 유효하지 않으면 발생
> 쿼리 실행 계획을 만드는 과정에서 쿼리의 일부분을 실행해 봄
#### No matching min/max row
- MIN(), MAX() 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때
#### No matching row in const table
- 조인에 사용된 테이블에 const 방식으로 접근할 때, 일치하는 레코드가 없을 때
#### No tables used
- FROM 절 차제가 없거나, DUAL을 사용 할때
- MYSQL은 FROM 절이 없는 쿼리도 허용이 가능
#### Not exists
- outer join을 이용해 안티-조인을 수행하는 경우
- 안티-조인
    - A테이블에는 존재하지만 B 테이블에는 없는 값을 조회
    - NOT EXISTS, NOT IN, OUTER-JOIN 사용 (OUTER-JOIN 빠름)
#### Range checked for each record(index map: N)
- 매 레코드마다 인덱스 레인지 스캔을 체크함
    - 조인 시 사용하는 컬럼의 크기에 따라 풀 테이블 스캔, 인덱스 레인지 스캔으로 수행 할지 최적의 조인 방법을 찾음
- type은 항상 All
#### Scanned N databases
- information_schema 를 이용하여 MYSQL 서버 내의 존재하는 DB의 메타 정보를 조회함
- [ N ] 
    - 0: 특정 테이블의 정보만 요청
    - 1: 특정 데이터베이스내의 모든 스키마 정보가 요청
    - ALL: 서버 내의 모든 스키마 정보
#### Selct tables optimilzed away
- MIN(), MAX() 만 select 절에 사용하거나, GROUP BY로 MIN(), MAX()를 조회하는 쿼리가 인덱스를 사용할 수 없을 때  
인덱스를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용
#### unique row not found
- 두개의 테이블이 각각의 primary key, unique key로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 아우터 테이블에  
일치하는 레코드가 존재하지 않을 때 발생
#### Using filesort
- ORDER BY 처리가 인덱스를 사용하지 못할때 발생
- ORDER BY를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 사용하지 못할 때는 MYSQL 서버가 조회된 레코드를 다시 한번 정렬해야 함 (조회 된 레코드를 정렬 용 메모리 버퍼에 복사해 퀵 소트 알고리즘 수행)
#### Using index(커버링 인덱스)
- 데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 표시
#### Using index for group-by
- GROUP BY 처리가 인덱스를 이용할 때 표시
- GROUP BY 처리를 위래 인덱스를 읽는 방법을 루스 인덱스 스캔 이라고 함
- GROUP BY 에 인덱스를 사용해도 WHERE 조건에 의해 검색 레코드 건수가 적으면 사용하지 않을 수도 있음
#### Using join buffer
- 드리븐 테이블에 적적한 인덱스가 없는 경우 드라이빙 테이블로부터 읽은 데이터 건수만큼 매번 드리븐 테이블을 풀 테이블 스캔이나 인덱스 풀 스캔해야 하는데, 이때 드리븐 테이블의 비효율적인 검색을 보완하기 위해 드라이빙 테이블에서 읽은 레코드를 임시 공간에 보관해두고 필요할 때 재사용할 수 있게 함.  이때 임시로 보관해두는 메모리 공간을 **조인버퍼**라고 함 
- 위 설명을 간략히 하면 드리븐 테이블에 적절한 인덱스가 없는 경우 드리븐 테이블에서 읽은 레코드 값들은 조인 버퍼에 임시 보관해두어 재사용 하게 함 (매번 드리븐 테이블을 스캔 하지 않기 위해서)
- 조인 버퍼를 사용할 때 표시
- 카테시안 조인을 수행하는 쿼리는 항상 조인 버퍼를 사용
#### Using sort_union(...), Using union(...), Using intersect(...)
- index_merge 접근 방식으로 실행되는 경우(2개 이상의 인덱스가 동시에 사용), 각 인덱스로부터 읽은 결과를 어떻게 병합했는지 상세히 설명하기 위해 표시
- Using intersect(...)
    - 각 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우 각 처리 결과에서 교집합을 추출
- Using union(...)
    - 각 인덱스를 사용할 수 있는 조건이 OR로 연결될 경우 각 처리 결과에 합집합을 추출
- Using sort_union(...)
    - Using union과 같은 작업을 수행하지만 Using union으로 처리될 수 없는 경우 사용  
    (OR로 연결된 상대적으로 대량의 range 조건들)
    - 프라이머리 키만 먼저 읽어서 정렬하고 병합한 후에 레코드를 읽어서 반활할 수 있음
- 보통 사용된 조건이 모두 동등 조건이면 Using union(), 그렇지 않으면 Using sort_union()이 사용
#### Using temporay
- 임시 테이블을 사용하면 표시 (이때 디스에 생성했는지 메모리에 생성했는지는 실행 계획만으로는 판단이 불가능)  
- Using temporay이 표시되지 않지만, 실제 내부적으로는 임시 테이블을 사용 할때 많다.
    - FROM 절에 사용된 서브 쿼리는 무조건 임시 테이블 생성(파생 테이블 = Derived table)  
    - COUNT(DISTICT column) 를 포함하는 쿼리도 인덱스를 사용할 수 없는 경우에는 임시 테이블 생성  
    - UNION, UNION ALL이 사용된 쿼리도 항상 임시 테이블을 사용해서 결과를 병합  
    - 인덱스를 사용하지 못하는 정렬 작업 또한 임시 버퍼 공간을 사용하는데, 정렬해야 할 레코드가 많아지면 결국  
    디스크를 사용 (정렬에 사용되는 버퍼도 결국 실체는 임시테이블과 같음 = Using filesort)
#### Using where
- MYSQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에 표시
- MYSQL 엔진과 스토리지 엔진의 이원화된 구조 탓에 발생하는 문제점 
    - 작업 범위 제한 조건으로 사용되지 못하는 조건은 스토리지 엔진에서 인덱스를 통해 체크되는 것이 아니라 MYSQL 엔진에서 처리
#### Using where with pushed condition
- Condition push down이 적용됐음을 의미
    - Condition push down: 이원화된 구조의 불합리를 제거하기 위해 WHERE 절의 범위 제한 조건뿐만 아니라 체크 조건까지 
    모두 스트리지 엔진으로 전달
- 일반적으로 표시하지 않고 NDB 클러스터 스토리 엔진을 사용하는 테이블에서만 표시 (네트워크 통신 비용도 들어감)
    - NDB 클러스트: MYSQL 엔진이 외부에서 작동하는 스토리지 엔진  
    (MYSQL 스토리지 엔진의 레코드 -> NETWORK 통신 -> MYSQL 엔진 전달)
### 6.11 EXPLAIN EXTENDED (Filtered 컬럼)
- EXTRA의 속성이 Using Where인 경우 MYSQL 엔진이 필터링하고 남은 레코드를 의미 (단위는 %)
### 6.12 EXPLAIN EXTENDED (추가 옵티마이저 정보)
- 분석된 파스트리를 재조합해서 쿼리 문장과 비슷한 순서대로 나열해서 보여주는 것
    - 쿼리 실행 계획을 산출하기 위해 쿼리 문장을 분석해 파스 트리를 생성
    - 일부 최적화도 파스 트리를 이용해 수행
- EXPLAIN EXTENDED 실행 후 **show warnings** 입력 시 옵티마이저가 분석해서 다시 재조합 쿼리 문장을 확인 할 수 있음
    - 표준 SQL 문장은 아님
### 6.13. EXPLAIN PARTITIONS (Partitions 컬럼)
- 쿼리를 실행하기 위해 테이블의 파티션 중에 어떤 파티션을 사용했는지 등의 정보를 조회

## 3. MYSQL의 주요 처리 방식
### 3.1. 풀 테이블 스캔
- 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미
    - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우 (페이지가 1개로 구성된 경우)
    - WHERE 절이나 ON 절에 인덱스를 이용할 수 없을 때
    - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
    - max_seeks_for_key 변수를 특정 값 'N'으로 설정하면 최대 'N'건만 읽으면 된다고 판단함.  
    (이 값을 작게 설정할수록 MYSQL 서버가 인덱스를 더 사용하도록 유도함)
- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read Ahead)작이 자동으로 실행
    - Read Ahead: 앞으로 필요한 데이터를 예측하여 요청이 오기 전에 미리 디스크에 읽어 버퍼 풀에 가져다 두는 것을 의미
    - 풀 테이블 스캔이 실행되면 처음에는 몇 개의 데이터 페이지는 포그라운드 스레드(Foreground thred)가 페이지 읽기를 실행하지만 특정 시점부터 읽기 작업을 백그라운드 스레드로 넘김
        - 백그라운드 스레드가 읽기를 넘겨받는 시점부터 한번에 4 ~ 8개씩의 페이지를 읽으면서 계속 그 수를 증가,  
        이때 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둠
        - 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빠리 처리
    - Read Ahead를 언제 시작할지 시스템 변수를 이용해 변경 할 수 있음
        - innodb_read_ahead_threshold
        - 데이터 웨어하우스용으로 MYSQL 사용한다면 기본 옵션을 더 낮은 값으로 설정해 더 자주 리드 어헤드가 시작되도록 유도함
### 3.2. ORDER BY 처리 (Using filesort)
- 레코드 정렬 요건은 대부분의 조회 쿼리에 포함돼 있을 것이다
- 정렬을 인덱스를 이용하지 못하는 경우
     - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
     - GROUP BY, DISTINCT와 같은 처리의 결과를 정리해야 하는 경우
     - UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
     - 랜덤하게 결과 레코드를 가져와야 하는 경우
- MYSQL이 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 EXTRA 컬럼에 "Using #" 표시
#### 소트 버퍼 (Sort buffer)
- MYSQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아 사용하는데, 이 메모리 공간을 소트 버퍼라고 함
- 최대 사용 가능한 버퍼의 공간은 "sort_buffer_size" 라는 시스템 변수 설정
- 정렬해야 할 레코드가 소트 버퍼로 할당된 공간보다 크면 정렬해야 할 레코드를 여러 조각으로 나눠서 처리함
    - 조각별로 메모리에서 정렬을 하고 임시로 디스크에 저장을 함
    - 소트 버퍼는 세션(로컬) 메모리 영역을 사용하기 때문에 정렬 작업이 많아지면 사용할 수 있는 메모리가 작아짐
#### 정령 알고리즘
레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 정렬 알고리즘이 달라짐
##### 싱글 패스(Single pass) 알고리즘
- 소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT되는 컬럼 전부를 담아서 정렬을 수행하는 방식
##### 투 패스(Two pass) 알고리즘
- 정렬 대상 컬럼과 프라이머리 키값만을 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT 할 컬럼으로 가져오는 알고리즘 (예전 MYSQL에서 사용하던 방법이지만 특정 조건이 되면 이 방법을 사용함)
##### 추가 내용
- 싱글 패스 알고리즘은 1번, 투 패스 알고리즘은 2번 조회를 하는데 싱글 알고리즘은 더 많은 소트 버퍼 공간이 필요함
- 투 패스 알고리즘을 사용하는 경우
    - 레코드 크기가 max_length_for_sort_data 파라미터로 설정된 값보다 클 때
    - BLOB, TEXT 타입의 컬림이 SELECT 대상일 때  
> 싱글 패스 알고리즘은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠르며, 투 패스 알고리즘은 정렬 대상 레코도의 크기나 건수가 상당히 많은 경우 효율적
#### 정렬의 처리 방식
MYSQL 옵티마이저는 정렬 대상 레코드를 최소하기 위해 2가지 방법 중 하나를 선택
1. 드라이빙 테이블만 정렬한 다음 조인을 수행
2. 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬 수행
- 일반적으로 조인을 하고나면 레코드 건수가 매우 많으므로 1번 방법이 효율적임
##### 인덱스를 이용한 정렬
- 실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 됌
    - B-Tree 인덱스가 키값으로 정렬되어있음
##### 드라이빙 테이블만 정렬
- 조인이 수행되면 결과 레코드가 수가 많아지기 때문에 조인을 실행하기 전에, 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 좋다
##### 임시 테이블을 이용한 정렬
- 두개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수 있음
- 드라이빙 테이블 정렬은 2개 이상의 테이블이 조인되면서 정렬이 실행되지만 임시 테이블을 사용하지 않음
- 조인의 결과를 임시 테이블에 저장하고, 그결과를 다시 정렬을 함
- 정렬 방식 중 이 방식이 가장 느림
##### 정렬 방식의 성능 비교
- 스트리밍 방식
- 버퍼링 방식
### 3.3. GROUP BY
- ORDER BY와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 요소 중 하나
- HAVING 절은 GROUPY BY 결과에 대해 필터링 역할을 수행
- GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 HAVING 절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요는 없음
- GROUP BY 작업도 인덱스를 사용하는 경우와 사용하지 않는 경우가 있음
- 인덱스를 사용하면 인덱스를 차례대로 이용하는 인덱스 스캔 방법과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔이라는 방법으로 나누어짐
- 인덱스를 사용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블을 사용
#### 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)
- 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그룹핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그룹핑 작업을 수행하고 그 결과로 지인을 처리
#### 루스(loose) 인덱스 스캔을 이용하는 GROUP BY
- 인덱스의 레코드를 건너뛰면서 필요한 부분만 가져오는 것을 의미
- 실행 계획에는 "Using index for group-by" 표시
#### 임시 테이블을 사용하는 GROUP BY
- GROUP BY 기준 컬럼이 드라이빙 테이블에 있는 드리븐 테이블에 있는 관계없이 인덱스를 전혀 사용하지 못할 때 사용하는 방식
- GROUP BY 절에 사용된 컬럼을 유니크 키를 생성하여 임시 테이블에 사용
### 3.4. DISTINCT 처리
DISTINCT는 MIN(), MAX(), COUNT() 같은 집합 함수와 함께 사용되는 경우와 집합 함수가 없는 경우로 두가지로 구분  
집합함수 내에서 DISTINCT 사용시 인덱스를 사용되지 못할 때는 항상 임시 테이블을 사용하고, Extra 컬럼에는 "Using temporary" 메시지가 출력되지 않음
#### SELECT DISTINCT ...
- GROUP BY와 거이 같은 방식으로 처리
- SELECT DISTINCT의 경우 정렬이 보장되지 않음
#### 집합 함수와 함께 사용된 DISTINCT
- 임시 테이블 사용
### 6.5. 임시 테이블 (Using temporary)
#### 임시 테이블이 필요한 쿼리
- ORDER BY 와 GROUP BY에 명시된 컬럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION, UNION DISTINCT가 사용된 쿼리 (select_type 컬림이 UNION RESULT인 경우)
- UNION ALL이 사용된 쿼리
- 쿼리의 실행 계획에서 select_type이 DELRIVED인 쿼리
#### 임시 테이블이 디스크에 생성되는 경우
- BLOB, TEXT와 같은 대용량 컬림이 있는 경우
- UNION, UNION ALL 에서 SELECT되는 컬럼 중에서 길이가 512바이트 이상인 크기의 컬럼이 있는 경우
- GROUP BY, DISTINCT 컬럼에서 512바이트 이상인 크기의 컬럼이 있는 경우
- 임시 테이블에 저장할 데이터의 전체 크기가 시스템 설정 값보다 큰 경우
