# 6. 실행 계획

## 1. 개요
### DBMS의 옵티마이저
쿼리를 최적으로 실행하기 위해 테이블 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참고하고,   
그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업을 담당
### 쿼리 실행 절차
1. 사용자로부터 요청된 SQL 문장을 잘개 쪼개서 MYSQL 서버가 이해할 수 있는 수준으로 분리
    - SQL 파싱이라고 함
    - MySQL 서버의 SQL 파서 모듈로 처리 (문법 검사를 진행함)
    - SQL 파스 트리가 만들어지고, MySQL서버는 SQL 파스 트리를 이용하여 쿼리 실행
2. SQL의 파싱정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
    - 최적화 및 실행 계획 수립
    - MYSQL 서버의 **옵티마이저** 에서 처리
    - 두번째 단계가 완료되면 **실행계획**이 만들어짐
3. 두번째 단계에서 결정된 테이블 읽기 순서나, 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴
    - MYSQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행
- 1, 2번 단계는 거의 MYSQL 엔진에서 처리하고, 3번은 MYSQL 엔진과 스토리 엔진이 동시에 참여해 처리
### 옵티마이저의 종류
- 데이터베이스의 서버의 두뇌
- 거이 대부분의 RDBM가 **비용 기반의 옵티마이저**를 채택 (MYSQL)
### 통계 정보
- 비용 기반 최적화에서 가장 중요한 것은 통계 정보
- 레코드 건수가 많지 않으면 통계 정보가 상당히 부정확한 경우가 많으므로 **ANALYZE** 명령을 이용해 강제적으로 통계정보 갱신
- ANALYZE 실행 시 읽기와 쓰기 모두 불가능 (운영에서 사용 X)
- InnoDB의 통계 수집을 위한 인덱스 페이지 개수는 8개에서 2, 3배 이상을 벗어나지 않도록 설정하는 것이 좋음
###  실행 계획 분석
#### id
select 쿼리 번호
#### select_type
- SIMPLE
    - UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리
    - 쿼리가 아무리 복잡하더라도 실행 계획에서 select_type이 simple인 단위 쿼리는 반드시 하나만 존재
    - 일반적으로 가장 바깥 SELECT 쿼리가 SIMPLE 표시
- PRIAMRY
    - UNION이나 서브 쿼리가 포함된 SELECT 쿼리의 실행에서 가장 바깥쪽(outer)에 있는 단위 쿼리는  
    select_type이 primary로 표지
    - SIMPLE과 마찬가지로 select_type PRIAMRY 단위 SELECT 쿼리는 하나만 존재 (가장 바깥쪽)
- UNION
    - UNION, UNION ALL 사용
- DEPENDENT UNION, DEPENDENT SUBQUERY
    - DEPNDET는 외부의 의해 영향을 받는 것을 의미
    - 서브쿼리는 외부 쿼리보다 먼지 실행을 하는데 외부에 의존성을 가지고 있는 서브 쿼리는 외부 쿼리보다 먼저 실행 될 수가 없음
    - DEPENDENT 키워드가 포함된 서버 쿼리는 비효율적인 경우가 많음
- UNION RESULT
    - UNION 결과를 담아주는 테이블을 의미
    - UNION의 결과를 임시 테이블로 생성하는데 이때 임시테이블을 UNION RESULT
    - 별도의 id 값은 부여 X
    - 테이블 영역에 <union 1, 2>는 id가 1, 2번의 조회 결과를 union했다는 것을 의미
- SUBQUERY
    - FROM 절 이외에서 사용되는 서브쿼리 의미
    - FROM 절에 사용된 서브 쿼리는 DERIVED 라고 표시
- DERIVED
    - FROM 절에 서브 쿼리 사용
    - DEDERIVED인 경우에 생성되는 임시 테이블을 파생 테이블이라고 함
    - 파생 테이블에는 인덱스가 전혀 없어 조인 시 성능상 불리할 때가 많음
- UNCACHEABLE SUBQUERY
    - 서브 쿼리에 포함된 요소에 의해 캐시 자체가 불가능 한 경우
- UNCAHCEDABLE UNION
    - 캐시를 사용하지 않음
#### table
- mysql의 실행 단위는는 select 쿼리 기준이 아니라 테이블 기준이다
- table 칼럼에 <derived>, <union> 등 '<>' 사용하는 경우 임시 테이블을 의미, 숫자는 id를 지칭
> 추가: 드라이븐 테이블: 먼저 엑세스 되는 쪽, 드리븐 테이블: 나중에 엑세스 되는 쪽
#### type
MYSQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지 의미 (index, full table)
- system
    - 레코드가 1건만 존재하는 테이블 or 한 건도 존재하지 않는 테이블을 참조하는 경우
- const
    - where 절에 프라이머리 키, 유니크 키 사용하여 1건을 반환하는 쿼리 처리 방식
    - 유니크 인덱스 스캔 이라고 표현하기도 함
- eq_ref
    - 첫 번째 읽은ㄴ 테이블의 컬럼 값을 이용해 두번째 테이블을 프라이머리 키나 유니크 키로 동등 조건 검색
    - 반드시 1개만 반환
- ref
    - 조인의 순서와 관계없이 사용, 프라이머리 키나 유니크 키등의 제약 조건도 없음
    - 동등 조건, 여러개 반환 가능
- fulltext
    - MYSQL의 전문 검색(FULLtext) 인덱스를 사용해 레코드를 읽는 접근 방법
    - Fulltext 인덱스는 통계 정보가 관리되지 않음
    - MATCH ... AGINST 구문을 이용함
- ref_or_null
    - ref 방식 또는 NULL 비교 접근 방식
- unique_subquery
    - WHERE 조건절의 IN(subquery) 형태의 쿼리 접근 방식
    - 중복되지 않은 유니크 값만 반환 (중복 제거 작업 X)
- index_subquery
    - WHERE 조건절의 IN(subquery) 형태의 쿼리 접근 방식
    - 중복되는 값을 반활 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음
- rang
    - 인덱스 레인지 스캔 형태 접근 방식
    - <, >, IS NULL, BETWEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색
- index_merge
    - 접근 방식이 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후 그 결과를 병합하는 처리 방식
    - fulltext 인덱스를 사용하는 쿼리에서는 적용되지 않음
- index
    - 인덱스 테이블 풀 스캔
- ALL
    - 풀 테이블 스캔
    > 리드 어헤드(READ Ahead): MYSQL에 연속적으로 인접한 페이지가 연속으로 몇 번 읽으면 백그라운드로 작동하는 읽기 쓰레드가 최대 한번에 64개의 페이지씩 한꺼번에 디스크로부터 읽어들어 한 번에 한페이지 씩 읽을때보다 작업이 빠르다
#### possible_keys
    - 후보로 선전했던 접근 방식에서 사용되는 인덱스 목록 (의미 없음)
#### key
최종 선택된 실행 계획에서 사용하는 인덱스 의미

## 2. 실행 계획 분석

## 3. MYSQL의 주요 처리 방식

## 4. 실행 계획 분석 시 주의 사항