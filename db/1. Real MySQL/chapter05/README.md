# 5. 인덱스

## 2. 인덱스란?
- DBMS의 인덱스도 인덱스가 많은 테이블은 당연히 INSERT or UPDATE or DELETE 문장의 처리가 느려짐
- 인덱스를 가지고 있기 때문에 SELECT 문장은 매우 빠르게 처리
- DBMS에서는 인덱스는 데이터의 저장(INSERT, DUPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
- 인덱스를 많이 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러옴
- 프라이머리 키는 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스를 의미
    - 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 식별자라고도 부름
    - NULL 값을 허용하지 않음
- 프라이머리 키를 제외한 모든 인덱스를 보조 인덱스(Secondary Index)로 분류
    - 유니크 인덱스는 프라이머 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수 도 있다고 해서 대체 키라고하는데,  
    별도로 분류하기도 하고 그냥 보조 인덱스로 분류하기도 함
- B-Tree 인덱스 알고리즘
    - 가장 일반적으로 사용되는 인덱스 알고리즘
    - 컬럼의 값을 변경하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘
- Hash 인덱스 알고리즘
    - 컬럼의 값으로 해시 해시 값을 계산해서 인덱싱하는 알고리즘
    - 매우 빠른 검색을 지원하지만 값을 변경해서 인덱싱하므로, 값의 일부만 검색하고자 할 때는 인덱스를 사용할 수 없음
    - Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용
- Fractal-Tree 알고리즘
    - B-Tree의 단점을 보완하기 위해 고안된 알고리즘
    - 값을 변경하지 않고 인덱싱하는 B-Tree와 거의 비슷하지만 데이터가 저장되거나 삭제될 때 처리 비용을 상당히 줄일 수 있게 설계
    - B-Tree 알고리즘만큼 안정적이고 성숙되진 않았지만     

## 3. B-Tree 인덱스
- B-Tree는 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입
- B-Tree의 B는 Balanced를 의미함
- B-Tree는 컬럼의 원래 값을 변형시키지않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지하고 있음
### 3.1. 구조 및 특성
- B-Tree는 트리구조의 최상위에 하나의 '루트 노드'가 존재하고 그 하위에 자식 노드가 붙어 있는 형태
- 트리 구조의 가장 하위에 있는 노드를 '리프 노드'라 하고, 트리구조에 루트 노드도 아니고 리프 노드도 아닌  
중간의 노드를 '브랜치 노드'라고 함
- 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있음
- 인덱스의 키 값은 모두 정렬돼 있지만 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서대로 저장
- InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서대로 정렬되어 저장
    - 클러스터링이란 비슷한 값들은 최대한 모아서 저장하는 방식을 의미
- 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야함
- InnoDB의 인덱스의 레코드 주소는 테이블의 프라이머 키가 주소 역할 음
    - InnodDB는 프라이머리 키로 클러스팅 하기 때문
### 3.2. B-Tree 인덱스 키 추가 및 삭제
- 테이블의 레코드를 저장하거나 변경하는 경우, 인덱스 키 추가나 삭제 작업이 발생
#### 인덱스 키 추가
- 새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키값이 즉시 인덱스에 저장될 수 도 있고 그렇지 않을 수 도있음
- B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상에 적절한 위치를 검색해야 함
- 저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree 리프 노드에 저장, 만약 리프 노드가 꽉 차서  
더는 저장할 수 없을 때는 리프 노드가 분리돼야 하는데, 이느 상위 브랜치 노드까지 처리의 범위가 넓어짐
    - B-Tree는 상대적으로 쓰기 작업에 비용이 많이 듬
- InnoDB 스토리지 엔진은 상황에 따라 인덱스 키 추가 작업을 지연시켜 나중에 처리할지, 바로 처리할지 결정
    - INSERT 뿐만 아니라 DELETE 등에 의한 인덱스 키의 추가 및 삭제 작업까지 버퍼링해서 지연 처리할 수 있음 (체인지 버퍼링 사용)
#### 인덱스 키 삭제
- B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업 완료
- 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있음
- 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 디스크 I/O가 필요함
#### 인덱스 키 변경
- 인덱스의 키값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스 상의 
키값만 변경하는 것은 불가능
- B-Tree의 키값 변경 작업은 먼저 키값을 삭제한 후, 다시 새로운 키값을 추가하는 형태로 처리
#### 인덱스 키 검색
- 인덱스를 검색하는 작업은 B-Tree의 루트 노두부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행 (트리 탐색)
- 인덱스 트리 탐색은 SELECT, UPDATE, DELETE를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 인덱스가 있으면 빠른 검색이 가능
- 인덱스의 키값에 변형이 가히진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없음
- InnnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭 락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현
    - UPDATE  or DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 없는 인덱스가 없으면 붚리요하게 많은 레코드를 잠금
    - 심한경우 테이블의 모든 레코드를 잠글 수 도 있음
    - InnoDB 스토리지 엔진에서는 인덱스의 설계가 중요하고 많은 부분에 영향을 미침
### 3.3. B-Tree 인덱스 사용에 영향을 미치는 요소
- 인덱스를 구성하는 컬럼의 크기, 레코드 건수, 유니크한 인덱스 키값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받음
#### 인덱스 키값의 크기
- 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 함
- 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에 데이터를 버퍼링하는 기본 단위
- 인덱스도 페이지 단위로 관리 (B-Tree 루트, 브랜치, 리프 노드를 구분하는 기준이 페이지 단위)
- B-Tree의 자식 노드의 개수는 가변적인 구조
    - 자식 노드의 개수는 페이지의 크기와 키 값의 크기에 따라 결정
    - InnoDB의 페이지 크기는 16KB로 고정
#### B-Tree 깊이
#### 선택도(기수성)
#### 읽어야 하는 레코드의 건수

### 3.4. B-Tree 인덱스를 통한 데이터 읽기
### 3.5. 다중 컬럼(Multi-column) 인덱스
### 3.6. B-Tree 인덱스의 정렬 및 스캔 방향
### 3.7. B-Tree 인덱스의 가용성과 효율성


## 4. 해시(Hash) 인덱스
## 5. R-Tree 인덱스
## 6. Fractal-Tree 인덱스
## 7. 전문 검색(Full Text search) 인덱스
## 8. 비트맵 인덱스와 함수 기반 인덱스
## 9. 클러스터링 인덱스
## 10. 유니크 인덱스
## 11. 외래키
## 12. 키타 주의사항