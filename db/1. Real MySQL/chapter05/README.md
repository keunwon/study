# 5. 인덱스

## 2. 인덱스란?
- DBMS의 인덱스도 인덱스가 많은 테이블은 당연히 INSERT or UPDATE or DELETE 문장의 처리가 느려짐
- 인덱스를 가지고 있기 때문에 SELECT 문장은 매우 빠르게 처리
- DBMS에서는 인덱스는 데이터의 저장(INSERT, DUPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
- 인덱스를 많이 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러옴
- 프라이머리 키는 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스를 의미
    - 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 식별자라고도 부름
    - NULL 값을 허용하지 않음
- 프라이머리 키를 제외한 모든 인덱스를 보조 인덱스(Secondary Index)로 분류
    - 유니크 인덱스는 프라이머 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수 도 있다고 해서 대체 키라고하는데,  
    별도로 분류하기도 하고 그냥 보조 인덱스로 분류하기도 함
- B-Tree 인덱스 알고리즘
    - 가장 일반적으로 사용되는 인덱스 알고리즘
    - 컬럼의 값을 변경하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘
- Hash 인덱스 알고리즘
    - 컬럼의 값으로 해시 해시 값을 계산해서 인덱싱하는 알고리즘
    - 매우 빠른 검색을 지원하지만 값을 변경해서 인덱싱하므로, 값의 일부만 검색하고자 할 때는 인덱스를 사용할 수 없음
    - Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용
- Fractal-Tree 알고리즘
    - B-Tree의 단점을 보완하기 위해 고안된 알고리즘
    - 값을 변경하지 않고 인덱싱하는 B-Tree와 거의 비슷하지만 데이터가 저장되거나 삭제될 때 처리 비용을 상당히 줄일 수 있게 설계
    - B-Tree 알고리즘만큼 안정적이고 성숙되진 않았지만     

## 3. B-Tree 인덱스
- B-Tree는 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입
- B-Tree의 B는 Balanced를 의미함
- B-Tree는 컬럼의 원래 값을 변형시키지않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지하고 있음
### 3.1. 구조 및 특성
- B-Tree는 트리구조의 최상위에 하나의 '루트 노드'가 존재하고 그 하위에 자식 노드가 붙어 있는 형태
- 트리 구조의 가장 하위에 있는 노드를 '리프 노드'라 하고, 트리구조에 루트 노드도 아니고 리프 노드도 아닌  
중간의 노드를 '브랜치 노드'라고 함
- 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있음
- 인덱스의 키 값은 모두 정렬돼 있지만 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서대로 저장
- InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서대로 정렬되어 저장
    - 클러스터링이란 비슷한 값들은 최대한 모아서 저장하는 방식을 의미
- 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야함
- InnoDB의 인덱스의 레코드 주소는 테이블의 프라이머 키가 주소 역할 음
    - InnodDB는 프라이머리 키로 클러스팅 하기 때문
### 3.2. B-Tree 인덱스 키 추가 및 삭제
- 테이블의 레코드를 저장하거나 변경하는 경우, 인덱스 키 추가나 삭제 작업이 발생
#### 인덱스 키 추가
- 새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키값이 즉시 인덱스에 저장될 수 도 있고 그렇지 않을 수 도있음
- B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상에 적절한 위치를 검색해야 함
- 저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree 리프 노드에 저장, 만약 리프 노드가 꽉 차서  
더는 저장할 수 없을 때는 리프 노드가 분리돼야 하는데, 이느 상위 브랜치 노드까지 처리의 범위가 넓어짐
    - B-Tree는 상대적으로 쓰기 작업에 비용이 많이 듬
- InnoDB 스토리지 엔진은 상황에 따라 인덱스 키 추가 작업을 지연시켜 나중에 처리할지, 바로 처리할지 결정
    - INSERT 뿐만 아니라 DELETE 등에 의한 인덱스 키의 추가 및 삭제 작업까지 버퍼링해서 지연 처리할 수 있음 (체인지 버퍼링 사용)
#### 인덱스 키 삭제
- B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업 완료
- 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있음
- 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 디스크 I/O가 필요함
#### 인덱스 키 변경
- 인덱스의 키값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스 상의 
키값만 변경하는 것은 불가능
- B-Tree의 키값 변경 작업은 먼저 키값을 삭제한 후, 다시 새로운 키값을 추가하는 형태로 처리
#### 인덱스 키 검색
- 인덱스를 검색하는 작업은 B-Tree의 루트 노두부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행 (트리 탐색)
- 인덱스 트리 탐색은 SELECT, UPDATE, DELETE를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 인덱스가 있으면 빠른 검색이 가능
- 인덱스의 키값에 변형이 가히진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없음
- InnnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭 락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현
    - UPDATE  or DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 없는 인덱스가 없으면 붚리요하게 많은 레코드를 잠금
    - 심한경우 테이블의 모든 레코드를 잠글 수 도 있음
    - InnoDB 스토리지 엔진에서는 인덱스의 설계가 중요하고 많은 부분에 영향을 미침
### 3.3. B-Tree 인덱스 사용에 영향을 미치는 요소
- 인덱스를 구성하는 컬럼의 크기, 레코드 건수, 유니크한 인덱스 키값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받음
#### 인덱스 키값의 크기
- 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 함
- 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에 데이터를 버퍼링하는 기본 단위
- 인덱스도 페이지 단위로 관리 (B-Tree 루트, 브랜치, 리프 노드를 구분하는 기준이 페이지 단위)
- B-Tree의 자식 노드의 개수는 가변적인 구조
    - 자식 노드의 개수는 페이지의 크기와 키 값의 크기에 따라 결정
    - InnoDB의 페이지 크기는 16KB로 고정
    - 인덱스를 구성하는 키값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려짐
#### B-Tree 깊이
- B-Tree 인덱스의 깊이는 상당히 중요하지만 직접적으로 제어할 방법이 없음
- 인덱스의 키값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키값의 개수가 작아져 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미
- 인덱스의 키 값의 크기는 가능하다면 작게 만드는 것이 좋지만, 아무리 대용량의 데이터베이스라도 B-Tree의 깊이가 4 ~ 5이상까지 깊어지는 경우는 거의 발생하지 않음
#### 선택도(기수성)
- 인덱스의 선택도는 기수성(Cardinality)와 거의 같은 의미로 사용
- 모든 인덱스 키값 가운데 유니크한 값의 수를 의미
- 인덱스의 중복된 값이 많아지면 기수성은 낮아지며 동시에 선택도 또한 떨이짐
- 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리
#### 읽어야 하는 레코드의 건수
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 듬
- 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20 ~ 25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적임
    - 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에 직접 레코드 1건을 읽는 것보다 4 ~ 5배 정도 더 비용이 많이 드는 작업인 것으로 예측
### 3.4. B-Tree 인덱스를 통한 데이터 읽기
#### 인덱스 레인지 스캔
- 인덱스 접근 방법 가운데 가장 대표적인 접근 방식
- 인덱스 레인지 스캐은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- B-Tree 인덱스에서 루티와 브랜치 노드를 이용해 특정 검색 시작 값을 가지고 있는 리프 노드를 검색,  
그 지점부터 필요한 방향으로 인덱스를 읽어 나가는 과정을 '인덱스 레인지 스캔'
- 인덱스 조건이 일치하여 데이터 레코드를 읽기 위해 랜덤 I/O가 실행 (인덱스를 통해 데이터 레코드를 읽는 비용이 많이 듬)
- 인덱스를 통해 읽어야 할 데이터 레코드가 20 ~ 25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 효율적임
#### 인덱스 풀 스캔
- 인덱스 레인지와 달리 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 함
- 인덱스 레인지 스캔보다 빠르지 않지만 테이블 풀 스캔보다는 효율적
     - 인덱스에 포함된 컬럼만으로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문
#### 루스 인덱스 스캔
- 루스 인덱스 스캔은 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미
- 루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 동작하지만, 중간마다 필요하지 않은 인덱스 키값을 무시(SKIP)하고  
다음으로 넘어가는 형태 (주로 GROUP BY or 집합 함수 가운데 MAX(), MIN() 함수에 대해 최적화를 하는 경우에 사용)
### 3.5. 다중 컬럼(Multi-column) 인덱스
- 두 개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스라고 함
- 다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 위치가 상당히 중요
    - 앞에 인덱스 컬럼에 의존적임
### 3.6. B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스 키값은 항상 오름차순으로 정렬되지만 끝에서부터 읽으면 내림차순으로 정렬된 인덱스로도 사용될 수 있음
#### 인덱스 정렬
- MYSQL은 컬럼단위로 정렬 방식을 혼합해서 생성하는 기능을 지원하지 않음
#### 인덱스 스캔 방향
- 인덱스는 항상 오름차순으로만 정렬돼 있지만 인덱스를 최소값부터 읽으면 오름차순으로 값으로 가져올 수 있고,  
최대값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 MYSQL 옵티마이저는 이미 알고 있음
### 3.7. B-Tree 인덱스의 가용성과 효율성
#### 비교 조건의 종류와 효율성
- 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건ㅇ르 '필터링 조건' or '체크 조건'
- 작업의 범위를 결정하는 조건을 '작업 범위 결정 조건'
- 작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다고 해서 쿼리의 처리 성능을 높이지 못함
#### 인덱스의 가용성
- B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬되어 있음
#### 가용성과 효율성 판단
- B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없음 (작업 번위 결정 조건으로 사용을 못한다는 의미)
    - NOT-EQUAL로 비교되는 경우
        - WHERE column <> 'N'
        - WHERE column NOT IN (...)
        - WHERE column IS NOT NULL
    - Like '%??' (앞부분이 아닌 뒷부분 일치)형태로 문자열 패턴이 비교된 경우
        - WHERE column like '%검색조건'
        - WHERE column like '_검색조건'
        - WHERE column like '%검색조건%'
    - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변경된 후 비교된 경우
        - WHERE SUBSTRING(column, 1, 1) = 'X'
        - WHERE DAYOFMONTH(column) = 1
    - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
    - 데이터 타입이 서로 다른 비교
    - 문자열 데이터 타입의 콜레이션이 다른 경우
- MYSQL에서는 NULL 값도 인덱스로 관리

## 4. 해시(Hash) 인덱스
- B-Tree만큼 범용적이지 않지만 고유의 특성과 용도를 지닌 인덱스 가운데 하나
- 해시 인덱스는 동등 비교 검색에는 최적화되어 있지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없음
- 해시 인덱스는 메모리 기반의 테이블에 주로 구현
- InnoDB의 버퍼 풀에서 빠른 레코드 검색을 위한 어댑티브 해시 인덱스로 사용되기도 함
### 4.1. 구조 및 특성
- 해시 인덱스의 큰 장점은 실제 키값과는 관계없이 인덱스 크기가 작고 검색이 빠름
- 해시 인덱스는 트리 형태의 구조가 아니고 검색하고자 하는 값을 해시 함수를 거쳐 찾고자 하는 키값이 포함된 버켓을 알아낼 수 있음
- 해시 인덱스는 원래의 키 값을 저장하는 것이 아니라 해시 함수의 결과만을 저장하므로 키 컬럼의 값이 아무리 길어도 실제 해시 인덱스에 저장되는 값은 작다
- 해시 함수의 결과 값의 범위가 넓으면 버켓이 많이 필요하여 공간의 낭비가 커지고, 범위가 작으면 충돌되는 경우가 많이 발생해 해시 인덱스의 장점이 사라짐

## 5. R-Tree 인덱스
- R-Tree 인덱스 알고리즘을 이용해 2차원 데이터를 인덱싱하고 검색하는 목적의 인덱스
### 5.1. 구조 및 특성
- MYSQL은 공간 정보의 저장 및 검색을 위해 여러가지 기하하적 도형(Geometry) 정보를 관리할 수 있는 데이터 타입을 제공
### 5.2. R-Tree 인덱스의 용도
- 일반적으로 위도, 경도 좌표 저장에 주로 사용 (좌표 시스템에 기반을 둔 정보에 대해서도 적용 가능)
- Contains() or Intersect()를 이용해 거리 기반의 비교를 사용
    - 사각형 박스와 같은 다각형으로만 연산할 수 있음

## 7. 전문 검색(Full Text search) 인덱스
- 문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 스토리지 엔진에서 제공하는 B-Tree 인덱스를 사용할 수 없음
- 문서 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘을 전문 검색(Full Text search) 인덱스라고 함
### 7.1. 인덱스 알고리즘
#### 구분자(Stopword) 기법
- 등록된 구분자를 이용해 키워드를 분석해 내고, 결과 단어를 인덱스로 생성해 두고 검색에 이용하는 방법
- 전문 검색에서 결과의 정렬은 일치율(Match percent)이 높은 순으로 출력되는 것이 일반적
#### N-그램 (n-Gram) 기법
- N-그램이란 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법
- 2-Gram 방식이 많이 사용 (2글자 키워드 방식)
### 7.2. 구분자와 N-그램의 차이
- 구분자를 기준으로 삼으면 왼쪽 일치 기준으로 비교 검색을 실행
- N-그램 전문 검색 인덱스는 구분자 방식보다 인덱스의 크기가 큼
    - 인덱스 생성 과정이 복잡하므로 인덱스에 키워드를 추가하거나 삭제하는데 시간도 많이 걸림
- 공통적으로 검색어의 길이가 길어질수록 성능 저하가 발생

## 9. 클러스터링 인덱스
- 클러스터란 여러 개를 하나로 묶는다는 의미
- 인덱스 클러스터링은 값이 비슷한 것들을 묶어서 저장하는 형태로 구현
### 9.1. 클러스터링 인덱스
- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용 (프라이머 키값이 비슷한 레코드끼리 묶어서 저장)
- 프라이머리 키값에 의해 레코드의 저장 위치가 결정 (프라이머리 키값이 변경된다면 레코드의 물리적인 저장 위치가 바뀌어야함)
- 클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장되어 있음
- 프라이머리 키가 없는 InnoDB는 어떻게 클러스터 테이블로 구성?
    - 프라이머리 키를 대체할 컬럼을 선택함
    - NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터 키로 선택
    - 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후 클러스터 키로 선택
### 9.2. 보조 인덱스(Secondary index)에 미치는 영향
- InnoDB 테이블의 모든 보조 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어 있음
### 9.3.클러스터 인덱스의 장점과 단점
- 장점
    - 프라이머리 키로 검색할 때 처리 성능이 매우 빠름
    - 테이블의 모든 보조 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음
- 단점
    - 보조 인덱스가 클러스터 키를 갖기 때문에 클러스터 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
    - 보조 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 조금 느림
    - INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
    - 프라이머리 키를 변경할 때 레코드를 DELETE 이후 INSERT 작업이 필요하기 때문에 처리 성능이 느림

## 10. 유니크 인덱스
### 10.1. 유니크 인덱스와 일반 보조 인덱스의 비교
- 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음
- 유니크 인덱스와 유니크하지 않은 일반 보조 인덱스는 사실 인덱스의 구조상 아무런 차이점이 없음
### 10.2. 유니크 인덱스 사용 시 주의사항
- 꼭 필요한 경우라면 유니크 인덱스를 생성하는 것은 당연
- 성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지는 않는 편이 좋음

## 11. 외래키
- 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있음
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스까지 생성
### 11.1. 자식 테이블의 변경이 대기하는 경우
- 자식 테이블의 외래키 컬럼의 변경은 부모 테이블의 확인 필요, 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 쓰기 잠금이 해제될 때까지 기다림
### 11.2. 부모 테이블의 변경 작업이 대기하는 경우
- 데이터베이스에서 외래 키를 물리적으로 생성하려면 이러한 현상으로 인한 잠금 경합까지 고려해 개발을 진행해야 함
