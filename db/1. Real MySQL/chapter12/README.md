# 12. 쿼리 종류별 잠금

## 1. InnoDB의 기본 잠금 방식
### 1.1. SELECT
- REPEATABLE-READ 이하의 트랜잭션 격리 수중에서 InnoDB 테이블에 대한 SELECT 쿼리는 기본적으로 아무런 잠금을 사용하지 않음  
(이미 잠긴 레코드를 읽는 것도 아무런 제약이 없음)
- SERIALIZABLE 격리 수준에서는 모든 SELECT 쿼리는 읽기 잠금을 걸고 레코드를 읽음
- LOCK IN SHARE MODE
    - 읽기 잠금, 같은 트랜잭션에서 변경하려면 쓰기 잠금을 획득해야함
    - 읽기 잠금을 얻은 상태에서 쓰기 잠금을 얻는 과정에서 데드락이 발생할 수 있음
- FOR UPDATE
    - SELECT 쿼리 문장으로 읽은 레코드를 쓰기 모드로 잠금
    - 다른 트랜잭션에 대한 영향도가 크기 때문에 반드시 읽은 데이터를 변경해야 할 때만 사용하는 것이 좋음
- LOCK IN SHARE MODE, FOR UPDATE와 같은 잠금 읽기 기능은 COMMIT or ROLLBACK이 실행되면 잠금이 해제
### 1.2. INSERT, UPDATE, DELETE
- INSERT, UPDATE, DELETE 쿼리는 모두 쓰기 잠금을 사용, 필요 시 읽기 잠금을 사용
- UPDATE, DELETE 문장을 실행할 때 SQL 문장이 조건에 일치하는 레코드를 찾기 위해 참조하는 인덱스의 모든 레코드에 잠금을 검
- InnoDB의 쿼리의 WHERE 절에 명시된 모든 조건에 일치하는 레코드만 선별적으로 잠그는 것이 불가능함
- InnoDB에서 UPDATE가 실행될 때 인덱스 기반으로 레코드를 잠금
    - 인덱스를 사용하지 않으면 모든 레코드를 잠금
- InnoDB 스토리지 엔진에서는 인덱스는 빠른 검색이나 정렬 등의 목적으로도 사용되지만 내부적으로는 레코드 잠금의 기준으로도 사용
- READ-COMMITED에서는 인덱스와 관계없이 실제 변경되는 레코드만 잠금을 검

## 2. SQL 문장별로 사용하는 잠금
### 2.1. SELECT 쿼리의 잠금
#### SELECT ... FROM ...
- InnoDB 테이블에서 기본 형태의 SELECT 쿼리는 별도의 잠금을 사용하지 않음
- 다른 트랜잭션의 쿼리 영향을 받지 않음
- 별도로 레코드를 읽기 위해 대개하지도 않음
     - 다른 트랜잭션에서 레코드를 변경하거나 삭제 중이면 InnoDB에서 관리하고 있는 데이터 변경 이력(언두 로그)을 이용해 레코드를 읽음
- 트랜잭션 격리 수준이 SERIALIZAABLE인 경우 아무런 잠금 옵션이 없는 SELECT 쿼리라도 LOCK IN SHARE MODE 옵션이 자동으로 덧붙여져서 실행하므로 읽기 잠금을 획득해야 함
#### SELECT ... FROM ... LOCK IN SHARE MODE
- WHERE 절에 일치하는 레코드뿐 아니라 검색을 위해 접근한 모든 레코드에 대해 공유 넥스트 키 락(Share next-key lock)을 필요
- 만약 읽기 잠금을 걸어야 하는 레코드가 다른 트랜잭션에 의해 쓰기 잠금이 걸려 있으면 잠금이 해제될 때까지 기다려야 함
- 만약 읽기 잠금을 걸어야 하는 레코드가 다른 트랜잭션에 의해 일기 잠금이 걸려 있으면 별도의 대기 없이 잠금을 획득할 수 있음 (읽기 잠금끼리 상호 호환)
#### SELECT ... FROM ... FOR UPDATE
- WHERE 조건절에 일치하는 레코드를 검색하기 위해 접근한 모든 레코드에 대해 배타적 넥스트 키 락(EExclusive next-key lock)을 검
- 다른 트랜잭션에 의해 레코드가 읽기 잠금, 쓰기 잠금이 사용되고 있다면 그 잠금이 해제될 때까지 대기
- FOR UPDATE가 사용된 SELECT 쿼리는 스냅 샷을 이용한 읽기를 사용하지 못하기 때문에 일관된 읽기(Consistent read)가 무시
### 2.2. INSERT 쿼리의 잠금
#### INSERT ...
- INSERT 문장은 기본적으로 베타적 레코드 잠금을 사용
- 테이블에 프라이머리 키나 유니크 키가 존재하면 중복 체크를 위해 공유 레코드 잠금을 먼저 획득해야 함
- 인서트 인텐션 락 (INSERT INTENTION LOCK) 잠금 방식 사용
- 인서트 인텐션 략은 INSERT를 실행할 의도를 지닌 쿼리가 획득해야 하는 잠금으로, 모든 INSERT 쿼리는 인서트 인텐션 락을 획득 후 INSERT를 실행, INSERT된 레코드에 대해서는 베타적 레코드 잠금을 자동으로 획득
- 인서트 인텐션 락은 갭락의 일종으로, 인서트 인텐션 락끼리는 서로 호환
- 인서트 인텐션 락을 사용하는 이유는 InnoDB의 갭 락으로 인한 동시성 감소를 최소화 하기 위해서
#### ISERT INTO ... ON DUPLICATE KEY UPDATE ...
- INSERT 하려는 레코드에 대해 중복된 키 값이 이미 있는지 판단하기 위해 공유 잠금을 걸어야 함
- 레코드가 존재하면 배타적 잠금을 걸고 업데이트 수행
- 레코드가 존재하지 않으면 일반적인 INSERT 문장과 같이 인서트 인덱션 락을 걸로 INSERT 실행, INSERT 된 레코드에 대해서 배타적 잠금을 획득
#### REPLACE
- REPLACE 문장에서는 중복된 키 값이 이미 있는지 판단하기 위해 공유 잠금을 걸어야 함
- 중복된 레코드가 존재하면 배타적 잠금을 걸고 레코드를 삭제, 나머지는 과정에서 필요한 잠금은 INSERT 문장과 마찬가지로 처리
#### INSERT INTO tb_new ... SELECT ... FROM tb_old ...
- tb_new 테이블에는 INSERT 때와 마찬가지로 새로 INSERT 되는 레코드에 대해 배타적 레코드 락을 획득
- 
#### REPLACE INTO tb_new ... SELECT ... FROM tb_old ...

## 3. InnoDB에서 데드락 만들기