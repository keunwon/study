# DDD START! 도메인 주도 설계 구현과 핵심 개념 익히기

## 1. 도메인 모델 시작
### 도메인
- 소프트웨어로 해결하고자 하는 문제 영역을 '도메인'
### 도메인 모델 패턴
- 도메인 모델은 아키텍처상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴
#### 아키텍처 구성
|계층(Layer)|설명|
|:---|:---|
|사용자인터페이스(UI) or 표현(Presentation)|사용자의 요청을 처리하고 사용자에게 정보를 보여줌|
|응용(Application)|사용자가 요청한 기능을 실행. 업무 로직을 직접 구현하지 않으며 도메은 계층을 조합해서 기능 실행|
|도메인|시스템이 제공할 도메인의 규칙을 구현|
|인프라스트럭처(Infrastructure)|데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리|
#### 도메인 모델 도출
- 도메인을 이해하고 이를 바탕으로 도메인 모델 초안을 만들어야 비로소 코드를 작성할 수 있음  
(구현을 하려면 도메인해 대한 초기 모델이 필요)
### 엔티티와 밸류
- 도출한 모델은 크게 엔티티와 밸류로 구분
#### 엔티티
- 엔티티는 서로 다른 식별자를 가짐 (ex. 주문 번호)
- 엔티티를 생성하고 엔티티의속성을 빠꾸고 엔티티를 삭제할 때까지 식별자는 유지
- 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있음
#### 엔티티의 식별자 생성
- 엔티티의 식별자를 생성하는 시점은 도메인의 특징과 사용하는 기술에 따라 달라짐
    - 특정 규칙에 따라 생성
    - UUID 사용
    - 값을 직접 입력
    - 일련번호 사용 (시퀀스나 DB의 자동 증가 컬럼 사용)
#### 밸류 타입
- 개념적으로 완전한 하나를 표현할 때 사용 
    - 받는 사람(이름 + 폰 번호)
    - 주소(우편주소 + 기본 주소 + 상세주소)
- 밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호 

## 2. 아키텍처 개요
### 네 개의 영역
- 아키텍처를 설계할 때 출현하는 전형적인 영역인 표현, 응용, 도메인, 인프라스트럭처의 4영역
### 계층 구조 아키텍처
- 인프라스트럭처에 의존하면 테스트의 어려움과 기능 확장의 어려움 두가지 문제가 발생함
### DIP
- DIP를 적용하면 저수준 모듈이 고수준 모듈에 의존하게 됨
    - 인프라스트럭처 영역에 의존할 때 발생했던 두가지 문제인 구현 교체가 어렵다는 문제와 테스트가 어려운 문제를 해소 가능
#### DIP 주의사항
- DIP를 잘못 생각하면 단순히 인터페이스와 구현 클래스를 분리하는 정도로 받아들일 수 있지만,  
DIP의 핵신은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함
#### DIP와 아키텍처
- 인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용 영역, 도메인 영역은 고수준 모듈
### 도메인 영역의 주요 구성 요소
<table>
<thead>
    <tr>
        <td>요소</td>
        <td>설명</td>
    </tr>
</thead>
<tbody>
    <tr>
        <td>엔티티 (ENTITY)</td>
        <td>
            고유의 식별자를 갖는 객체로 자신의 라이프사이클을 갖음 <br>
            도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 제공
        </td>
    </tr>
    <tr>
        <td>밸류 (VALUE)</td>
        <td>
            고유의 식별자를 갖지 않는 객체, 주로 개념적으로 하나의 도메인 객체의 속성을 표현할 때 사용
        </td>
    </tr>
    <tr>
        <td>애그리거트 (AGGREGATE)</td>
        <td>
            에그리거트는 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것 <br>
            ex. 주문과 같은 Order 엔티티, OrderLine 밸류, Orderder 밸류 객체를 '주문' 애그리거트로 묶음
        </td>
    </tr>
    <tr>
        <td>리포지터리 (REPOSITORY)</td>
        <td>
            도메인 모델의 영속성을 처리 (DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능)
        </td>
    </tr>
    <tr>
        <td>도메인 서비스 (DOMAIN SERVICE)</td>
        <td>
            특정 엔티티에 속하지 않은 도메인 로직을 제공 <br>
            '할인 금액 계산'은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데,  <br>
            도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직을 구현
        </td>
    </tr>
</tbody>
</table>

### 애그리거트
- 도메인이 커질수록 개발할 도메인 모델도 커지면서 많은 엔티티와 밸류가 출현함 (엔티티, 밸류 개수가 커지면 모델은 점점 복잡해짐)
- 도메인 모델에서 전체 구조를 이해하는데 도움이 되는 것이 바로 '애그리거트'
- 애그리거트는 관련 객체를 하나로 묶은 군집 (주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액)
    - 큰 틀에서 도메인 모델을 관리
- 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖음
### 리포지터리
- 도메인 객체를 지속적으로 사용하려면 RDBMS, NOSQL, 로컬 파일과 같은 물리적인 저장소에 도엠인 객체를 보관하는 이러한 도메인 모델을 리포지터리
### 인프라스트럭처 개요
- 인프라스트럭처는 표현 영역, 응용 영역, 도메인 영역을 지원 
### 모듈 구성
- 각 애그리거트와 모델과 리포지터리는 같은 패키지에 위치

## 3. 애그리거트
### 애그리거트
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요하는데 그 방법이 애그리거트
- 애그리거트에 속한 구성요서는 대부분 함께 생성하고 함께 제거
### 애그리거트 루트
- 애그리거에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티
#### 도메인 규칙와 일관성
- 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다
#### 애그리거트 루트의 기능 구현
- 애그리거트 루트가 구성요소의 상태만을 참조하지는 않음
- 기능 실행을 위함하기도 함
#### 트랜잭션 범위
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 함 (권장)
- 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아짐
- 만약 한 트랜잭션에서 두 개 이상의 애그리거트를 수정해야 한다면 응용 서비스에서 두 애그리거트를 수정하도록 구현해야 함

## 4. 리포지터리와 모델구현(JPA 중심)
### JPA를 이용한 리포지터리 구현
#### 모듈 위치
- 애그리거트와 같이 도메인 영역에 속하고, 리프지터리를 구현한 클래스는 인프라스트럭처 영역에 속함
- 리포지터리 인터페이스는 애그리거트 루트를 기준으로 작성


## 5. 리포지터리의 조회 기능(JPA 중심)
## 6. 응용 서비스와 표현 영역
## 7. 도메인 서비스
## 8. 애그리거트 트랜잭션 관리
## 9. 도메인 모델과 BOUNDED CONTEXT
## 10. 이벤트
## 11. CQRS