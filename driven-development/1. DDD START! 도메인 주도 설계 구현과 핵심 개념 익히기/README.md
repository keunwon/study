# DDD START! 도메인 주도 설계 구현과 핵심 개념 익히기

## 1. 도메인 모델 시작
### 도메인
- 소프트웨어로 해결하고자 하는 문제 영역을 '도메인'
### 도메인 모델 패턴
- 도메인 모델은 아키텍처상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴
#### 아키텍처 구성
| 계층(Layer)                         | 설명                                                     |
|:----------------------------------|:-------------------------------------------------------|
| 사용자인터페이스(UI) or 표현(Presentation)  | 사용자의 요청을 처리하고 사용자에게 정보를 보여줌                            |
| 응용(Application)                   | 사용자가 요청한 기능을 실행. 업무 로직을 직접 구현하지 않으며 도메은 계층을 조합해서 기능 실행 |
| 도메인                               | 시스템이 제공할 도메인의 규칙을 구현                                   |
| 인프라스트럭처(Infrastructure)           | 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리                    |
#### 도메인 모델 도출
- 도메인을 이해하고 이를 바탕으로 도메인 모델 초안을 만들어야 비로소 코드를 작성할 수 있음  
(구현을 하려면 도메인해 대한 초기 모델이 필요)
### 엔티티와 밸류
- 도출한 모델은 크게 엔티티와 밸류로 구분
#### 엔티티
- 엔티티는 서로 다른 식별자를 가짐 (ex. 주문 번호)
- 엔티티를 생성하고 엔티티의속성을 빠꾸고 엔티티를 삭제할 때까지 식별자는 유지
- 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있음
#### 엔티티의 식별자 생성
- 엔티티의 식별자를 생성하는 시점은 도메인의 특징과 사용하는 기술에 따라 달라짐
    - 특정 규칙에 따라 생성
    - UUID 사용
    - 값을 직접 입력
    - 일련번호 사용 (시퀀스나 DB의 자동 증가 컬럼 사용)
#### 밸류 타입
- 개념적으로 완전한 하나를 표현할 때 사용 
    - 받는 사람(이름 + 폰 번호)
    - 주소(우편주소 + 기본 주소 + 상세주소)
- 밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호 (불변 객체)
    - 불변 객체를 사용하면 안전한 코드를 작상 가능
    - 불변 객체는 참조 투명성과 스드 안전한 특징을 가짐
#### DTO의 get/set 메서드
- DTO는 Data Transfer Object의 약자로 프레젠테이션 계층과 도메인 계층이 서로 주고답을 때 사용하는 일종의 구조체
- DTO가 도메인 로직을 담고 있지는 않기에 get/set 메서드를 제공해도 도메인 객체의 데이터 일관성에 영향을 줄 가능성이 높지않음
- set을 만드는 대신 해당 기능을 최대한 활용하여, DTO도 불변 객체가 되어 불변의 장점을 DTO까지 확장 가능
### 도메인 용어
- 알맞은 영어 단어를 찾는 것은 쉽지 않은 일이지만 시간을 들여 찾는 노력이 필요
- 도메인과 어울리지 않는 단어를 사용하면 코드는 도메인과 점점 멀어짐
- 도메인 용어에 알맞은 단어를 찾는 시간을 아까워하지 말자

## 2. 아키텍처 개요
### 네 개의 영역
- 아키텍처를 설계할 때 출현하는 전형적인 영역인 표현, 응용, 도메인, 인프라스트럭처의 4영역
- UI영역은 사용자의 요청을 받아 응용 영역에 전달, 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 함
- 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직을 수행을 위임
- 도메인 영역은 도메인 모델을 구현 (도메인 모델은 도메인의 핵심 로직을 구현)
- 인프라스트럭처 영역은 구현 기술에 대한 것을 다룸
    - RDMS 연동 처리
    - 메시징 큐 전송하거나 수신하는 기능을 구현
### 계층 구조 아키텍처
- 도메인 복잡도에 따라 응용과 도메인 분리하기도 하고 한 계층으로 합치기도 함
- 상위 계층에 의존하지 않음
    - 표현 계층은 응용 계층에 의존
    - 응용 계층이 도메인 계층에 의존
    - 인프라스트럭처 계층이 도메인에 의존하거나 도메인이 응용 계층에 의존하지 않음
- 인프라스트럭처에 의존하면 테스트의 어려움과 기능 확장의 어려움 두가지 문제가 발생함
### DIP
- DIP를 적용하면 저수준 모듈이 고수준 모듈에 의존하게 됨
    - 인프라스트럭처 영역에 의존할 때 발생했던 두가지 문제인 구현 교체가 어렵다는 문제와 테스트가 어려운 문제를 해소 가능
#### DIP 주의사항
- DIP를 잘못 생각하면 단순히 인터페이스와 구현 클래스를 분리하는 정도로 받아들일 수 있지만,  
DIP의 핵신은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함
#### DIP와 아키텍처
- 인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용 영역, 도메인 영역은 고수준 모듈
### 도메인 영역의 주요 구성 요소
<table>
<thead>
    <tr>
        <td>요소</td>
        <td>설명</td>
    </tr>
</thead>
<tbody>
    <tr>
        <td>엔티티 (ENTITY)</td>
        <td>
            고유의 식별자를 갖는 객체로 자신의 라이프사이클을 갖음 <br>
            도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 제공
        </td>
    </tr>
    <tr>
        <td>밸류 (VALUE)</td>
        <td>
            고유의 식별자를 갖지 않는 객체, 주로 개념적으로 하나의 도메인 객체의 속성을 표현할 때 사용
        </td>
    </tr>
    <tr>
        <td>애그리거트 (AGGREGATE)</td>
        <td>
            에그리거트는 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것 <br>
            ex. 주문과 같은 Order 엔티티, OrderLine 밸류, Orderder 밸류 객체를 '주문' 애그리거트로 묶음
        </td>
    </tr>
    <tr>
        <td>리포지터리 (REPOSITORY)</td>
        <td>
            도메인 모델의 영속성을 처리 (DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능)
        </td>
    </tr>
    <tr>
        <td>도메인 서비스 (DOMAIN SERVICE)</td>
        <td>
            특정 엔티티에 속하지 않은 도메인 로직을 제공 <br>
            '할인 금액 계산'은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데,  <br>
            도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직을 구현
        </td>
    </tr>
</tbody>
</table>

#### 엔티티와 밸류
- DB 테이블의 엔티티와 도메인 모델의 엔티티는 같은 것이 아님
- 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함꼐 제공
### 애그리거트
- 도메인이 커질수록 개발할 도메인 모델도 커지면서 많은 엔티티와 밸류가 출현함 (엔티티, 밸류 개수가 커지면 모델은 점점 복잡해짐)
- 도메인 모델에서 전체 구조를 이해하는데 도움이 되는 것이 바로 '애그리거트'
- 애그리거트는 관련 객체를 하나로 묶은 군집 (주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액)
    - 큰 틀에서 도메인 모델을 관리
- 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖음
    - 루트 엔티티에는 애크리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야할 기능을 제공
### 리포지터리
- 도메인 객체를 지속적으로 사용하려면 RDBMS, NOSQL, 로컬 파일과 같은 물리적인 저장소에 도엠인 객체를 보관하는 이러한 도메인 모델을 리포지터리
### 인프라스트럭처 개요
- 인프라스트럭처는 표현 영역, 응용 영역, 도메인 영역을 지원 
### 모듈 구성
- domain 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성
- 각 애그리거트와 모델과 리포지터리는 같은 패키지에 위치

## 3. 애그리거트
### 애그리거트
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요하는데 그 방법이 애그리거트
- 애그리거트에 속한 구성요서는 대부분 함께 생성하고 함께 제거
- 한 애그리거트에 속한 개체는 다른 애그리거트에 속하지 않음
### 애그리거트 루트
- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티
#### 도메인 규칙와 일관성
- 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다
- 애그거트 루트가 제공하는 메서드는 규칙에 따라 에그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 함
#### 애그리거트 루트의 기능 구현
- 애그리거트 루트가 구성요소의 상태만을 참조하지는 않음, 기능 실행을 위함하기도 함
#### 트랜잭션 범위
- 트랜잭션 범위는 작을수록 좋음
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 함 (권장)
    - 만약 한 트랜잭션에서 두 개 이상의 애그리거트를 수정해야 한다면 응용 서비스에서 두 애그리거트를 수정하도록 구현해야 함
- 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아짐

## 4. 리포지터리와 모델구현(JPA 중심)
### JPA를 이용한 리포지터리 구현
#### 모듈 위치
- 애그리거트와 같이 도메인 영역에 속하고, 리프지터리를 구현한 클래스는 인프라스트럭처 영역에 속함
- 리포지터리 인터페이스는 애그리거트 루트를 기준으로 작성

## 5. 리포지터리의 조회 기능(JPA 중심)
### 검색을 위한 스펙
- 검색 조건의 조합이 다양할 경우 스펙을 이용해서 해결

## 6. 응용 서비스와 표현 영역
### 표현 영역과 응용 영역
- 표현 영역은 사용자의 요청을 해석
### 응용 서비스의 역할
- 사용자가(클라이언트)가 요청한 기능을 실행
- 사용자의 요청을 처리하기 위해 리포지터리로부터 도메인 객체를 구하고, 도메인 객체를 사용
- 응용 서비스는 주로 도메인 객체 간의 흐름을 제어하기 때문에 단순한 형태를 가짐
- 응용 서비스의 주된 영할 중 하나는 트랜잭션 처리
### 응용 서비스의 구현
- 응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 함
- 응용 서비스 자체는 복잡한 로직을 수행하지 않기 때문에 응용 서비스의 구현은 어렵지 않음
#### 응용 서비스의 인터페이스와 클래스
- 인터페이스가 명확하게 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 설계
#### 표현 영역에 의존하지 않기
- 응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용 X
- HttpServletRequest or HttpSession을 응용 서비스에 파라미터로 전달 X
### 표현 영역
- 표현 영역의 책임
    - 사용자가 시스템을 사용할 수 있는 (화면) 흐름을 제공하고 제어
    - 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공
    - 사용자의 세션을 관리
### 값 검증
- 표현 영역, 응용 서비스 두 곳에서 모두 수행 가능
    - 표현 영역: 필수 값, 값의 형식, 범위 등 검증
    - 응용 서비스: 데이터의 존재 유무와 같은 논리적 오류 검증
- 원천적으로 모든 값에 대한 검증은 응용 서비스에서 처리
#### 조회 전용 기능과 응용 서비스
- 서비스에서 수행하는 추가적인 로직이 없을뿐더러 조회 전용 기능이어서 트랜잭션이 필요하지도 않은 경우 굳이 서비를 만들지 않고 표현 영역에서 조회 전용 기능을 사용해도 된다

## 7. 도메인 서비스
### 여러 애그거가 필요한 기능
- 도메인 영역의 코드를 작성하다 보면 한 애그리거트로 기능을 구현할 수 없을 때가 있음
- 애그거에 넣기에 애한 도메인 기능을 특정 애그거에서 억지로 구현 X
### 도메인 서비스
- 한 애그리거트에 넣기 애매한 도메인 개념을 구현하려면 애그리거트에 억지로 넣기보다는 도메인 서비스를 이용해서 도메인 개념을 명시적 사용
#### 도메인 서비스의 패키지 위치
- 도메인 서비스는 도메인 로직을 실행하므로 도메인 서비스의 위치는 다른 도메인 구성 요서와 동일한 패키지에 위치

## 9. 도메인 모델과 BOUNDED CONTEXT
### 도메인 모델과 경계
- 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수 도 없음
### BOUNDED CONTEXT
- BOUNDED CONTEXT는 모델의 경계를 결정하며 한 개의 BOUNDED CONTEXT는 논리적으로 한 개의 모델을 갖음
### BOUNDED CONTEXT의 구현
- BOUNDED CONTEXT는 도메인 모델뿐만 아니라 도메인 기능을 사용자에게 제공하는데 필요한 표현 영역, 응용 서비스, 인프라 영역 등을 모두 포함
### BOUNDED CONTEXT 간 관계
- 상류 컴포넌트는 서비스 공급자 역할, 하류 컴포넌트는 그 서비스를 사용하는 고객 역할
- 상류 컴포넌트의 서비스는 상류 BOUNDED CONTEXT의 도메인 모델을 따름
- 나의 모델이 깨지는 것을 막아주는 안티코럽션 계층이 있음

## 10. 이벤트
### 시스템 간 강결합의 문제
- BOUNDED CONTEXT 간에 강한 결합을 이벤트를 이용하여 낮춤
### 이벤트 개요
#### 이벤트 관련 구성요서
- 도메인 모델에서 이벤트 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체
- 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트 발생
- 이벤트 핸들러는 이벤트 생성 주체가 발생한 이벤트에 반응
- 이밴트 생성 주체와 이벤트 핸들러를 연결하는 것이 이벤트 디스패처
    - 디스패치 구현에 따라 비/동기 실행
#### 이벤트 용도
1. 트리거
- 도메인의 상태가 바뀔 때 다른 후처리를 해야 할 경우 후처리를 실행하기 위한 트리거로 이벤트를 사용
2. 다른 시스템 간의 데이터 동기화
- 외부 서비스에 바뀐 정보를 전송
#### 이벤트 장점
- 도메인 로직이 섞이는 것을 방지

## 11. CQRS
- 도메인 관점에서 상태 변경 기능은 주로 애그리거트의 상태를 변경
- 단일 모델을 사용할 때 발생하는 복잡도를 해결하기 위해 사용하는 방법이 CQRS
- 상태를 변경하는 명령(Command)을 위한 모델과 상태를 제공하는 조회(Query)를 위한 모델을 분리하는 패턴
- 조회 모델에는 응용 서비스가 존재하지 않음
### 웹과 CQRS
- 일반적인 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 많음
- 대규모 트래픽이 발생하는 웹 서비스는 알게 모르게 CQRS를 적용
    - 메모리에 조회 데이터를 캐시해서 응답 속도를 높임 (조회 전용 저장소를 따로 사용)
    - 명시적으로 명령 모델과 조회 모델을 구분하지 않을 뿐
### CQRS 장단점
#### 장점
- 명령 모델을 구현할 때 도메인 자체에 집중
- 조회 성증을 향상사키는데 유리
    - 조회 단위로 캐시 기술을 적용 가능
    - 조회 특화 쿼리를 마음대로 사용
    - 조회를 위한 코드가 명령 모델에 영향을 주지 않음
#### 단점
- 구현해야 할 코드가 많음
- 도메인이 단순하거나 트래픽이 많지 않은 서비스라면 조회 전용 모델을 만들 이유가 없음
- 더 많은 구현 기술이 필요함
    - 조회 모델은 다른 구현 기술을 사용해서 구현하기도 함
    - 다른 저장소를 사용
    - 데이터 동기화를 위해 메시징 시스템을 도입
